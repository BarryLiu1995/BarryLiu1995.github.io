<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《前端性能优化原理与实践》掘金小册思维导图]]></title>
    <url>%2F2019%2F03%2F09%2F%E3%80%8A%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E6%8E%98%E9%87%91%E5%B0%8F%E5%86%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最近阅读了一本《前端性能优化原理与实践》的掘金小册，书中能够极好地为前端开发人员在脑海中建立一个 Web 前端性能优化的“索引表”。同时在阅读的过程中，根据文中的重要知识点使用 XMind 软件创建了思维导图，于是分享出去，希望可以帮助到大家。 知识点概览 性能优化方案——网络篇 性能优化方案——存储篇 性能优化方案——渲染篇 最后书本的知识只是给我们建立了性能优化的“索引表”，因此还需自身不断去深入学习每个知识点的方方面面。同时我认为性能优化本身是一门工程学，因此在理论装备大脑的同时去实践各个性能优化方案，才能够加深对理论的理解。（脑图中知识点如有错误，可及时邮件 ssdf90771@gmail.com 与我交流） 原文件：《前端性能优化原理与实践》思维导图，提取码: emam]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】HTTP 简史]]></title>
    <url>%2F2019%2F01%2F28%2FHTTP-%E7%AE%80%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[每一个技术诞生的背后，都有其历史。了解技术背后的历史，也有助于我们了解技术的本质。同时，译文如有翻译不当，欢迎提出修改意见。 超文本传输协议（HTTP）是 Internet 上最普遍和广泛采用的应用程序协议之一：它是客户端和服务器之间的通用语言，支持现代 Web。从简单的单一关键字和文档路径开始，它已成为不仅适用于浏览器，而且适用于几乎所有连接互联网软硬件应用的协议。 在本章中，我们将简要介绍一下 HTTP 协议的演变历程。对不同 HTTP 语义的完整讨论超出了本书的范围，但是理解 HTTP 的关键设计变更以及每个变更背后的动机将为我们讨论 HTTP 性能提供必要的背景，特别是在当前即将到来的 HTTP/2 时代讨论其带来的许多改进。 HTTP 0.9——单行协议Tim Berners-Lee 最初的 HTTP 提案在设计时考虑到了简单性，以帮助他实现他的另一个新想法——万维网。该策略似乎有效——有抱负的协议设计者，请注意。 1991年，Berners-Lee 概述了新协议的设计动机并列出了几个高级设计目标：文件传输功能，请求索引搜索超文本存档的能力，格式协商以及将客户端引用到另一个服务器的能力。为了证明该理论的实际应用效果，他构建了一个简单的原型，它实现了所提议功能的一小部分： 客户端请求是单行 ASCII 字符串 客户端请求行以 CRLF 结束 服务器响应是 ASCII 字符流 服务器响应体是一种超文本标记语言（HTML） 文档传输完成后终止连接 虽然，听起来很复杂。但这些规则创建的是一个非常简单的，Telnet 友好的协议，一些 Web 服务器在当天就支持了这一协议： 12345678$&gt; telnet google.com 80Connected to 74.125.xxx.xxxGET /about/(hypertext response)(connection closed) 该请求只由一行组成：GET 方法和所请求文档的路径。响应是单个超文本文档——没有标题或任何其他元数据，只有 HTML。它真的不能变得更简单。同时，由于这些规则是预期协议的子集，因此它非正式地命名为 HTTP 0.9 版本。其余的，正如他们所说，是历史了。 从1991年这些不起眼的规则开始，HTTP 开始了自己的生命，并在未来几年迅速发展。让我们快速回顾一下 HTTP 0.9 的特性： 客户端——服务端，请求——响应协议 ASCII 协议，通过 TCP/IP 链路运行 旨在传输超文本文档（HTML） 每次请求后，服务器和客户端之间的连接都将关闭 流行的 Web 服务器，如 Apache 和 Nginx，仍然支持部分 HTTP 0.9 协议 - 原因是协议内容并没有多少！如果您好奇，请打开 Telnet 会话并尝试通过 HTTP 0.9 访问 google.com 或您自己喜欢的网站，并体验早期协议的行为和限制 HTTP/1.0——快速增长和信息化 RFC1991年至1995年期间是 HTML 规范、一种被称为“网络浏览器”的新型软件的快速共同进化，以及面向消费者的公共互联网基础设施的出现和快速增长。 完美风暴：20世纪90年代初的互联网热潮在 Tim Berner-Lee 最初的浏览器原型的基础上，国家超级计算应用中心（NCSA）的一个团队决定开发他们自己的版本。因此，第一个流行的浏览器诞生了——NCSA Mosaic。1994年10月，NCSA 团队的一名程序员Marc Andreessen 与 Jim Clark 合作创建了 Mosaic Communications。该公司后来改名为 Netscape，并于1994年12月发布了 Netscape Navigator 1.0。到目前为止，情况已经很明了了——万维网必然不仅仅是学术上的好奇心。 事实上，同年第一次万维网会议在瑞士日内瓦举办，同时意味着万维网联盟（W3C）诞生了，该组织帮助指导 HTML 的发展。同样，在 IETF 内部建立了并行 HTTP 工作组（HTTP-WG）——专注于改进 HTTP 协议。这两个组织持续帮助万维网的发展。 最后，为了创造完美风暴，CompuServe，AOL 和 Prodigy 开始在1994-1995这个相同的时间范围内向公众提供拨号上网服务。凭借这股迅速应用的浪潮，Netscape 在1995年8月9日以非常成功的 IPO 创造了历史——互联网热潮已经到来，每个人都想要它的一部分！ 早期 Web 功能需求以及公共网站上访问数量的不断增加很快暴露了 HTTP 0.9 的许多基本限制——我们需要的协议不仅可以提供超文本文档，还可以提供有关请求和响应更丰富的元数据，启用内容协商等。反过来，早期 Web 开发人员社区在这一过渡时期设计了大量实验性的 HTTP 服务器和客户端实现——他们实现，部署，看看是否有其他人采用它。 从这段快速实验开始，一系列最佳实践和常见模式开始出现。1996年5月，HTTP 工作组（HTTP-WG）发布了 RFC 1945，它记录了当时出现的许多 HTTP/1.0 的“常见用法”。请注意，这只是写进了 RFC——HTTP/1.0，因为我们知道它不是正式规范或 Internet 标准！ 话虽如此，示例 HTTP/1.0 请求看起来应该非常熟悉： 1234567891011121314151617$&gt; telnet website.org 80Connected to xxx.xxx.xxx.xxxGET /rfc/rfc1945.txt HTTP/1.0 #具有HTTP版本号的请求行，后跟请求头User-Agent: CERN-LineMode/2.15 libwww/2.17b3Accept: */*HTTP/1.0 200 OK #响应状态，后跟响应头Content-Type: text/plainContent-Length: 137582Expires: Thu, 01 Dec 1997 16:00:00 GMTLast-Modified: Wed, 1 May 1996 12:45:26 GMTServer: Apache 0.84(plain-text response)(connection closed) 前面的例子只包含了 HTTP/1.0 协议部分内容，但它确实说明了一些协议关键改进。 请求可能包含多个换行符分隔的标题字段 响应添加了响应状态行作为前缀 响应本身有自己的一组换行符分隔的标题字段 响应内容不限于超文本 每次请求后，服务器和客户端之间的连接都将关闭 请求头和响应头都保存为 ASCII 编码，但响应内容本身可以是任何类型：HTML 文件，纯文本文件，图像或任何其他内容类型。因此，HTTP 的『超文本传输』名字在引入后不久就变成了用词不当。实际上，HTTP 已经迅速发展成为超媒体传输，但仍然沿用原有名称。 除了媒体类型协商之外，RFC 还记录了许多其他常用功能：内容编码，字符集支持，多部分类型，授权，缓存，代理行为，日期格式等。 今天，Web 上的几乎所有服务器都可以并且仍将使用 HTTP/1.0。除此之外，到现在为止，你应该知道更好！每个请求需要新的 TCP 连接会对 HTTP/1.0 造成严重的性能损失——依据于 TCP 拥塞控制的慢启动后的三次握手。 HTTP/1.1——互联网标准将 HTTP 转变为官方 IETF 互联网标准的工作与围绕 HTTP/1.0 的文档工作并行进行，并发生在大约四年的时间内——1995年至1999年。事实上，第一个正式的 HTTP/1.1 标准定义于 RFC 2068，在 HTTP/1.0 发布大约六个月后于1997年1月正式发布。然后，两年半之后，即1999年6月，该标准中包含了许多改进和更新，并作为 RFC 2616发布。 HTTP/1.1 标准解决了早期版本中发现的许多协议歧义，并引入了许多关键性能优化：keepalive 连接，分块编码传输，字节范围请求，附加缓存机制，传输编码和请求流水线。 有了这些功能，我们现在可以查看由任何现代 HTTP 浏览器和客户端执行的典型 HTTP/1.1 会话 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263$&gt; telnet website.org 80Connected to xxx.xxx.xxx.xxx#请求HTML文件，包含编码，字符集和cookie元数据GET /index.html HTTP/1.1 Host: website.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: en-US,en;q=0.8Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3Cookie: __qca=P0-800083390... (snip)#原始HTML请求的分块响应HTTP/1.1 200 OK Server: nginx/1.0.11Connection: keep-aliveContent-Type: text/html; charset=utf-8Via: HTTP/1.1 GWADate: Wed, 25 Jul 2012 20:23:35 GMTExpires: Wed, 25 Jul 2012 20:23:35 GMTCache-Control: max-age=0, no-cacheTransfer-Encoding: chunked#块中的八位字节数表示为 ASCII 十六进制数100 &lt;!doctype html&gt;(snip)100(snip)#分块流响应结束0 #请求在同一TCP连接上创建的图标文件GET /favicon.ico HTTP/1.1 Host: www.website.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)Accept: */*Referer: http://website.org/Connection: close #通知服务器不会重用连接Accept-Encoding: gzip,deflate,sdchAccept-Language: en-US,en;q=0.8Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3Cookie: __qca=P0-800083390... (snip)#图标响应，然后关闭连接HTTP/1.1 200 OK Server: nginx/1.0.11Content-Type: image/x-iconContent-Length: 3638Connection: closeLast-Modified: Thu, 19 Jul 2012 17:51:44 GMTCache-Control: max-age=315360000Accept-Ranges: bytesVia: HTTP/1.1 GWADate: Sat, 21 Jul 2012 21:35:22 GMTExpires: Thu, 31 Dec 2037 23:55:55 GMTEtag: W/PSA-GAu26oXbDi(icon data)(connection closed) 哎呀，那里有很多事情发生！第一个也是最明显的区别是我们有两个对象请求，一个用于 HTML 页面，另一个用于图像，两者都通过单个连接传递。这是连接 keepalive 的实际应用，它允许我们重用现有的 TCP 连接，以便对同一主机发出多个请求，并提供更快的最终用户体验；请参阅优化TCP。 要终止持久连接，请注意第二个客户端请求通过 Connection 字段向服务器发送显式关闭令牌。类似地，一旦传输响应，服务器就可以通知客户端关闭当前 TCP 连接的意图。从技术上讲，任何一方都可以在任何时候都不通过这样的方式来终止 TCP 连接，但是客户端和服务器应该尽可能地提供它以在双方上实现更好的连接重用策略。 HTTP/1.1 默认情况下将 HTTP 协议的语义更改为使用连接 keepalive。这意味着，除非另有说明（通过Connection: close 头部），服务器应默认保持连接打开。 但是，同样的功能也被反向移植到 HTTP/1.0 并通过 Connection: Keep-Alive 头部启用。因此，如果您使用 HTTP/1.1，从技术上讲，您不需要 Connection: Keep-Alive 头部，但许多客户仍然选择提供它。 此外，HTTP/1.1 协议添加了内容，编码，字符集，甚至语言协商，传输编码，缓存指令，客户端cookie，以及可以在每个请求上协商的十几种其他功能。 我们不打算详述每个 HTTP/1.1 功能的语义。这已经是可以专门用来写书的主题，同时市面上已经有很多很棒的书。相反，前面的示例可以很好地说明 HTTP 的快速进展和演变，以及每个客户端 - 服务器交换的错综复杂的舞蹈。那里有很多事情发生！ 有关 HTTP 协议所有内部工作原理的详细参考，请查看 David Gourley 和 Brian Totty 撰写的 O’Reilly 的《HTTP 权威指南》。 HTTP/2——提高运输性能自发布以来，RFC 2616 已经成为互联网空前增长的基础：数十亿台各种形状和大小的设备，从台式电脑到我们口袋里的小型网络设备，每天都会用 HTTP 来传送新闻，视频，以及数以百万计的我们生活中依赖的其他网络应用程序。 最初用于检索超文本的简单单行协议很快演变成通用的超媒体传输，现在十年后可以用来为你能想象的任何应用提供支持。大量服务器和广泛使用的客户端意味着现在许多应用程序都是专门在 HTTP 之上设计和部署的。 需要一个协议来控制你的咖啡壶？RFC 2324 已经涵盖了超文本咖啡壶控制协议（HTCPCP / 1.0） - 原本是 IETF 的愚人节笑话，并且在我们新的超链接世界中会有越来越多的笑话。 超文本传输协议（HTTP）是用于分布式的协作超媒体信息系统的应用程序级协议。它是一种通用的无状态协议，可以通过扩展其请求方法，错误代码和标头，用于超出其用于超文本的许多任务，例如名称服务器和分布式对象管理系统。 HTTP 的一个特性是数据表示的输入和协商，允许系统独立于正在传输的数据而构建 HTTP 协议的简单性使其成为最初的应用方案和快速增长。事实上，现在使用 HTTP 作为主要控制和数据协议的嵌入式设备（传感器、执行器和咖啡壶）并不罕见。但在它自身成功的重压下，随着我们越来越多地将日常互动迁移到网络上——社交、电子邮件、新闻和视频，以及包括越来越多的我们的整个个人和工作空间——它也开始显示出压力的迹象。用户和 web 开发人员现在都要求 HTTP/1.1 提供近乎实时的响应和协议性能，如果不进行一些修改, 它根本无法满足这些响应能力和协议性能。 为了应对这些新的挑战，HTTP 必须继续发展，因此，HTTPbis 工作组于2012年初宣布了 HTTP/2 的一项新举措: 在没有 HTTP/1.x 消息机制和语法的情况下保留 HTTP 语义的协议促成了新的实践经验和兴趣，这些机制和语法已被确定为妨碍了性能并鼓励滥用基础运输。 工作组将在当前有序的、双向的 HTTP 连接中生成 HTTP 当前语义的新规范。与 HTTP/1.x 一样，主要目标传输是 TCP，但应该可以使用其他传输。 HTTP/2 的主要重点是提高传输性能，实现更低的延迟和更高的吞吐量。新协议版本号的主要版本序号增加听起来是一个很大的更新。单就性能而言，确实现在和将来的变化都是一个很大的更新。但请注意，所有高级协议语义都不会受到影响：所有 HTTP 头部字段、值和用例都是相同的。 任何现有的网站或应用程序都可以而且将通过 HTTP/2 交付，而无需修改：您不需要修改应用程序标记以利用 HTTP/2。HTTP 服务器必须使用 HTTP/2，但这应该是对大多数用户的透明升级。如果工作组实现了其目标，唯一的区别应该是我们的应用程序以更低的延迟和更好地利用网络链接的方式交付！ 话虽如此，但我们不要走在前面。在我们使用新的 HTTP/2 协议之前，值得退一步，研究我们现有的 HTTP/1.1 自身的部署和性能最佳实践。HTTP/2 工作组在新规范方面进展迅速，但即使最终标准已经完成并准备就绪，在可预见的未来（实际上, 十年或更长时间），我们仍需使用较旧的 HTTP/1.1。 原文Brief History of HTTP]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回车与换行的故事]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%9B%9E%E8%BD%A6%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[日常生活中我们在进行文本输入的情况下，如果需要文本换行继续输入文字的话只需按下Enter键。然而这个动作在不同平台下对应的控制字符有所不同，就是我们所说的 LF、CRLF，其中 LF（Line Feed）表示换行，CR（Carriage Return）表示回车。我就很纳闷：换行不就是另起一行再次输入码？为啥还有个回车。恰好网络上看到一篇很不错的详细讲解文本换行的博文，便转载供学习使用。 不知各位有没有过这样的经历： Linux 上创建的文件在 Windows 上打开时，结果所有内容会挤成一行。而 Windows 上创建的文件在 Linux上 打开时，每一行的结尾又多了一个奇怪字符^M。 在安装 Windows 版的git时，安装向导在某一步会提示你选择”Configuring the line ending conversions”，里面提到了 Windows-style 和 Unix-style 的 line endings，为什么会有这些呢？ 调用C语言的API fopen时，会有 text mode 和 binary mode，这两者有什么区别？ 其实这一切都和我们常说的回车换行有关，但你有没有很奇怪，什么是回车？直接用换行不就好了，为什么要分开两个词？我们使用的键盘上的键明明起得是换行的作用，为什么叫回车？千万别被绕晕了，本文将和大家讨论有关回车换行的一段有趣的历史，随后将回答这些问题。 历史我们通常所说的回车换行其实只相当于一个概念，即一行结束，开始下一行，英文叫做End-of-Line，简写为EOL。你也可以将这理解为一个逻辑上的换行，但为了与回车换行中的换行区分开来，我们后面还是称呼它为EOL。 打字机回车换行严格说起来是两个独立的概念，即回车和换行，它们的出现要追溯到计算机出现之前，那时有一种电传打字机：Teletype Model 33 ASR，如下图： 在打字机上，有一个部件叫Carriage，它是打字头，相当于打字机的光标。每输入一个字符，Carriage就前进一格。当输满一行后，想要切换到下一行时，需要Carriage在两个方向上的运动：水平和竖直。水平方向上需要将Carriage移到一行的起始位置，竖直方向上需要纸张向上移动一行，此时也就是相当于Carriage下移了一行。（这在很多影视作品里面可以看到，打字者们打完一行之后，通常会用手拨动一个滑块，然后听到“咔”的一声，接着输入下一行。只是在这款打字机中不再需要人为的去拨动。）而这两个动作分别对应着： Carriage Return（CR），也即回车，它在 ASCII 表中的值为 0x0D，可以用转义符\r表示 Line Feed（LF），也即换行，它在 ASCII 表中的值为 0x0A，可以用转义符\n表示 因为打字机是机械的结构，所以虽然从逻辑上只表示为EOF，但从设计上它需要分为两个独立的操作，这也正是我们习惯连起来说回车换行的原因。可以参照下图看看其键盘的布局： 键盘的右方有一个Line Feed和Return，从名字可以看出，这分别对应着前面提到的两个操作。然而，通常一个回车操作不能够在一个字符打印的时间内完成，所以可以利用Carriage移动的时间，去完成另外一个完全独立的操作Line Feed，这也是通常Carriage Return会被放在Line Feed前面的原因。你可以想象，如果在在Carriage和纸移动的过程中按下了其它的字符键，打印的内容将变得十分混乱。所以在Carriage Return和Line Feed之后，有时会有1~3个 NUL 字符(即相当于汇编语言中的空指令，仅起占位作用)，以等待前两个操作的完成。所以实际上打字机的EOL为：EOL = CR + LF + 1~3NUL。 分歧出现等到早期的计算机发明时，很自然的这两个概念被拿了过来。但是由于那时的存储设备非常昂贵，一些人认为在每行的结尾加两个字符用于换行，实在是极大的浪费，于是各个厂商在这一点上便出现了分歧。 由于一些早期的微型计算机还没有用于隐藏底层硬件细节的设备驱动，所以它们直接沿用了打字机的惯例，使用不带 NUL 的CRLF作为一个EOL。而 CP/M 为了和这些微型计算机使用同一个终端，也采用了这种设计。所以它的克隆 MS-DOS 也同样使用CRLF，由于 Windows 又是基于 MS-DOS，为保持兼容性，所以就导致了如今的 Windows 是采用CRLF作为EOL，即\r\n(或0x0D 0x0A)。 而 Multics 在被设计之时就非常认真的考虑了这一问题，设计者们觉得只需一个字符便完全足够来表示EOL，这样更加合理。那么选择CR还是LF呢？本来由于那时的键盘上都有一个Return键，所以可能更好的选择是CR。但当时考虑到CR可以用来重写一行，以完成如粗体和删除线等效果，所以他们选择了稍稍难以理解的LF。然后自己设计了一个设备驱动程序来将LF转换为各种打字机所需要的EOL，这个方案非常完美，当然除了LF稍微奇怪一些。随后一脉相承的 Unix和 Linux 们都继承了这个选择，于是你在这些操作系统上可以发现每一行的结尾是一个LF，即\n(或0x0A)。 Mac 系统的选择就更加复杂一些。Apple 在设计 Mac OS 时，他们采用了一个最容易理解的选择：CR，即\r(或0x0D)。但这只维持到 Mac OS 9，后一个版本的 Mac OS X 基于 Mach-BSD内核，所以此后版本的 Mac OS X 在每行的结尾存储了与 Linux 一样的LF，即\n(或0x0A)。 混乱的状况还有很多其它的操作系统采用更加不同的方案，这也导致了混乱的产生，文章开始提出的几个问题便由该混乱引起。因为 Linux 和 Mac OS X 上使用的是LF，而 Windows 上使用的是CRLF，那么 Linux 和 Mac OS X 上创建的文件在 Windows 上打开时，由于每一行的结尾只有一个LF，但 Windows 只认识CRLF，所以便不会有逻辑上的换行处理，故所有的文字被挤到了一行。反过来，如果 Windows 上的文件在 Linux 和 Mac OS X 上打开时，仅需LF便可换行，那么每一行的结尾便多了一个CR，对应的ASCII码为^M。 而 git 的安装向导会特意有一个这样的提醒页面也出于此，因为一个项目可能有多个开发者，每个开发者可能使用的是不同的系统，那么开发者 checkout 代码时，如果不做换行符的转换，有可能就会出现只有一行或者行尾多了^M的情况。当然，如果你有一个可以识别多种EOL的现代文本编辑器，那么不做转换也无妨(notepad不行)。 如果出现了上面的转换问题时，也别着急，可以对文件进行转换。那在我们写程序时如何正确的处理这些问题？像隐藏硬件细节的驱动程序一样，我们可寄希望于高级语言。 统一为了避免在这些不同的实现中挣扎，高级语言给我们带来了福音，它们各自使用了统一的方式来处理EOL。在C语言中，你一定知道在字符串中如果要增加一个换行符的话，直接用\n即可，比如： 1printf("This is the first line! \nThis is a new line!"); 上面的输出将是： 12This is the first line!This is a new line! 为什么 C 语言选择了\n而不是\r？这绝非偶然。熟悉 C 语言历史的朋友可能知道当初 C 语言是Dennis Ritchie为开发 Unix 而设计，所以它沿用了 Unix 上EOL的惯例便很容易理解了。而我们知道 Unix 使用的LF的ASCII码为0x0A，转义符为\n，因此 C 语言中也使用\n作为换行。 Text Mode &amp; Binary Mode但是，千万别简单的认为上面的\n最终写到文件中就一定是其 ASCII 码0x0A，或者文件中的0x0A被读到内存中就是其转义符\n。这取决于你打开文件的方式。在 C 语言中，在对文件进行读取操作之前，都需要先打开文件，可以使用下面的函数： 12#inlcude &lt;stdio.h&gt;FILE *fopen(const char *path, const char *mode); 注意看第二个参数mode，它是一个字符指针，通常可以为读(r)，写(w)，追加(a)或者读写(r+, w+, a+)，仅指定这些参数时，文件将被当成是文本文件来操作，即Text Mode，而如果在这些参数之外再指定一个额外的b时，文件便会被当成是二进制文件，即Binary Mode。这两种模式的区别在哪里呢？这里稍稍有些复杂，因为它们在不同的平台上表现不同。 Windows 平台对于 Windows 平台，因为其使用CRLF来表示EOL，故对于Text Mode需要做一定的转换才能够与 C 语言保持一致。接下来的两个图可以给出最为直观的描述。 先看二者对于读操作的区别： READ LF CRLF “r”——text mode LF LF “rb”——binary mode LF CRLF Text Mode下，C 语言会尝试去“理解”这些回车与换行，它会知道LF和CRLF都可能是EOL，所以不管文件中是LF还是CRLF，被读进内存时都会变成LF。而Binary Mode下，C 语言不会做任何的“理解”，所以这些字符在文件中什么样，读到内存中依然那样。 接下来是写操作的区别： WRITE LF CRLF “w”——text mode CRLF CRCRLF “wb”——binary mode LF CRLF Text Mode下，内存中的每一个LF写入文件中时都会变为CRLF，当然，如果不幸内存中为CRLF，以此种模式写入到文件中时就会变成CRCRLF（注意：这里不是CRLF。原因我想大概是如果你认为内存中的数据是文本，那么它一定是以LF作为EOL，CR也一定是你有意而为之，是个有意义的字符，所以它并不会处理。）。而Binary Mode下，内存中的内容会被原封不动的写到文件中。 所以为了保证一致性，一定需要注意配套使用读和写，即读和写采用同一种模式打开文件。 Linux 和 Mac OS X 平台因为 Linux 和 Mac OS X 平台与 C 语言对待EOL的方式完全一致，所以Text Mode和Binary Mode在这些平台下没有任何区别，可以参考fopen的man page。实际上，所有遵循 POSIX 的平台都忽略了b这个参数。 虽说在这些平台上处理EOL非常简单，但是如果你的程序需要移植到其它非POSIX平台上时，请务必正确对待b参数。 原文来源知无涯之回车换行的故事]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见2018]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%AF%B7%E5%9B%9E%E7%AD%942018%2F</url>
    <content type="text"><![CDATA[又到了一年的年底，年底的固定活动——写年底总结，就又得安排一下，这不，趁元旦假期第一天就给安排上了 其实到了每年的年底，以往的我并没有什么特别的感受，觉得又到了放寒假的时候了。只是从去年开始，到了年底就感觉心中多了一些说不清道不明的情绪，可能只是因为自己知道自己将要离开学校，独自承担生活的全部而产生的不安而又有些憧憬的情绪。 工作2018年，我毕业了。从今年年初开始进入到校招公司实习，到六月份毕业典礼那天通知被裁，到现在在新的公司工作接近半年时间。这一年的时间，真的是感受到了生活的酸甜苦辣。现在回忆起来，心中只是多了份平淡，觉得或许这才是生活，说起来还得感谢毕业前夕被裁的经历。被裁后的半个多月里情绪非常低落，甚至有放弃程序员职业的念头，但还好自己头脑还算清醒，知道自己想要的是什么。 被裁后找了一家离学校不是很远的小公司。面试的时候由于毕业前在前东家四个月左右的项目经历还是让自己在找工作时具备一定的竞争力。所以现在想想，我还是挺幸运的，幸运的就是我当初选择了提前过去校招公司实习而获得能力的提升和经验的收获。 刚开始进入新东家的时候，还是及其不适应公司环境、氛围。由于当时找工作找得比较急，并没有好好考虑新东家是不是真的适合我，入职后才发现自己好像掉进了一个大坑。其实在新东家面试时，面试官的异常表现就应该让我警醒。因为入职的部门具有一些外包背景，同时公司内部前端人员的数量并不多，因此新东家在前端方面并没有任何的技术积累、规范以及相关的高级技术人员，也毫不考虑技术人员的培养工作。然而即使这样，公司前端项目使用的还是前端框架中学习成本比较大的 Angular。因此在入职一两个星期内都在纠结是否应该继续留下来，后来由于自己急需收入，因此还是选择留下。对于从未使用过 Angular 的我，一开始参与项目开发是有些懵的，然而由于以往自己的 Android 开发经历，以及下班后阅读官方文档系统学习 Angular 开发的经历，一段时间后就开始步入了正轨。到如今，自己算是掌握了 Angular 的基本使用，同时也开始在公司内部推行自己根据项目经验制定的开发标准，同时还写了一些工具应用来加速公司日常工作中前端项目的工作流程。因此，这半年我看到了自己的成长，虽然并没有立即产生什么大的效益。但这半年新的开发经历让我对技术有了更深层次的理解。我相信，这些深层次的理解、总结，并且应用到实际工作中，才是我职业生涯中最宝贵的财富。喜欢总结，并将提炼出来的知识应用于实际工作，或许是程序员成长应该走的道路。 除了工作，利用业余时间也学了 Node 开发，Nginx 使用，web 后端的部署、运维等等。虽然点亮的技能树不算多，但基本上都会去深入实践对应的技能点，因此在自己毕业前一个月趁还能用学生证薅羊毛，在腾讯云购买了一台云主机好让自己折腾。比如，毕业后找房子是件极其痛苦的事，因此自己还花了好几天时间用 node 写了个豆瓣租房论坛的爬虫程序，后来又把它扩展成一个接口，然后自己用 vue 写了个搜索页面来调用自己写的爬虫接口。上个月又把前端页面用 Angular 给重构了，不过还没把这个新的坑给填完。所以，我觉得作为一名程序员是一件幸福的事，毕竟有这么多“玩具”可以慢慢玩，虽然有时候这么多“工具”也成为了“幸福”的烦恼。 未来新的一年，应该会将学习重心放到计算机核心基础上，例如计算机网络和操作系统、算法……毕竟最近在阅读完前端“娱乐圈”中大火的《停止学习框架》文章后，还是蛮认同文章的观点。 生活其实毕业后一个最大的感受就是：时间好像就不是你自己的了。工作后，由于每天两点一线的生活，让你感觉时间过的飞快，比以往学生时代都感觉快得多。同时自己突然就害怕，工作后时间过的这么快，害怕十几二十年就这么过去，然而自己还有很多想要做的事来不及做。 同时自己也是兴趣比较广泛，一直都想学一门乐器或者学舞蹈。这里立个flag，明年这时候一定能把尤克里里玩得比较溜。 毕业后，虽然工作，学习占了个人大多数的时间，但希望新的一年，自己能够抓住时间“及时行乐”……]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[控制反转和依赖注入]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在学习 Angular 框架的过程中了解到了依赖注入的概念，并上网搜索了相关知识，因此还了解到了 IoC。本文摘抄了一些博文段落以形象的讲解了 IoC/DI 机制。 博文一IoC 是什么IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好 IoC 呢？理解好 IoC 的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 IoC 容器来控制对 象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 IoC 能做什么IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。 IoC 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC 和 DIDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于 IoC 容器； ●为什么需要依赖：应用程序需要 IoC 容器来提供程序内对象需要的外部资源； ●谁注入谁：很明显是 IoC 容器向应用程序注入某个依赖的对象； ●注入了什么：就是注入应用程序中某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC 和 DI 有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。 博文二IoC首先想说说 IoC（Inversion of Control，控制反转）。这是 spring 的核心，贯穿始终。所谓IoC，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号………，想办法认识她们，投其所好送其所要……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么 IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 DIIoC 的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象 A 需要操作数据库，以前我们总是要在 A 中自己编写代码来获得一个 Connection 对象，有了 spring 我们就只需要告诉spring，A 中需要一个 Connection，至于这个 Connection 怎么构造，何时构造，A 不需要知道。在系统运行时，spring 会在适当的时候制造一个 Connection，然后像打针一样，注射到 A当中，这样就完成了对各个对象之间关系的控制。A 需要依赖 Connection 才能正常运行，而这个 Connection 是由spring注入到A中的，依赖注入的名字就这么来的。那么 DI 是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring 就是通过反射来实现注入的。 博文三在平时的 java 应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用 spring 的时候，每个对象在需要使用他的合作对象时，自己均要使用像 new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了 spring 之后就不一样了，创建合作对象B的工作是由 spring 来做的，spring 创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，spring 就从存放对象的那个容器里面取出 A 要使用的那个 B 对象，然后交给A对象使用，至于 spring 是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到 spring 给我们的对象之后，两个人一起协作完成要完成的工作即可。 所以控制反转 IoC(Inversion of Control) 是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了 IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC 容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖 IoC 容器了，通过 IoC 容器来建立它们之间的关系。 这是我对 spring 的 IoC(控制反转)的理解。DI(依赖注入)其实就是 IoC 的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。 总结IoC 和 DI 机制让我想起计算机世界的一个名言——“All problems in computer science can be solved by another level of indirection”，所有计算机科学问题都可以通过一个间接层来解决。 参考依赖注入和控制反转的理解，写的太好了。|CSDN]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在一台服务器上使用Nginx反向代理来部署多子域名下的web服务]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%A4%9A%E5%AD%90%E5%9F%9F%E5%90%8D%E4%B8%8B%E7%9A%84web%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[在单台服务器上部署多个web服务，或许有多种解决方案，其中今天接触到使用 Nginx 的反向代理功能来实现，所以总结一下实现的过程 概述相信很多拥有单台云服务器的小伙伴都有这样一个困扰：我只有一台物理机，HTTP 协议的默认 80 端口也只有一个，如果想要部署多个 web 服务最简单的就是以端口号区分。然而这样当访问起来的时候就显得特别不够优雅，比如我有个主域名：barryliu1995.studio，有一个二级域名 funhouse.barryliu1995.studio 解析的 IP 地址为我手上唯一一台物理机的 IP 地址。这样访问该服务器上的各个 web 服务都需要加个端口号：funhouse.barryliu1995.studio:8200、funhouse.barryliu1995.studio:4200 …… 这时我们就可以使用 Nginx 反向代理功能来部署多个 web 服务，摒弃上面用端口号来区分不同 web 服务的方法。大致如下图所示。 配置过程第一步：要有 Nginx 环境首先废话的是你的机子要有 Nginx，各 Linux 发行版本的安装方式不太一样，这里就不赘述。如果幸运的你跟我一样使用的是 CentOS 7.0+ 的话，可以参考这篇简短的 Nginx 入门教程 - 一个前端必会的 Nginx免费教程 |技术胖。 第二步：域名解析配置然后你还需要个域名。有了之后去域名管理商那里添加对应配置记录。以我个人为例，我的 barryliu1995.studio 是在阿里云买的，因此进入对应阿里云域名的管理页面即可。然后点击添加记录，并相对应填入两个子域名 resume.barryliu1995.studio 和 funhouse.barryliu1995.studio 解析记录。注意这个子域名的解析记录的记录值都是云主机的公网 IP。 添加结果如下所示： 填写记录： 第三步：Nginx 配置这里以 resume.barryliu1995.studio web 服务为例。首先我们现在 Nginx 的配置目录下新增 resume.conf 文件，该文件负责 web 服务。resume.conf 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 4200; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html/resume; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; 在相同目录下新增一个 resume_forward.conf 配置文件，该文件负责 resume.barryliu1995.studio 的反向代理工作，具体配置如下： 1234567891011121314server&#123; server_name resume.barryliu1995.studio; listen 80; location / &#123; # proxy_http_version 1.1; proxy_set_header Connection ""; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:4200$request_uri; #这里的端口号要跟对应的web服务相同 proxy_redirect off; &#125;&#125; 第四步：重启 Nginx由于更新了 Nginx 配置文件，所以需要重启一下。 第五步：验证效果这里就可以直接在浏览器试试效果啦 总结该文只是一个简单的教你如何在单台物理机上部署多子域名下的 web 服务，关于详细的 Nginx 配置原理各位请自行查找相关资料，毕竟我也是刚学 Nginx。如果连 Nginx 都不知道是什么以及还没有实践过的童鞋，可以去看看文章中提到的 Nginx 入门教程，如果是大佬的话，有空的话看看该文，也就当赐教菜鸟，可以针对本文出现的知识性错误提出修改意见。 最后本文参考于使用nginx来为你在一台服务器部署多个Web Server]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular中入口组件（entryComponents）与声明式组件的区别]]></title>
    <url>%2F2018%2F10%2F10%2FAngular%E4%B8%AD%E5%85%A5%E5%8F%A3%E7%BB%84%E4%BB%B6%EF%BC%88entryComponents%EF%BC%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在阅读 Angular 官方文档的过程中，其中 Angular 自定义元素|Angular章节的内容晦涩难懂，幸好现在互联网资料丰富，现在总结一下Angular加载组件的种类和不同。 概述Angular的声明式组件和入口组件的区别体现在两者的加载方式不同。 声明式组件是通过组件声明的selector加载 入口组件（entry component）是通过组件的类型动态加载 声明式组件声明式组件会在模板里通过组件声明的selector加载组件。 示例： 1234567@Component(&#123; selector: 'a-cmp', template: ` &lt;p&gt;这是A组件&lt;/p&gt; `&#125;)export class AComponent&#123;&#125; 12345678@Component(&#123; selector: 'b-cmp', template: ` &lt;p&gt;在B组件里内嵌A组件&lt;/p&gt; &lt;a-cmp&gt;&lt;/a-cmp&gt; `&#125;)export class BComponent&#123;&#125; 在BComponent的模板里，使用selector&lt;a-cmp&gt;&lt;/a-cmp&gt;声明加载AComponent。 入口组件（entryComponents)入口组件是通过指定的组件类加载组件。 主要分为三类： 在@NgModule.bootstrap里声明的启动组件，如AppComponent。 在路由配置里引用的组件 其他通过编程使用组件类型加载的动态组件 启动组件app.components.ts 123456@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss']&#125;)export class AppComponent&#123;&#125; app.module.ts 12345678910111213@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, BrowserAnimationsModule, AppRoutingModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 在bootstrap里声明的AppComponent为启动组件。虽然我们会在index.html里使用组件的selector&lt;app-root&gt;&lt;/app-root&gt;的位置，但是 Angular 并不是根据此 selector 来加载 AppComponent。这是容易让人误解的地方。因为 index.html 不属于任何组件模板，Angular 需要通过编程使用bootstrap里声明的AppComponent类型加载组件，而不是使用 selector。 由于 Angular 动态加载 AppComponent，所以AppComponent是一个入口组件。 路由配置引用的组件1234567891011@Component(&#123; selector: 'app-nav', template: ` &lt;nav&gt; &lt;a routerLink="/home" routerLinkActive #rla="routerLinkActive" selected="#rla.isActive"&gt;首页&lt;/a&gt; &lt;a routerLink="/users" routerLinkActive #rla="routerLinkActive" selected="#rla.isActive"&gt;用户&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `&#125;)export class NavComponent &#123;&#125; 我们需要配置一个路由 12345678910111213141516const routes: Routes = [ &#123; path: "home", component: HomeComponent &#125;, &#123; path: "user", component: UserComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; Angular根据配置的路由，根据路由指定的组件类来加载组件，而不是通过组件的selector加载。 配置入口组件在 Angular 里，对于入库组件需要在@NgModule.entryComponents里配置。 由于启动组件和路由配置里引用的组件都为入口组件，Angular会在编译时自动把这两种组件添加到@NgModule.entryComponents里。对于我们自己编写的动态组件需要手动添加到@NgModule.entryComponents里。 123456789101112131415161718@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, BrowserAnimationsModule, AppRoutingModule ], providers: [], entryComponents: [ DialogComponent ], bootstrap: [ AppComponent ] &#125;) export class AppModule &#123; &#125; 引自 Angular入口组件（entry component）和声明式组件的区别]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native vs. Cordova, PhoneGap, Ionic etc]]></title>
    <url>%2F2018%2F07%2F15%2FReact-Native-vs-Cordova-PhoneGap-Ionic-etc%2F</url>
    <content type="text"><![CDATA[最近在网络上看到(译)图解 React这篇介绍 React 的文章。用比喻以及插画的形式科普 React 的相关术语还是蛮有趣的。于是乎自己就翻译了文章原作者讲述 React 术语系列文章中的其余两篇——《What is React Native？》和《React Native vs. Cordova, PhoneGap, Ionic etc.》。本篇为《React Native vs. Cordova, PhoneGap, Ionic etc.》的译文，有翻译不对的地方欢迎指正！ 在上一篇文章中，我告诉过你，React Native 很棒，因为它允许我们使用原生 UI 构建应用程序。 React Native 应用程序的用户体验比使用 WebView UI 的用户体验要好得多。但“native”究竟意味着什么？什么是 WebView UI？为什么原生 UI 比 WebView UI 更好？React Native 如何与其他移动框架（如 PhoneGap，Cordova 和 Ionic）进行比较？ 让我们现在深入研究这些问题。坐稳，出发啦！ 学习目标 看完这篇文章后，我会让你回到这里。希望您能够轻松回答这些问题： 什么是原生app？ 什么是 WebView UI？ 更原生的框架有哪些好处和缺点？那原生性较少的框架怎么样 ？ React Native与 Cordova 相比如何？ 总之，什么是“native”app？要了解这种“native”实际意味着什么，我们现在来讨论一下： 我是黑客帝国的忠实粉丝，你也是吗？你知道，我们所见的现实实际上是一种模拟。有人提到，即使在电影里的 Zion 城市，一个人类曾经认为自己也是自由的最后一个城市，也是一个模拟。多层模拟现实的想法一直让我着迷——一个虚拟世界在另一个虚拟世界中作为模拟运行在第三世界里面 。 这很像我们的计算机（或手机）中的软件架构 。 软件是如何操作大量晶体管和电路的指令的安排，统称为硬件。直接在硬件上运行的原始指令对我们人类来说是难以理解的，特别是考虑到当今计算机的复杂性和规模。 为了使软件易于理解和可操作，计算机科学家将其分为多个层，这些层由运行在另一个框架之上的框架（让我们在这篇文章中简单地使用术语“框架”来指代具有某种结构的软件 ）组成。在所有这些框架中，框架越接近硬件，我们就说它更“native”。 因此，应用程序的“原生性”实际上是一个相对术语。严格地说，我们不能说应用程序本身是否是原生的。我们只能说，与其他应用相比，这款应用更具原生性。例如，您可以使用C ++，Java（或Kotlin）或 Cordova 构建 Android 应用程序。 C ++ 应用程序是最原生的，Cordova 应用程序是最少原生的。 Java / Kotlin 应用程序介于两者之间。 更具原生性的app有什么优势app有更多原生性或着较少的原生性都有各自的好处。更接近硬件意味着更多的自由，而更多的模拟（指较少的原生性）让您更舒适 。 使用更原生框架的程序通常可以更多地访问硬件功能，并且可以更自由地使用它们。它通常运行效率更高，因为不同语言之间的模拟和转换开销较低。但是现实中学习起来也会比较困难 - 代码通常更难以编写和理解。 另一方面，我们人类通常更容易在较少的原生性框架中编写代码。编码语言更容易理解，更简洁（需要更少的输入）。它的词汇量更接近我们的自然语言。它需要较少了解硬件的构成以及它内部的工作方式。还有一个好处就是，较少原生性框架中的程序通常更具可移植性 - 程序可以在完全不同的硬件平台上运行而无需修改，因为它的词汇和内部概念不包含任何特定于原始硬件的内容。然而，所有这些便利的代价是你通常会牺牲一些效率和自由。 移动开发框架集中营在React Native之前，移动框架通常为两个阵营中的一个。 第一个是原生阵营，例如 Android 的 Java/Kotlin 和 iOS 的 Objective-C/Swift。在原生阵营中，应用程序速度快，可以访问丰富的硬件功能。用户界面是针对目标平台（Android 或 iOS）的定制，因此非常流畅且使用愉快。然而，所有这些优点仅限于一个平台。要构建应用程序，必须学习两种不同的框架，这使得学习曲线陡峭两倍。这尤其会让数百万网络开发人员落伍。 然后是另一个移动框架阵营，例如 Cordova/PhoneGap 和 Ionic。这些框架允许 Web 开发人员使用其现有的 HTML，CSS 和 JavaScript 技能构建移动应用程序。这些应用可以在Android和iOS（以及更多）上运行。但是，它们更加缓慢，并且对硬件功能的访问受限。最重要的是，这些应用程序的用户界面很糟糕！由于这些框架使用一个名为 WebView 的关键组件来呈现 UI，因此我们将它们称为 WebView 框架。 WebView 框架构建在原生框架之上。我们可以看到前者是在后者内部运行的模拟世界。这就是为什么他们有上述的好处和限制。 为什么我们不能从中获益并避免两者的陷阱？这就是 React Native 要做的事情。 React Native 代表了移动框架的第三阵营。它的 UI 层比 WebView 框架更原生，而其余部分则处于相同的模拟级别，以实现其易用性。 React Native UI 比 WebView UI 更加原生像 Cordova 这样的框架可以使用 Web 技术构建移动UI。他们是如何做到的呢？他们在每个应用程序中嵌入了一个名为 WebView 的网络浏览器！您在UI中看到的所有内容，按钮，菜单和动画都在浏览器的网页中运行。在模拟方面，Cordova 应用程序的 UI 是在 Web 浏览器中运行的模拟世界，Web 浏览器又是一个在原生系统内运行的模拟世界。 相比之下，React Native的 UI 是比 WebView 框架更接近原生的一层——它直接在原生系统内运行。 此结构确定了 React Native UI 的优点。 React Native 直接使用原生 UI 组件，而 WebView 框架尝试使用 HTML / CSS 中的 Web UI 模仿原生 UI 的外观。真实的东西或假的东西，你更喜欢哪一个？ 根据经验，识别出使用 WebView 框架构建的应用程序并不困难。那些小东西，比如滚动加速，键盘行为，导航和UI的一般平滑度。如果他们没有完全本地化的行为，复杂性就会增加并导致用户感到沮丧。 React Native 使用 JavaScript 来使过程更加简单另一方面，React Native 仍然允许我们用 JavaScript 编写应用程序，并使用类似于 HTML 和CSS 的语法来构建 UI。这无疑降低了网页设计师和 Web 开发人员的入门门槛。 必要时，React Native 提供了一种渗透到原生框架的方法，以实现我们希望在应用程序中实现的任何原生功能。这有点像在黑客帝国中拨打电话。 那么 WebView 框架一文不值？ 不，绝对不是。例如，如果您已经拥有一个 Web 应用程序，并希望尽快将其发布到应用程序商店。您愿意以最短的上市时间牺牲用户体验。 另一种情况是，如果应用程序中显示的内容主要是内容没有太多的交互性，那么将它放在WebView中并不是太糟糕。 但是，如果您的应用程序的用户体验很重要，如果应用程序中存在某些交互性，例如接受用户输入，拖放，滑动屏幕等，请务必考虑 React Native。因为你最不想要做的一件事就是使用 WebView UI 模拟原生 UI。 总结好吧，我们已经看过“native”的真正含义，WebView UI 是什么以及为何 React Native UI 更好，React Native 如何与其他 WebView 框架（如 Cordova/PhoneGap 和 Ionic）进行比较。 你怎么看？您将使用哪个框架来构建您的下一个应用程序？ 原文链接：React Native vs. Cordova, PhoneGap, Ionic etc. 作者： Linton Ye(a full-stack developer in BC Canada)]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是React Native]]></title>
    <url>%2F2018%2F07%2F15%2F%E4%BB%80%E4%B9%88%E6%98%AFReact-Native%2F</url>
    <content type="text"><![CDATA[最近在网络上看到(译)图解 React这篇介绍 React 的文章。用比喻以及插画的形式科普 React 的相关术语还是蛮有趣的。于是乎自己就翻译了文章原作者讲述 React 术语系列文章中的其余两篇——《What is React Native？》和《React Native vs. Cordova, PhoneGap, Ionic etc.》。本篇为《What is React Native？》的译文，有翻译不对的地方欢迎指正！ 在上一篇文章中，我们探究了 React 是什么以及它的特点。今天我们来了解 React Native：拿来干什么，从哪里来，跟 React 有什么不同以及为什么它会如此重要。 学习目标读完这篇文章后，我会让你回顾这个章节。希望您能够轻松回答这些问题： 什么是 React Native？为什么它的名字包括“Native” ？ 为什么 React Native 很不错？ 我们可以用 React Native 构建什么？ 那 React 呢？ ReactDOM 来自哪里？它有什么作用？ React Renderer 有什么作用？ React Sketch.app 如何运行？ ReactVR 如何运行？ 什么是 ReactJS？React.js？ 在 Web 之外的世界到现在，可能你的脑海了会有这样一幅画面： 你知道，React 是一个针对 Web 构建用户界面的好工具。使用 React，您可以通过描述您想要的内容来构建 UI，而不是如何更新 UI（响应式UI），在可重用组件中组织代码，以及创建高性能 UI 而无需担心 DOM 这个慢性子家伙（因为有虚拟 DOM）。越来越多的 Web 开发人员选择React，因为它允许他们专注于更大的页面而不是低级细节。我们称这种构建 UI 的方式为 React 范式。范式基本上包含了如何思考问题以及如何描述问题及其解决方案的方式1。 这对 Web 应用来说非常棒。那么其他平台呢，比如 iOS 和 Android？如果你可以将相同的React 范式应用于移动应用程序的开发，那不是很好吗？ 在某种程度上，移动平台的工作方式与 Web 相同。有一个 model（一棵树）。有一样东西（艺术家）可以根据 model 创建视觉元素。构建移动 UI 的传统方式是直接操作树状 model 并告诉它如何更新内容（直接操作树状 model）。这与在 Web 浏览器中直接操作 DOM 具有类似的缺点。 React 正好有助于改善此问题。 除了相似之外，移动平台与 Web 是不相同，在各个方面都是彼此不同。过去，开发人员必须学习平台的特定语言和工具链才能为其构建应用程序。 这就像在异国情调的工作室工作，工作人员会说各种不同的语言。您必须学习与这些 UI model进行交互的所有新语言。这听起来不容易，是吗？ 因此，如果您想为 iOS 和 Android 构建原生应用程序，则必须创建两个完全独立的代码库。必须实施两次相同的业务逻辑。创建应用程序既困难又昂贵，从长远来看，维护它更是如此。 这就是 React Native 诞生的原因。让我们看看它如何让事情变得更容易。 React Native渲染器以及新的 React对于 Web 应用程序，React 负责启用 React 范式开发（管理响应式UI，组件和虚拟DOM），以及在浏览器中实际更新 DOM。当 DOM 是唯一需要交互的东西时，React 可以轻松处理这两项任务。 但是，对于移动应用程序，当需要在不同平台上管理各种 UI 树状模型时，事情变得具有挑战性。如果我们继续在 React 的肩膀上增加更多的责任，它将开始变得寸步难行。 为了解决这个问题，React 的创建者将原来的 React 拆分为两部分。第一部分是新的 React，重点是启用 React 开发范式。第二部分称为 ReactDOM，其唯一的工作是在浏览器中与 DOM 交互。因为 ReactDOM 更新了在浏览器上呈现内容的 DOM，所以我们说 ReactDOM 是一个渲染器。 回到我们的故事，想象一下，我们的 React 这个“超级英雄”脱下他的斗篷并撒上一些魔法尘埃。 他的斗篷活跃起来，成为他的帮手。摆脱了与 DOM 打交道的负担，React 现在可以专注于他所做的最好的事情。 这种角色分离是一个非常好的创意。它可以针对不同平台轻松编写适应新平台的新渲染器，同时保持 React 的优点。在 iOS 和 Android 渲染器的支持下，您现在可以使用单一语言和相同的React 范式为这两个平台构建应用程序。 React专注于他的事情（即响应式 UI，组件和虚拟 DOM）。 Renderers负责与具体的 UI 树交互。 一个完整平台React 的官方定义是：用于构建用户界面的 JavaScript 库。它的意义是双重的：首先它是 UI 构建的一个很好的工具，其次它不包括任何其他东西。 实际上，单独使用 React 还无法构建完整的应用程序。您需要用于样式的 CSS 示例，用于预处理和捆绑代码的 webpack，用于保存数据的 Firebase 以及许多其他内容。 Web浏览器这一“工作室”实际上比你看到的要繁忙得多。 这在 Web 开发环境中使用很友好，因为作为一个 JavaScript 库，React 自然适用于与其他库一起工作，这些其他库既可以是 JavaScript 库，也可以与 JavaScript 库配合使用的第三方库。毕竟，JavaScript 是 Web 的语言。 但是，对于使用各种语言和技术的移动平台而言，情况有所不同。在 JavaScript 中包含一整套工具变得非常重要，这些工具可以像 React 一样使用。因此，React Native诞生了。 与 Web 开发的 React 库相比，React Native 包含更多内容 ： React 作为其核心，负责响应式 UI，组件以及虚拟 DOM（我们的无斗篷的超级英雄） 针对特定平台例如 iOS 以及 Android 的渲染器 将代码转换并捆绑到可安装应用程序中的工具 原生 UI 组件（状态栏，ListView等）和动画 用于样式化和布局UI（flexbox）的工具包 构成大多数应用程序的基本部分（如网络） 提供原生功能的部分，如剪贴板，加速度计和存储 … 我们说 React Native 本身就是一个完整的平台，因为它包含了构建完整应用程序所需的一切。相比之下，最初的 React 只负责 Web UI，您需要自己包含其他部分来创建 Web 应用程序。 原生 UI你有没有想过为什么 React Native 被标记为 Native？这实际上是它的品牌特征：使用 React Native 构建的 UI 包含软件运行平台原生 UI 组件，这些 UI 组件性能良好且交互体验一致，而不是嵌入到 WebView 中运行的一些模拟原生 app 的垃圾界面。使用 React Native 构建的应用程序通常与使用 Swift 和 Java 等移动平台原生语言编写的应用程序无法区分。 你知道，滚动加速，动画，键盘行为和阴影这些小东西实际上在你的应用程序的用户体验中起着重要作用。如果这些与手机上的其他应用程序不一致，用户很快就会感到沮丧。 我原本打算在这里解释一下“native”的真正意义以及为什么 React Native 表现更好。但经过几次头脑风暴会议之后，我的笔记很快就变成了整页。让我们把它作为自己的未来帖子吧。 现在，我希望你能记住，原生用户界面是让 React Native 大放异彩的好事之一。 所以，在这里，React Native是一个完整的平台，允许您在 JavaScript 中使用 React 范式构建真正的原生应用程序。 React Sketch.app, ReactVR, React XYZ…最近 Airbnb 发布了一个名为 React Sketch.app 的工具，它将 React 代码转换为 Sketch 中的图像层。你能猜出它是如何工作的吗？ 对！它本质上是 React Native，在 Sketch 中某个渲染器与 UI 树模型进行交互！ 因为 React Sketch.app 是基于 React Native，它是一个完整的包，我们可以做一些惊喜的事情，比如从真实的 API 中获取数据并在 Sketch 中呈现它。 与此同时，React Native 的许多其他变体被创建用于支持构建 Windows，macOS，VR 等平台2的应用程序。 这意味着，只要您掌握了 React 的精髓，就可以使用相同的思维模式在 JavaScript 中为数以千计的平台构建应用程序。正如 React Native 的创作者所说，“学习一次，随处开发”。 上手时间到目前为止说了这么多！你想在手机上试试吗？ 我也很兴奋！抓住你的手机跟着我吧！ 在手机上，下载Expo应用程序。您可以从这里下载：iOS，Android，或在App Store中搜索“Expo” 在您的计算机上，打开此页面：https://snack.expo.io/ 在你的手机运行 Expo app 并且点击“Scan QR Code” 扫描计算机上显示的QR码。如果一切正常，您应该看到绿色的“设备已连接”消息。 如果QR码不会自动消失，请单击页面右上角的小十字将其关闭。你应该看到一个代码编辑器 删除编辑器中的所有内容，粘贴此代码 你在手机上看到了什么？ 如果需要，您可以在编辑器中更改代码，并立即在手机上查看结果！ 我将来会详细解释这个环境。现在，请记住它就像 React Native 的 Codepen。 如果将 React Native 版本的代码与 React（Web）版本进行比较，您会发现它们看起来非常相似。它们都是这样的： 12345678910111213141516const Hat = ...const Thinker = ...// Below is the React Native version// For Web version, replace "View" with "div"const ThinkerWithHat = (&#123;hat&#125;) =&gt; ( &lt;View&gt; &lt;Thinker /&gt; &lt;Hat type=&#123;hat&#125;/&gt; &lt;/View&gt;);const HatSwitcher = ...... “一次学习，多平台开发”！记得？ 至于 ReachJS 和 React.js您可能已经听过很多人称呼为 ReactJS（或React.js）——我也使用过这个名字。事实上它从来都不是官方名称3。从第一天起，官方名称一直是“React”。 因为 JavaScript 库往往被命名为“XyzJS”或“Xyz.js”而 React 是一个 JavaScript 库，所以人们可能会自愿将“JS”或“.js”附加到其名称中。由于 React 最初是一个Web库，很多人使用 ReactJS 或React.js 来引用 Web 上的 React，React和ReactDOM的组合。 遵循事实上的惯例，当我说 ReactJS 时，我的意思是 React ，在网上也是如此。 总结真棒！到目前为止，我们已经完成了很多事情。我们已经了解了 React 的一些历史以及 React Native 如何组合在一起。作为一个完整的平台，React Native 包含了在 JavaScript 和 React 范式中构建原生应用程序所需的一切。 React Native 现在支持许多平台，包括iOS，Android，Windows，macOS，Sketch.app 甚至 VR。 “一次学习，多平台开发”！ 在下一篇文章中，我们将了解原生应用程序的真正含义以及为什么 React Native 是构建原生应用程序的最佳方式之一。 我鼓励你回到学习目标，看看你是否能回答所有问题。如果您有任何问题或意见，请与我们联系！ 1. 还记得声明式和命令式编程吗？它们都是范式。 React 范式是关于如何将 UI 界面分解为组件，如何传递数据等等，我们将在后面详细研究 &#8617; 2. React Renderers 的想法非常强大。这里有一个很酷的渲染器列表可以使用React构建许多不同的东西。 &#8617; 3. 如果您正在寻找React Native和React Web之间的深入技术比较，请查看此文章 &#8617; 原文链接：What Is React Native? 作者：Linton Ye(a full-stack developer in BC Canada)]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript运行机制]]></title>
    <url>%2F2018%2F05%2F06%2FJavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在 Medium 中看到了一篇讲解 JavaScript 运行机制的文章，里面讲述了解释引擎、运行时以及调用栈的概念，对于 JavaScript 学习者来说我觉得有必要了解一下…… 随着JavaScript越来越受欢迎，开发团队正在将其用在技术栈的各个方面，包括 - 前端、后端、混合应用、嵌入式设备等等。 如 GitHut统计 所示，JavaScript在GitHub中的活动存储库和总推送方面位于前列，在其他方面也不差。 如果项目越来越依赖于JavaScript，这意味着开发人员必须更深入地了解内部机制，才能利用语言和生态系统提供的所有技术，构建出惊艳的软件。 事实证明，虽然有很多开发人员每天都在使用JavaScript，但并不知道它的工作机制。 概述几乎所有人都已经听说过V8引擎的概念，大多数人都知道JavaScript是单线程的，或者是使用回调队列。 在这篇文章中，我们将详细介绍所有这些概念，并解释JavaScript的工作机制。通过了解这些细节，您将能够正确利用提供的API，编写更好的非阻塞应用程序。 如果您是一个JavaScript新手，此博文将帮助您了解为什么JavaScript与其他语言相比是如此“怪异”。 而如果您是一位经验丰富的JavaScript开发人员，希望能够提供与您每天使用的JavaScript运行时有关的一些新鲜见解。 JavaScript引擎JavaScript引擎的一个流行示例是Google的V8引擎。例如，V8引擎在Chrome和Node.js中使用。如下是它看起来像什么的一个简单视图： 引擎由两个主要组成部分组成： 内存堆 - 这是内存分配发生的地方 调用栈 - 这是您的代码执行所在的栈帧 运行时浏览器中已经有几个几乎所有JavaScript开发人员都会使用的API（比如 setTimeout）。不过，这些API不是由引擎提供的。 那么，它们是来自哪里呢？ 事实证明，现实有点复杂。 所以，除了引擎以外，实际上还有更多东西。有一些由浏览器提供的，称为Web API的东西，比如DOM、AJAX、setTimeout等等。还有超受欢迎的事件循环和回调队列。 调用栈JavaScript是一种单线程编程语言，这意味着它只有一个调用栈。因此，它一次只能做一件事。 调用栈是一种数据结构，它基本上是记录了我们处于程序中哪个地方。如果单步执行进一个函数，就把该函数放在栈顶。如果从函数返回，就把它从栈顶弹出。这就是栈所做的事情。 下面我们来看一个示例。看看下面的代码： 12345678910function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 引擎开始执行这段代码时，调用栈是空的。之后，步骤将是如下这样： 调用栈中的每个条目称为栈帧。 而这正是在异常被抛出时，栈跟踪被构造的方式 - 当异常发生时，它基本上是调用栈的状态。看看下面的代码： 12345678910111213function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); 如果是在Chrome中执行这段代码（假设此代码位于一个名为foo.js的文件中），则会产生以下栈跟踪信息： “爆栈” - 当达到最大调用栈大小时，就会发生这种情况。并且这非常容易发生，特别是如果使用递归而不充分测试代码时。请看如下示例代码： 12345function foo() &#123; foo();&#125;foo(); 当引擎开始执行这段代码时，它首先调用函数“foo”。不过，这个函数是递归的，并且开始调用自身而没有任何终止条件。所以在执行的每个步骤中，相同的函数都被一次又一次地添加到调用栈中。看起来像这样： 然而，在某些时候，如果调用栈中的函数调用量超过了调用栈的实际大小，浏览器就会决定采取行动，抛出一个错误，看起来像这样： 在单个线程上运行代码可能很容易，因为您不必处理在多线程环境中出现的复杂场景，例如死锁。 但在单线程上运行也有很大限制。由于JavaScript有一个调用栈，当事情缓慢时会发生什么？ 并发和事件循环当在调用栈中有函数调用需要大量时间才能处理完时，会发生什么？例如，假设想在浏览器中使用JavaScript进行一些复杂的图像转换。 你可能会问 - 这怎么就成了一个问题呢？原因是，在调用堆有函数要执行的同时，浏览器实际上不能做任何事情 - 它被阻塞了。这意味着浏览器无法渲染，它不能运行任何其他代码，它只是卡住了。如果想在应用中有流畅的UI，这会出问题。 而这不是唯一的问题。一旦浏览器开始处理调用栈中的许多任务，它可能会停止响应很长时间。大多数浏览器通过引发一个错误来采取行动，询问您是否要终止网页。 现在，这不是最好的用户体验，对吧？ 那么，如何执行繁重的代码，而不阻塞UI并且不会使浏览器无响应呢？好吧，解决方案是异步回调。 我将在教程的第2部分中详细介绍。 作者：Alexander Zlatkov 原文地址：How JavaScript works: an overview of the engine, the runtime, and the call stack]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于callback函数我所知道的一切]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%85%B3%E4%BA%8Ecallback%E5%87%BD%E6%95%B0%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[距上一篇博文已经好长时间了，这几个月入职公司实习，忙毕设设计，出去找房……大四狗的生活好累啊（抽泣脸）。回到博文本身，因为一直对使用 Node.js 写一些后台程序充满了极大的兴趣，不过直到入职公司的时候才开始逐步入门学习 Node.js 开发知识。学习 Node.js 最主要的学会如何异步编程，异步编程使用了 callback 函数，于是决定来认真学习一下 callback 函数的概念以及用法 扯扯 Node.js最近学习 Node.js，看了一本挺不错的 Node.js 基础入门书《Node.js Succinctly》。了解到 Node.js 赖以成名的异步非阻塞特性。那何为异步非阻塞呢？首先我们得明白 JavaScript 本身就是一门事件驱动（观察者模式）和单线程的语言，它的特性是跟 JavaScript 的诞生背景是相关的。JavaScript 一开始设计出来就是为了丰富 Web 的交互效果也就是DOM操作，进行简单的表单验证。同样，Node.js 的执行程序本就是单线程，因为同样也是用 JavaScript（当初设计 Node.js 时决定使用 JavaScript 也是看重它单线程语言的特点）。单个线程如果遇到耗时操作例如 I/O操作，网络访问时则会阻塞该线程后面的执行流程，因此为了不阻塞这唯一的执行线程，因此就利用了异步的方式。所谓异步的方式就是让耗时操作在其他线程中完成的，我们姑且称他们为工作线程。当某些耗时操作完成后就需要将执行的结果返回给唯一的主线程，这一步则是通过 callback 函数完成的，同时也体现了事件驱动的特点。因此，我们可以说异步编程最直接的表现就是回调，但 callback 函数跟异步/同步并没有直接的关系。例如下面的例子： 1234567891011121314151617function heavyCompute(n, callback)&#123; let count = 0, i, j; for (i = n; i &gt; 0;--i)&#123; for(j = n; j &gt; 0;--j)&#123; count += 1; &#125; &#125; callback(count);&#125;heavyCompute(10000, function(count)&#123; console.log(count);&#125;);console.log('hello'); 执行的结果为： 100000000 hello 可以看到，以上代码的回调函数仍然先于后续代码执行，也可以看出 JavaScript 函数也是一等公民的特点，毕竟也可以作为函数参数。这种方式就叫同步回调，而异步回调就类似于在写页面时经常会遇到的点击按钮触发弹出框弹出的动作，如下： 123456......let btn = document.getElementByID('myButton');btn.addEventListen('click',function(ev)&#123; console.log(ev.target);&#125;);...... 什么是 callback 函数绕远一点来说，编程分为系统编程和应用编程。系统编程就是编写库，这些编写的库函数相对来说更接近硬件。而应用编程就是利用写好的各种库来编写具有某种功用的程序。系统程序员会给自己编写的库留下一些接口，即 API （application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下应用程序会时常通过 API 调用库函数。这时会出现这样一种情况：某些库函数要求应用先传给它一个函数，好在合适的时候调用，已完成目标任务。这个被传入的，后又被调用的函数就称为 callback 函数。 可以看到，callback 函数通常和应用处于同一抽象层（因为传入什么样的 callback 函数是在应用这一层决定的）。而所谓的“callback”就体现在：高层函数调用底层函数即库函数，底层函数回过头来调用高层函数的过程。 如果以饭馆吃饭买单的过程来比喻的话：在客人招呼服务员买单的时候，服务员就根据手上的订单计算总价后再告诉客人应付多少钱。这一过程中，客人招呼服务员买单就像应用程序的高层函数去调用底层函数，这里应用程序指的就是这一桌客人要买单的上下文环境，底层函数就是服务员计算总价的过程。服务员计算完总价之后再告诉客人就类似于底层函数调用高层函数，回到客人买单的上下文环境中去。 为什么需要 Callback 函数callback 这种机制比简单的函数调用有着更大的灵活性。除了上面那种 callback 机制的应用场景外，其实任何时候我们都可以实现上面的那种 callback 机制，而不仅仅在应用和库之间。因此，从这里开始我们把上面的库函数称为中间函数。那 callback 机制的灵活性是如何实现的呢？我们可以认为中间函数在没有传入 callback 函数之前逻辑上是不完整的。换句话说，程序可以在运行时通过传入不同的 callback 函数来改变中间函数的行为，这比简单的函数调用要灵活得多。我们来看看用 python 写的示例： even.py 123456789#回调函数1#生成一个2k形式的偶数def double(x): return x * 2 #回调函数2#生成一个4k形式的偶数def quadruple(x): return x * 4 callback_demo.py 1234567891011121314151617181920from even import *#中间函数#接受一个生成偶数的函数作为参数#返回一个奇数def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) #起始函数，这里是程序的主函数def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) if __name__ == "__main__": main() 运行callback_demp.py，输出如下： 3 5 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是 callback 机制的优势所在。 但是在这里我们得强调：通过上面的论述，中间函数和 callback 函数是 callback 机制的两个必要部分，不过人们往往忽略了 callback 机制的起点：起始函数。它也是中间函数的调用者，在大部分情况下，可以把这个起始函数和程序的主函数等同起来。因此 callback 机制是起始函数、中间函数和 callback 函数的三方联动。同时起始函数和 callback 函数也不能简单看为一体。因为 callback 实际上有两种：阻塞式和延迟式。阻塞式，callback 函数的调用一定发生在起始函数返回之前；而延迟式，callback 函数的调用有可能是在起始函数返回之后。因此起始函数和 callback 函数并不为同一事物。 回到 JavaScript 中，为什么我们需要 callback 函数。因此上面我们也说到 JavaScript 是一门事件驱动的语言。这意味着 JavaScript 执行程序不会等待响应，而会在监听其他事件时继续执行。 参考 回调函数（callback）是什么？ - no.body的回答 - 知乎 JavaScript: What the heck is a Callback?|Medium 七天学会NodeJS]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME是什么及其应用]]></title>
    <url>%2F2018%2F01%2F28%2F%E4%BB%80%E4%B9%88%E6%98%AFMIME%2F</url>
    <content type="text"><![CDATA[前一篇 JavaScript与文字编码 中谈到了 MIME，同时联系到&lt;form&gt;标签的enctype属性，所以这里做个小小的总结 为什么会有 MIMEMIME 的全称为“Multipurpose Internet Mail Extensions”，中文译为“多用途互联网邮件扩展”，指的是一系列的电子邮件技术规范。它是作为 SMTP(Simple Mail Transfer Protocal) 的一个扩展。因为当初制定 SMTP 协议的时候并没有考虑传输内容可以有非文本内容（即二进制文件），同时制定者也没有考虑到非英语国家使用的文字。可能早期电子邮件的诞生只是为了解决简单信息即文本的问题，取代电报这一传统方式。 MIME 的相关内容概述MIME 主要包括以下三部分内容： 5 个新的邮件首部字段，它们可包含在原来邮件的首部中。这些字段提供了有关邮件主体的信息 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变 下面时 MIME 增加的 5 个新的邮件首部的名称及其含义 MIME-Version：标明 MIME 的版本。现在的版本号为 1.0。若邮件报文中无此项，表明是遵守 SMTP 协议的传统邮件报文，内容仅为 ASCII 字符 Contetn-Description：这是可读字符串，说明此邮件主题是否是图像、音频或视频 Content-Id：邮件的唯一标识符 Content-Transfer-Encoding：在传送时邮件的主体是如何编码的 Content-Type：说明邮件主体的数据类型和子类型 上述前面三项意思说的很清楚，第四项Content-Transfer-Encoding的选项有： 7 bit 8 bit binary quoted-printab base64 其中第一个方案时缺省值，即不用转化的 ASCII 字符。真正常用的是 quoted-printable 和 Base64 ，而 Base64 编码方案上篇博文 JavaScript与文字编码 有详细介绍，而 quoted-printable 限于篇幅有限，这里就不细说，各位童鞋可以谷歌或者翻阅教科书。这里我们重点说说第五项：Content-Type 最重要的 Content-Type 字段这一邮件首部及其重要，它表明传递的信息类型和采用的编码。 MIME 标准规定该首部值为：内容类型/子类型。下面表格列举了部分基本内容类型及其子类型： 内容类型 子类型 说明 text plain、html、xml、css 不同格式的文本 image gif、jpeg、tiff 不同格式的图像 audio basic、mpeg 可听见的声音 video mpeg、mp4、quicktime 不同格式的影片 application octet-stream、pdf、x-www-form-urlencoded 不同应用程序产生的数据 multipart mixed、alternative、parallel、digest 多种类型的组合 其中如果内容主体的类型为“text”，那么还必须指明编码类型“charset”，缺省值是 ASCII，其他可能值有 UTF-8、GB2312、GBK 等。还有 MIME 允许自定义内容类型。但为了避免可能出现名字冲突，标准要求自定义的内容类型的名称要以字符串x-开始。例如 HTML form 标签的 enctype 属性值之一：x-www-form-urlencode 同时还要注意到 MIME 中的 multipart 内容类型，该内容类型很有用，因为它使邮件增加了相当大的灵活性，其子类型主要有： mixed——该子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类型和编码，可以是文本、图像或声音。在 mixed 后面还要用到一个关键字，即Boundary=，此关键字定义了分割报文各部分所用的字符串，只要在邮件的内容中不会出现这样的字符串即可，可以把它理解为分割标识符。当某一行以两个连字符“—”开始，后面紧跟上述的字符串，就表示下面开始了另一个子报文。 alternative——该子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件平台或软件平台的收件人发送文本时就很有用。比如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在察看图形时选择格式化的形式。 parallel——该子类型允许单个报文含有可同时显示的各个子部分。例如，图像和声音同时播放。 digest——该子类型允许单个报文含有一组其他报文。 HTTP 报文中的实体首部其实 Content-Type 字段不仅使用在电子邮件，后来也被移植到了 HTTP 协议中。HTTP 报文中的实体首部就有 Content-Type 这一字段，其用来说明报文实体部分的内容类型。 form 标签的 enctype 属性enctype 属性规定了对表单提交给服务器时表单数据编码的内容类型（Content-Type），这里的“内容类型”就是来自 MIME 的 Content-Type 字段。但是 enctype 属性值只有三种： application/x-www-form-urlencoded multipart/form-data text/plain application/x-www-form-urlencodedform 表单提交的默认内容类型，使用该类型时，会将表单数据组合成key1=value1&amp;key2=value2形式。其中要注意表单数据中如果有非字母数字的字符，那么该字符会转换。因为 RFC 文档规定 URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。所以如果 URL 中有汉字，就必须编码后使用。至于怎么编码，各位童鞋可查看阮一峰的 关于URL编码|阮一峰的网络日志。这篇文章虽然距今有点久远，具体方案可能会有所改变，但至少可以让你更加了解 URL 编码的问题。 采用此种内容类型，后端在取数据后，需要进行分解。同时还要注意，若此时表单中有文件，那么表单数据只有文件名。 mulltipart/form-data该内容类型不对字符编码，在使用包含文件上传控件的表单时，必须使用该值。 text/plain表单数据中的空格转换为 “+” 加号，但不对特殊字符编码。要注意的是，若表单中有文件，则表单数据仅为文件名。 参考 MIME笔记|阮一峰的网络日志 《计算机网络》谢希仁著（第七版） 表单提交时编码类型enctype详解|SegmentFault 关于URL编码|阮一峰的网络日志]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2017]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%88%91%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[今天是2017年的最后一天，有些话想聊一聊，也就算个人的年度总结吧 2017的那些选择关注过我博客的各位童鞋应该都知道，我本不是计算机相关专业的学生。因为喜欢，就完完全全抛弃了自己的专业，在图书馆花了一整年的时间学习软件开发。先是学习了半年多时间的Android开发，因为一开始的目标就是想弄个有趣的 app 出来，结果因为六七月份找实习的时候发现情况不太好，就尝试了往前端开发方向发展了。最终在10月份的时候成功找到一份实习，接着在11月底找到一份待遇还算不错的正式工作。一开始决定往软件开发方向发展时，自己都不知道结果会是怎么样，而且当时已经是大三了，没有那么多时间给自己学习，所以一开始的时候还是很忐忑，家里人一开始也不是很支持我往开发方向发展。然而到今年底，也可以说是上帝眷顾自己的努力吧，算比较幸运的找到了一份待遇、工作氛围、工作内容都挺满意的工作，最高兴的还算是父母终于肯定了自己的付出。自己一年来的努力算是没有辜负当初自己做出这个选择时下定的决心，没有忘记当初是为了什么才做出这个决定。 2017年的那些人话说，今年一整年都在忙着学习开发，等到了今天回过头来看。发现自己还有半年就算是结束了自己16年的学生生涯。想想一下子不去教室上课了，还真的是很伤感。因为今年平时都忙着学习开发，自己的专业课基本都逃了，已经忘记了上课是一种什么感觉了，然而今年一过，后面就再也不用去上课了。所以好多东西，都是过去了才懂得珍惜。这也让我想起了高考完几天后，在家里收拾着高三一整年的资料书籍，突然不知怎么的，看着这一大堆书籍、资料，觉得高考考完，好像自己的生活就没了意义，于是就好想回到课堂上跟大家一起做“五三”，好想和高三(1)班的同学一起聊天、玩耍。如今大学快毕业了，发现跟自己很好的那帮同学还是以前的高中同学，毕竟他们和你度过了青春中最美好的六个年华。所以呀，过年回家的时候就特别期待着班级聚会，想看看大家，特别是当年那个自己特别喜欢的女生变什么样了。而等到上大学之后，特别是今年去了湖北十堰，九、十月份秋招的时候跑了一些宣讲会、十月份到十二月份实习，就发现等你见过各色各样的人之后，你会觉得找到一个打心底里跟自己能敞开心扉的人其实很难，而当你跟中学时代的那一帮同学度过了最美好的时光后，你也会发现，从某种情况下你跟他们的关系已经超越了同学的层面。所以上大学后，就越发珍惜以前的超越同学的情谊，一有时间我就会找那帮同学聊聊天。而大学同学，大多数人都只是从你生活“路过”而已。 2017年的那些看过的电视剧、电影今年年初的时候看了两部日剧《逃避虽可耻》、《求婚大作战》和一部日影《你的名字。》。看完这些后就非常喜欢这两部电视剧和电影里带给人的那种感觉。特别是《你的名字。》，感觉日本人的生活气息是特别空灵的那种，也特别祥和。所以那时就决定以后有机会一定要去日本感受一下那种不一样的生活气息。年底的时候在同学推荐下又看了《请回答1988》，剧里面透露出来的亲情、爱情、友情真是很让人羡慕，虽然生活算不上富裕，但能够遇上如此有爱的邻居，和邻居家的孩子一起长大，最后到相爱相知，我想这就已经足够了。 2017年的科比今年还有一件重要的事就是科比球衣退役。想想前年还坐在电脑前看科比球员生涯的最后一场比赛，到球衣退役那天，发现仅仅两年多的时间，科比却感觉明显老了一些。想想当年为什么喜欢科比，或许只是因为投入关键球后他那龇牙咧嘴的狠劲。还有早年，Nike 09年的广告《只要心够绝》让我喜欢上了科比的那种竞争精神。现在他已退役了，但科比精神仍在！话说，今年双十一的时候入了科比14年的低帮球鞋，突然就找回以前打球的欲望了，这大概就是球星的力量吧。 展望2018既然现在我已是程序员的身份了，希望新的一年戒骄戒躁，脚踏实地干实事。还有提醒自己记得注意自己的身体，多多锻炼，有机会去报个班学跳舞。有机会能多带父母走走，有闲钱可以入个MBP，有机会多出去看看外面的世界…..嗯，大概就这样吧。记住，少说套话多干实事！]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript与文字编码]]></title>
    <url>%2F2017%2F12%2F28%2FJavaScript%E4%B8%8E%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在学习阮一峰的 字符串的扩展|ECMAScript 6 入门 章节的时候其中有一处“JavaScript 共有 6 种方法可以表示一个字符”。然后想起之前看的一篇关于文字编码的文章，所以现在打算重新复习一下文字编码 文字编码在物理层面上，我们存入计算机的所有文件都是以二进制形式保存的。但现实生活中，我们会发现计算机中保存的文件形式各式各样，有音频文件、文本文件、视频文件、还有我们程序员熟悉的源代码文件等等。由此可以看出，不同文件的差别只是我们解读二进制的方式不同。然而即使同为一个类别的文件，解读二进制文件又会有不同。其中我们以网页开发中最常接触到的文本文件的编码方式拿来细说。这里所说的文本文件，一般是指基于字符编码的文件。计算机发展到现在为止，出现的字符编码就有 ASCII、GB2312、Unicode等等。 ASCIIASCII（American Standard Code for Information Interchange），中文名称为美国信息交换标准代码。是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统。ASCII码又分为标准ASCII码和扩展ASCII码。 使用 8 个二进制位进行编码的方案，最多可以给 256 个字符（包括字母、数字、标点符号、控制字符及其他符号）分配数值。基本的 ASCII 字符集共有 128 （0~127）个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。因为这 128 个基本字符就可以用 7 位二进制表示。所以多出来的最高位设为 0 （在数据传输时可用作奇偶校验位）。剩下的 128 个拿来扩充 ASCII 字符集，为了以后方便加入新的字符。这些扩充字符的编码最高为均为 1 的二进制数字（即十进制 128~255），称为扩展 ASCII 码，各国为了可以在计算机使用他们自己的文字，于是就在扩展 ASCII 码上各自做文章。虽然剩下的128个扩展 ASCII 码数量有限，但在实际应用中是可以满足部分国家文字编码的需求。因此针对扩展的 ASCII 码，不同的国家有不同的字符集，但它不是国际标准。比如 Latin1 字符集属于扩展ASCII码的一种，国际标准名为 ISO-8859-1，它把位于128-255之间的字符用于拉丁字母表中特殊语言字符的编码，也因此而得名。不过欧洲语言不是地球上的唯一语言，亚洲和非洲语言并不能被Latine1字符集所支持。这些基于基本 ASCII 字符集进行扩展出来的单字节字符集在不同国家地区有不同具体的方案。 GB2312等中国人开始使用计算机时发现如果还是使用扩展 ASCII 码来制定中文的字符集是行不通，因为常用汉字就已超过6000个。于是这时候国人就自主研发，把那些127号之后的奇异符号们直接取消掉。规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312″。GB2312 是对 ASCII 的中文扩展。 GBK但是中国的汉字太多了，后来还是不够用，于是干脆不再要求低字节一定是127之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 GB18030后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030 ANSI各国在 ASCII 的基础上制定了自己的字符集，这些从 ANSI 标准派生的字符集被习惯的统称为 ANSI 字符集，它们正式的名称应该是 MBCS（Multi-Byte Chactacter System，即多字节字符系统）。这些派生字符集的特点是以 ASCII 127 bits 为基础，兼容 ASCII 127，他们使用大于128的编码作为一个 Leading Byte，紧跟在 Leading Byte 后的第二（甚至第三）个字节与 Leading Byte 一起作为实际的编码，由此产生了 GB2312、GBK、GB18030、Big5、Shift_JIS 等各自的编码标准。但西欧国家也有根据本国文字的数量仅需要 128 个扩展的 ASCII 码就完成制定了单字节字符集。 Unicode为了解决不同国家地区间编码方案的不同引起的不便，于是就有了这样一个想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会乱码了。 Unicode 就是在这种背景下诞生了。Unicode 规定了每个字符的编号，这个编号也叫做“码点”（code point)。它从 0 开始，目前 Unicode 的最新版本一共收入了 109449 个符号，其中的中日韩文字为 74500 个。这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以放 65536 （$2^{16}$)个字符，称为一个平面（plane）。目前，一共有 17 （$2^{5}$)个平面，也就是说，整个 Unicode 字符集的大小现在是 $2^{21}$ 个。其中最前面的 65536 个字符位，称为基本平面（缩写BMP），它的码点范围是从 0 ~ $2^{16}-1$，写成十六进制就是从 U+0000 ~ U+FFFF 。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（缩写SMP），码点范围从 U+010000 ~ U+10FFFF。 Unicode 只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。 UTF-32最直观的编码方法就是，每个码点使用 4 个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。例如码点 597D U+597D = 0x0000 597D UTF-32 的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比 ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成UTF-32。 UTF-8UTF-32 太过于浪费空间，所以急需一种节省空间的表示方案，这导致了 UTF-8 的诞生。UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。 字节 编号范围 0x0000 - 0x007F 1 0x0080 - 0x07FF 2 0x0800 - 0xFFFF 3 0x010000 - 0x10FFFF 4 我们来看看 UTF-8 具体是如何存储字符的，如下面的字符 we 发 财 🤑 上面的字符对应的十进制编码如下 其中 20 是空格的编码，可以看到一个英文还是 1 个字节，一个中文用了 3 个字节，而一个 Emoj 用了 4 个字节。它怎么知道每次应该读取多少个字节呢？如下图所示： 如果一个字节是 0 开头，表示这个字节就表示一个字符，如果是 3 个 1 开头表示这个字符要占 3 个字节，有多少个 1 就表示当前字符占用了多少个字节。这个就是 UTF-8 的存储特点，UTF 规定了每个字符的编号，而 UTF-8 定义了字符应该怎么存储。从 Unicode官网 可以查到，“我”的UTF 十六进制编码是 \u6211，如下图所示： 6211 怎么变成 UTF-8 编码呢？因为 6211 落在下面这个范围： U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX 所以是这么转的： “我”的 UTF-8 就是 E6 88 91 UTF-16UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000到U+FFFF），要么是 4 个字节（U+010000到U+10FFFF）。 但是现在面临一个问题就是：当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？然而在基本平面内，从 U+D800 ~ U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段被拿来映射辅助平面的字符。当我们遇到两个字节，发现它的码点在 U+D800 ~ U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00 ~ U+DFFF之间，这四个字节必须放在一起解读。 到此，我们可以看出，UTF-8 的优点在于 1 个英文只要 1 个字节，但是 1 个中文却是 3 个字节，UTF-16 的优点在于编码长度固定，1 个中文只要 2 个字节，但是 1 个英文也要 2 个字节。所以对于英文网页 UTF-8 编码更加有利，而对于中文网页使用 UTF-16 应该更加有利。因为绝大部分的中文都是落在 U+0000 ~ U+FFFF。 “联通”两字与Windows记事本在简体中文 Windows 操作系统中，ANSI 编码代表 GBK 编码；在繁体中文 Windows 操作系统中，ANSI 编码代表 Big5；在日文 Windows 操作系统中，ANSI 编码代表 Shift_JIS 编码。而记事本程序保存非英文字符时的默认编码方案就是 ANSI，即根据 Windows 语言版本选择编码方式，就如上述中文 Windows 操作系统使用 GBK 字符集。保存后再使用记事本程序打开会发现原来保存的“联通”两字现在变成了不知什么鬼的字符，就是乱码了。因为当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件有三种途径来决定文本的字符集和编码： 文本文件开头的字符集标记 询问用户采用哪个字符集 软件自己猜测 结果因为“联通”两字的 GBK 编码看起来更像UTF-8编码，记事本程序就根据 UTF-8 编码规则解码这两个字，从而导致最后的乱码。 Base64早期电子邮件的 SMTP（Simple Mail Transfer Protocol） 协议仅限于传送 7 位的 ASCII 码。许多其他非英语国家的文字以及多媒体资源就无法传送，所以说早期的电子邮件就只能传送英文文字。或许是早期电子邮件的诞生的时候，美国人民以为只有他们自己会传送文字以取消传统的电报业务。 于是后来就提出了通用互联网邮件扩充（MIME）。MIME 并没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。因此在这种情况下，Base64 就诞生了。 Base64 可以把原本 ASCII 码的控制字符甚至 ASCII 码之外的字符都转成可打印的 6 bit 字符，也就是说用 6 bit 字符表达了原本 8 bit 字符。我们看看下面的图片： 像表格中那样，8 Bit$\times$3 的字符串可以每 6 个 bit 分成一组，每一组 bit 对应一个十进制的 index，每一个 index 值又对应了 Base64 的字符。由于 6 bit 的二进制代码共有 64 种不同的值，从 0 到 63。用 A 表示 0 ，用 B 表示 1 ，等等。26 个大写字母排列完毕后，接下去再排 26 个小写字母，再后面是 10 个数字，最后用“+”表示 62，而用“/”表示 63。再用两个连在一起的等号 “==” 和一个等号 “=” 分别表示最后一组的代码只有 8 bit 或 16 bit。 JavaScript 与编码JavaScript使用哪种编码JavaScript 语言采用 Unicode 字符集，但是它编码使用的既不是 UTF-16，也不是UTF-8，更不是 UTF-32，而是 UCS-2。他们之间是什么关系呢？我们讲讲一些历史。 互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。 UCS 的开发进度快于 Unicode，1990 年就公布了第一套编码方法 UCS-2，使用 2 个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以 2 个字节就够用了。）UTF-16 编码迟至 1996 年 7 月才公布，明确宣布是 UCS-2 的超集，即基本平面字符沿用 UCS-2 编码，辅助平面字符定义了 4 个字节的表示方法。 两者的关系简单说，就是 UTF-16 取代了 UCS-2 ，或者说 UCS-2 整合进了 UTF-16。所以，现在只有 UTF-16，没有 UCS-2。 JavaScript为什么不使用 UTF-16那么，为什么 JavaScript 不选择更高级的 UTF-16，而用了已经被淘汰的 UCS-2 呢？答案很简单：非不想也，是不能也。因为在 JavaScript 语言出现的时候，还没有 UTF-16 编码。 JavaScript 字符函数的局限由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。所以当遍历字符串的时，必须对码点做一个判断，然后手动调整。 String.prototype.replace() String.prototype.substring() String.prototype.slice() … 上面的字符函数都只对 2 字节的码点有效。要正确处理 4 字节的码点要手动处理。 ES6JavaScript 的下一个版本 ECMAScript 6（ES6），大幅增强了 Unicode 支持，基本上解决了上面的问题。新增了以下特点： ES6能够自动识别 4 字节的码点 允许直接用码点表示 Unicode 字符 新增了几个专门处理 4 字节码点的函数 对正则表达式添加了 4 字节码点的支持 Unicode 正规化 参考 字符编码|百度百科 文字编码的那些事|掘金 Unicode 与 JavaScript 详解|阮一峰的网络日志 《计算机网络》谢希仁著（第七版） 漫画：什么是 Base64 算法|算法爱好者 关于记事本无法单独保存“联通”两个字说明]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP和MVVM的图示]]></title>
    <url>%2F2017%2F10%2F14%2FMVC-MVP%E5%92%8CMVVM%E7%9A%84%E5%9B%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[最近学习 Vue，里面提到了 MVVM 架构，在阮老师网站上找到一篇不错的关于软件架构的说明 软件架构复杂的软件必须有清晰合理的架构，否则无法开发和维护。 MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。 昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。 MVCMVC模式的意思是，软件可以分成三个部分。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下。 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 实例：Backbone.js实际项目往往采用更灵活的方式，以 Backbone.js 为例。 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 作者：阮一峰 原文地址：MVC，MVP 和 MVVM 的图示]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈cookie]]></title>
    <url>%2F2017%2F10%2F11%2F%E8%B0%88%E8%B0%88cookie%2F</url>
    <content type="text"><![CDATA[今天被4399面试官问到了 cookie 的相关知识，之前不是很了解，现在补补… 什么是cookiecookie 译为“小甜饼，具体种类称为酥性甜饼干，这是一种中档配料的产品……”。咦，跑偏了，开个玩笑先，虽然面试过程不爽，但还是得笑对人生（生无可恋）。 我们知道HTTP是无状态的，也就说同个客户端即使多次向同个服务器发出请求，服务器也做出响应了，但他们始终都是形同陌路的“陌生人”。因此，当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，cookie 会记录如身份识别号码、密码、用户在 Web 站点购物的方式或用户访问该站点的次数等关键信息，所以 cookie 使得基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。打个比喻就像各大网站如 Google、百度、网易等给客户端颁发一个通行证，客户端需要访问网站时带上自己的通行证。这样服务器就能认出这个客户端是哪个老相好了。然而也因为 cookie 将包含但不限于上述的一些重要信息保存在用户浏览器上的小文本文件上，使 cookie 技术成为广大网民和开发人员争论的一个焦点。 cookie原理 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会把 cookie 带过去，服务端会辨别用户身份，当然服务器也可以修改 cookie 内容（后面会谈到这点）。cookie 的产生是通过扩展 HTTP 协议来实现的，服务器通过在 HTTP 响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的 cookie。然而纯粹的客户端脚本如 JavaScript 也可以生成 cookie。而 cookie 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的 cookie ，如果某个 cookie 所声明的作用范围（这个作用范围由 cookie 的 path 和 domain 同时决定）大于等于将要请求的资源所在的位置，则把该 cookie 附在请求资源的 HTTP 请求头上发送给服务器。 cookie的不可跨域名性很多网站都会使用 cookie。例如，Google 会向客户端颁发 cookie，Baidu 也会向客户端颁发cookie。那浏览器访问 Google 会不会也携带上 Baidu 颁发的 cookie 呢？或者 Google 能不能修改Baidu 颁发的 cookie 呢？ 答案是否定的。cookie具有不可跨域名性。根据 cookie 规范，浏览器访问 Google 只会携带 Google 的 cookie，而不会携带 Baidu 的 cookie。Google 也只能操作 Google 的 cookie，而不能操作 Baidu 的 cookie。 cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 cookie 而不会操作 Baidu的 cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站 cookie 的依据是域名。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 cookie。 需要注意的是，虽然网站 images.google.com与网站 www.google.com 同属于Google，但是域名不一样，二者同样不能互相操作彼此的 cookie。 注意：用户登录网站 www.google.com 之后会发现访问 images.google.com 时登录信息仍然有效，而普通的 cookie 是做不到的。这是因为 Google在后端进行了相关处理。 cookie属性cookie 的属性比较多，我们可以看下下面这张图 name这个显而易见，就是代表 cookie 的名字的意思，一个域名下绑定的 cookie ，name 不能相同，相同的 name 的值会被覆盖掉 value这个就是每个 cookie 拥有的一个属性，它表示该属性的值 domain这个是指的域名，这个代表的是，cookie 绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，还有值得注意的点，统一个域名下的二级域名也是不可以交换使用 cookie 的，比如，你设置 www.baidu.com 和 image.baidu.com ，依旧是不能公用的 pathpath这个属性默认是/，当你设置成比如/blog的时候，其实它会给 “domain+path” 范围内绑定 cookie Expires/Max-Age该属性决定 cookie 的有效期，一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除，这就是上图中的—— session (会话储存)。 如果你想要 cookie 存在一段时间，那么你可以通过设置 Expires 属性为未来的一个时间节点，Expires 这个是代表当前时间的，这个属性已经逐渐被我们下面这个主人公所取代——Max-Age。 Max-Age，是以秒为单位的，Max-Age 为正数时，cookie 会在 Max-Age 秒之后被删除。在 Max-Age 之前 cookie 是保存到硬盘上，即使关闭浏览器后再次打开，这些 cookie 仍然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。当 Max-Age 为负数时，表示的是临时储存，不会生出 cookie 文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭， cookie 就会消失，当 Max-Age 为 0 时，又会发生什么呢，删除 cookie ，因为cookie 机制本身没有设置删除 cookie ，失效的 cookie 会被浏览器自动从内存中删除，所以，它实现的就是让 cookie 失效。 secure这个属性译为安全，http 不仅是无状态的，还是不安全的协议，容易被劫持。所以当这个属性设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输。但需要强调一下这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性 HttpOnly这个属性是面试的时候常考的，如果这个属性设置为 true，就不能通过 JavaScript 脚本来获取 cookie 的值，能有效的防止xss 攻击,看 MDN 的官方文档： 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问有HttpOnly 标记的Cookie，Cookie只需要发送给服务端。如果包含服务端session信息的Cookie不想被客户端Javascript使用，那么就需要使用HttpOnly 标记 关于JavaScript操作cookiedocument.cookie 可以对 cookie 进行读写： 12console.log(document.cookie); //读取浏览器中的cookiedocument.cookie='myname=liuzhiyu;path=/;domain=.baidu.com'; // 写入 cookie 服务端如何去设置cookie 服务端就是通过 setCookie 来设置 cookie 的，注意点，要设置多个 cookie 时，得多写几个 setCookie ，我们还可以从上图看到，请求可以携带 cookie 给后端。 cookie与session本片开头已说过 HTTP 是一个不保存状态的协议。session 是服务器端使用的一种记录客户端状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 session。客户端浏览器再次访问时只需要从该 session 中查找该客户的状态就可以了。如果说 cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session对浏览器的要求虽然 session 保存在服务器中，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 session 需要使用 cookie 作为识别标志。HTTP 协议是无状态的，session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 cookie，它的值为该 session 的 id。session 依据该cookie 来识别是否为同一用户。该 cookie 为服务器自动生成的，它的 MaxAge 属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。 session中不使用cookieURL 地址重写是对客户端不支持 cookie 的解决方案。URL 地址重写的原理是将该用户 session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 session 的 id。这样即使客户端不支持 cookie，也可以使用 session 来记录用户状态。 cookie session 区别 cookie 数据存放在客户的浏览器上，session数据放在服务器上 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存20个 cookie。 鉴于上述区别我们建议 将登陆信息等重要信息存放为 SESSION 其他信息如果需要保留，可以放在 COOKIE 中 参考cookie 与 session 的区别详解 把cookie聊清楚|稀土掘金 Cookie/Session机制详解|CSDN 最后，如果本文有任何知识性错误，欢迎各位小哥哥小姐姐提出！ 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是一个函数]]></title>
    <url>%2F2017%2F09%2F30%2F%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前几天在图书馆粗略的浏览了一本叫做《代码揭秘：从C/C++的角度探秘计算机系统》的书籍。里面有一章节从计算机的底层讲解了函数的本质。恰好码农翻身公众号的推送《我是一个函数》生动的讲解了函数的知识，故转载过来学习 我和邻居我是一个函数， 生活在内存当中，我的家—用你们的”黑话”来说—就是进程的地址空间， 我的邻居也是一个函数，其中有一段很有趣的代码。 我经常去拜访他，去的时候当然不能空着手，我会携带四个数字作为礼物送给他计算， 耐心等待他在 CPU 中忙活半天，最后，作为回赠的礼物，他告诉我一个地址，让我去那里取结果。 拜访的次数多了，我慢慢地琢磨出了我这个邻居做的事情： 房贷计算。 我给他发的四个参数分别是房贷总额，利率，贷款年限，还款方式（等额本息是 1， 等额本金是 2） 他告诉我的是一个地址，其实就是一个列表，存放着每个月应还的月供、本金和利息。 用你们的“黑话”来说就是这样： List calculateHouseLoan(float total, float intrestRate, int years ,int loanType) 所有的调用都发生在本机内的一个进程中， 大家把这种方式称为本地过程调用。 这种调用方式速度飞快，眨眼间就可完成。 有时候，房贷计算邻居会惊呼道： 我赛，你给我发了一个多大的数啊， 800万的贷款总额！ 我就知道，帝都的房价又涨了！ 日子过了一天又一天， 房价也涨了一天又一天。 邻居搬走了一天早上， 我睡了一觉醒来感觉不太对劲，头晕晕的，一般情况下这就表示昨天夜里系统重启了。 还没等我清醒过来， 我就接到上司（调用我的函数）的命令，又要计算房贷了，我忍着头晕赶紧去找邻居，可是这一次却换成了陌生人， 他笑眯眯的说：“是不是要找你的邻居房贷计算啊” “是啊” “他已经搬走了！” “啊？ 他搬到哪儿去了？ 我怎么计算房贷？ ” “ 他搬到另外一台机器去住了，具体位置我也不清楚，不过从 IP 看应该是在同一个机房吧” 说实话这个消息让我吃惊不小，我听人说过，想和网络上的机器通信，那可比本机的同一进程内的通信麻烦太多了。 之前我们生活在同一个进程中，每个函数的住处（地址）对大家来说都是可见的，想要调用了，直接去函数的住处去执行代码即可。 现在这个函数都搬走了，新的地址我也不知道，就是知道了，跨域网络的调用，据说得使用什么socket，建立连接，在连接上按双方商量好格式、次序来发送数据， 接收数据，听着就头大， 打死我也搞不定。 （码农翻身老刘注： socket的故事参见《张大胖和socket》） 陌生人看出了我的担心， 笑着说： “放心吧， 我是他的客户端代理，你尽管把那四个参数交给我，我来帮你搞定” 这家伙自称为客户端代理的家伙竟然知道那个四个参数，也许能行，对我来说反正调用方式没什么变化， 于是我将信将疑地像以前把4个参数传递过去， 他马上就忙活起来，建立连接，发送数据，接收数据，过了很久（我感觉比平时要慢了100倍）他才说房贷已经计算好了，数据在地址XXXX处， 你去拿吧。 我去那个地方一查，和往常一样，每月的还款结果已经整整齐齐的摆在那里了。 “你这个房贷计算的客户端代理还真不含糊啊， 既然你是客户端代理， 难道还有服务器端代理人？ ” “没错， 我还有个好基友，在服务器端忙活， 我和他约定好了消息的格式， 你交给我的数据其实我都通过socket发给他了，由他来调用真正的房贷计算， 然后再把结果发回来。” “难道这就是传说中的远程过程调用（RPC)）？ ” 我问道 ”是的， 我们这两个代理人把脏活累活都帮着你们做了，把那些复杂的网络细节都给隐藏起来了， 在你们看来和本地调用一样。 对了，有人会把我称为 Stub，把我的好基友称为 Skeleton，我和他之间的交互是通过 socket 进行的， 有些 RPC 的代理人可能不用这么底层的东西，直接用 http，不过没关系，只要两端的代理人约定好就行了，关键是要给你们提供一个舒适的体验。” “我想到一个问题， 如果我传递给你的不是简单的 float、int 型的参数， 而是内存中的对象， 怎么处理？” “当然要做序列化了， 要不然怎么通过网络发送啊， 其实 float，int 也得做序列化， 把内存中的值和对象变成二进制流，这样才能发送出去。到了我的好基友那边，他还得做反序列化，把而二进制流再转化为对象， 然后才能调用真正的函数， 唉，这工作实在是麻烦啊。” 我对他表示了深切的同情和敬意， 为了我们能做透明的远程调用，这些代理们真不容易。 “我听说还能用 XML 和 JSON ？” 我问道 “你知道的不少嘛 ！ 有些人在使用 Http 作为通信协议的时候， 喜欢把对象变成文本，例如XML/JSON，可读性比较好，但是你要知道，虽然应用层的 HTTP 中看起来时文本， 但是到了底层通道例如 TCP 发送出去的时候，那还得变成二进制流， 到了目的地再把他们转化成文本。”（码农翻身老刘注： 参加《序列化：一个老家伙的咸鱼翻身》） 聊了半天，我们越来越熟， 我无意间谈起了他的身世， 他说 ： “我们这些代理人啊，出生的方式主要有两种， 一种就是程序员们一行行代码的把我们给敲出来、费心而费力， 另外一种就是自动生成。” “自动生成，具体怎么做？” “拿Java来举个例子， 你可以先定义一个接口(interface), 让这个接口扩展自java.rmi.Remote， 然后写个实现类， 最后用一个工具rmic就可以自动生成客户端和服务器端的代理人了 ， 是不是很简单？ ” 1234567891011121314public interface HouseLoanCalculator extends Remote&#123; public List calculate(float total,float interestRate,int years,int loanType) throws RemoteException;&#125;public class HouseLoanCalculatorImpl extends UnicastRemoteObject implements HouseLoanCalculator&#123; @Override public List calculate(float total,float interestRate, int years,int LoanType) throws RemoteException&#123; //实现房贷计算 &#125;&#125; （码农翻身老刘注： 从JDK5.0开始， 连这个rmic这一步都可以省略， 完全由JVM自动生成，运行时可以把客户端代理人下载到客户端） 网络的世界远比单机精彩， 不知不觉我已经和这个代理人聊了将近800毫秒， 我的上司已经等不及了，他抱怨地说： “这次怎么这么慢？ 难道人类在调试，在你这里加了断点？” 我说 ：“没有调试， 原来是本地过程调用，现在变成远程过程调用了！” 作者：码农翻身刘欣 出处：我是一个函数|码农翻身]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法大杂烩]]></title>
    <url>%2F2017%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%9D%82%E7%83%A9%2F</url>
    <content type="text"><![CDATA[学习数据结构之后那么算法也是必须需要了解的，甚至对于某些开发人员来说算法是他们开发工作中最为重要的一部分。数据结构和算法又是密不可分的，特定的算法需要特定的数据结构才能发挥出应有的效率。其中，熟悉各种基本的排序算法是程序猿的基本技能之一 引子“算法+数据结构=程序”，这是一名瑞士的计算机科学家 Nicklaus Wirth 提出的著名公式，而他本人也凭借这一句话获得了图灵奖。百科百科上有这么一句评价“这个公式对计算机科学的影响程度足以类似物理学中爱因斯坦的 $E=MC^2$ ” 。而排序算法又是各类算法中最为基础但也较为有用的算法之一，因此对它的了解也显得十分必要和重要。为了叙述方便，本文随后讨论的排序问题都约定为从小到大的排序。 选择排序简单选择排序简单选择排序（Simple Selection Sort）是一种直观的排序算法，其思想是在未排序的序列中选出最小的元素和序列的首位元素交换，接下来在剩下的未排序序列中再选出最小元素与序列的第二位元素交换，以此类推，最后形成从小到大的已排序序列。 下列给出 C 语言实现： 12345678910111213141516void Swap(ElementType *a,ElementType *b)&#123; ElementType t=*a; *a = *b; *b=t;&#125;void SimpleSelectionSort(ElementType A[], int N)&#123; int i,j,min; for(i=0;i&lt;N-1;i++)&#123; min=i; for(j=i+1;j&lt;N;j++)&#123; if(A[j]&lt;A[min])&#123; min=j; //min记录最小元素位置 &#125; Swap(&amp;A[i],&amp;A[min]); //将第 i 个元素与最小元素交换 &#125; &#125;&#125; 可以看出，因为循环中嵌套循环，故其时间复杂度为 $O(N^2)$ 。最好情况下移动元素的次数为 0 次，这时序列已有序。最坏的情况下为 $3(N-1)$ 次（除了最后一个元素外，每个元素都要经过 3 步交换位置）。 堆排序堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。我们知道堆是一种特殊的二叉树，每个子结点的值总是小于（或者大于）它的父结点，相应地分为最大堆和最小堆。由于堆是一个完全二叉树，一般情况下堆排序都是用数组的方式来实现。 堆排序的核心思想是：利用最大堆（或者最小堆）输出堆顶元素，即最大值（或最小值），将剩余元素重新生成最大堆（或者最小堆），继续输出堆顶元素，重复此过程，直到全部元素都已输出，得到的输出元素序列即为有序序列。 实现堆排序方法一种简单的做法是额外开辟一个辅助的数组空间，将堆顶元素逐一放入辅助数组里，最后再把辅助数组的内容复制回原始的数组。这种方法的额外空间复杂度是 $O(N)$ 。下面我们讨论一种更聪明的方法，只用 $O(1)$ 的额外空间即可。 如下图所示，首先将一个无序的序列生成一个最大堆，如图（a）所示。接下来我们不需要将堆顶元素输出，只要将它与堆的最后一个元素对换位置即可，如图（b）所示。这时我们确知最后一个元素 99 一定是递增序列的最后一个元素，而且已经在正确的位置上。 现在问题变成了如何将剩余的元素重新生成一个最大堆——也很简单，只要依次自上而下进行过滤，使其符合最大堆的性质。图（c）是调整后形成的新的最大堆。要注意的是，99 已经被排除在最大堆之外，即在调整的时候，堆中元素的个数应该减 1 。结束第 1 轮调整后，再次将当前堆中的最后一个元素 22 与堆顶元素换位，如图（d）所示，再继续调整成新的最大堆……如此循环，直到堆中只剩 1 个元素，即可停止，得到一个从小到大排列的有序序列。 插入排序简单插入排序简单插入排序的核心思想就是：将待排序的一组序列分为已排好序的和未排好序的两个部分；初始状态时，已排序序列仅包含第一个元素，为排序序列中的元素为除去第一个以外 $N-1$ 个元素；此后将为排序序列中的元素逐一插入到已排序的序列中。如此往复，经过 $N-1$ 次插入后，未排序序列中元素个数为 0，则排序完成。 具体到第 $k-1$ 次插入，对应待插入元素应为第 $k$ 个元素，也就是未排序序列中的第一个元素，插入的基本过程是：将它和第 $k-1$ 个元素（也就是已排序序列的最后一个元素）进行比较，若 大于第 $k-1$ 个记录，则该次循环结束；否则，将两个元素交换，再比较该数和第 $k-2$ 个元素之间 的大小，依此往复，直到该数比它当前位置的前一个元素大，或该数已交换到了第 1 个位置，则第 $k-1$次循环结束。 下面我们来看一个例子。下表显示了对 {44，12，59，36，62，43，94，7，35，52，85} 进行简单插入排序的前 3 次循环的情况。在第 2 次循环结束后，已排序序列中有 3 个记录。第 3 次循环第 1 步，将未排序序列中的第一个记录 36 和已排序组中的最后一个记录59进行比较，因满足 $36&lt;59$ ，因此交换这两个记录；第 2 步，36仍然小于一个记录 44 ，则继续交换；直到大于前一个记录 12 ，则停止交换，第 3 次循环结束。已排序序列中新增记录 36，未排序序列中删除该记录，记录数量减 1 。 下面给出代码实现： 1234567891011void InsertionSort(ElementType A[],int N)&#123; int P,i; ElementType temp; for(P=1;P&lt;N;P++)&#123; temp=A[P]; //取出未排序序列中的第一个元素 for(i=P;i&gt;0&amp;&amp;A[i-1]&gt;temp;i--)&#123; A[i]=A[i-1]; //依次与已排序序列中元素比较并右移 &#125; A[i]=temp; //放进合适的位置 &#125;&#125; 由该算法代码可以看出，空间复杂度上，简单插入排序仅需要常数个额外空间；时间复杂度上，函数中有 2 个嵌套的循环，每个循环进行 $O(N)$ 次比较和交换，因此整个简单插入排序的平均时间复杂度为 $O(N^2)$ 。在最坏的情况下，对应每一个 P ,要进行P- 1 次比较和交换，总共要花费 $O(N^2)$ 次操作；在最好的情况下，也就是对已经排好序的序列进行排序，第二个循环在第一个$(A[i-1]&gt;temp)$ 比较时就跳出，因此总共花费 $O(N)$ 次操作。此外，简单插入排序是稳定的排序，我们发现，数值相同的两个记录不会发生相对位置上的改变。 希尔排序简单插入排序效率不高的一个重要原因是每次只交换相邻的两个元素，这样只能消去一对错位的元素。希尔排序对插人排序进行改进，试图通过每次交换相隔一定距离的元素，达到排序效率上的提升。 希尔排序的基本原理是，将待排序的一组元素按一定间隔分为若干个序列，分别进行插入排序。开始时设置的“间隔”较大，在每轮排序中将间隔逐步减小，直到“间隔”为 1 ，也就是最后一步是进行简单插入排序。 希尔排序将“间隔”定义为一组增量序列，用来分割待排序列，即将位置之差等于当前增量的元素归属于同一个子序列，并分别进行插入排序；排好后再选取下一个增量，划分子序列再次排序，直到最后一个增量（一般为1)。 【例子】对于待排序列 {44，12，59，36，62，43，94，7，35，52，85}，我们可设定增量序列为 {5，3，1}。 【解析】第一个增量为 5，因此 {44，43，85}、{12，94}、{59，7}、{36，35}、{62，52} 分别隶属于同一个子序列，子序列内部进行插入排序；然后选取第二个增量3，因此 {43，35，94，62}、{12，52，59，85}、{7，44，36} 分别隶属于同一个子序列；最后一个增量为 1，这一次排序相当于简单插入排序，但是经过前两次排序，序列已经基本有序，因此此次排序时间效率就提高了很多。希尔排序过程如下： 希尔排序算法的整体时间复杂度和增量序列的选取有关，目前并没有统一的最优增量序列。但使用增量序列 {[$N/2$]，[$N/2^2$]，…，1} 进行希尔排序时，最差情况下时间复杂度为 $O(N^2)$ ；而当使用增量序列 {$2^k-1$，…，7，3，1} 时，最差情况下时间复杂度为 $O(N^{3/2})$ ，其平均时间复杂度尚无定论，猜想结果为 $O(N^{5/4})$ 。除此之外，还有不少其他的增量序列选取方法，在各自特定的排序对象中有较好的时间复杂度的表现。 交换排序冒泡排序冒泡排序估计是很多非计算机相关专业学生都知道的排序算法，这也是交换排序中比较简单的方式。对元素个数为$N$的待排序序列进行排序时， 共进行 $N-1$ 次循环。在第 $k$ 次循环中，对从第 1 到第 $N-k$ 个元素从前往后进行比较，每次比较相邻的两个元素，若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变。这样一次循环下来 ， 就把第 $k$ 大的元素移动到第 $N-k$ 个位置上，称为第 $k$ 趟的冒泡。整个过程一共进行 $N-1$ 趟冒泡 ，直到第 1 个和第 2 个元素比较完成 ，最终剩余最小的元素 ，留在第 1 个位置上，排序结束。 我们来看下例中对给定初始序列的冒泡排序过程，会有十分直观的理解：第 1 趟冒泡后,最大的记录 94 被移动到了第 $N$ 个位置上，它将不参与接下来的冒泡；第 2 趟冒泡后，剩余 $N-1$ 个记录中最大的记录 85 被移动到了第 $N-1$ 个位置上；经过 $N-1$ 趟冒泡后，剩余的最小记录 7 留在第 1 个位置上，排序结束，如下表所示。 快速排序快速排序也是交换排序的一种，但和冒泡排序不同的是，冒泡排序只比较相邻两个记录 的顺序，而快速排序的原理是：将未排序元素根据一个作为基准的“主元”（Pivot）分为两个子序列，其中一个子序列的记录均大于主元，而另一个子序列均小于主元，然后递归地对这两个 子序列用类似的方法进行排序。本质上，快速排序使用分治法，将问题的规模减小，然后再分别进行处理。 首先，子序列的划分方法我们可以参考利用函数递归求取集合的中位数问题的解答。求得中位数后，将该中位数设置为待排序序列的主元，将比主元大的元素从右向左放置，而比主元小的元素从左向右放置。 下表给出了进行一趟主元调整的过程，具体步骤为： 选择一个主元，并与最后一个元素交换。 设置两个指针 Low 和 High ，初值分别指向第一和倒数第二个元素。 Low 从左向右扫描，其位置左侧为已遍历或交换过的比主元小的元素；High从右往左扫描 ， 其位置右侧为已遍历或交换过的比主元大的元素。首先从 Low 指向的位置向右扫描，若遇到比主元大的元素，则停止；然后从 High 指向的位置向左搜索，若遇到比主元小的元素，则停止。 若 Low 和 High 没有错位（即Low&lt;High)，则 High 和 Low 指向的元素互换位置。 重复3、4直至 High 和 Low 错位，将基准与 A[Low] 对换位置。这就完成了一次划分，以主元为边界分别划分成大于和小于主元的两个子序列。 递归地对两个子序列用同样方法进行快排直至当前子序列只有一个元素时结束递归，这样就达到了分而治之的算法目的。 归并排序归并排序是建立在归并操作基础上的一种排序方法。归并操作，是指将两个已排序的子序列合并成一个有序序列的过程。 归并排序的基本原理是：将大小为 $N$ 的序列看成 $N$ 个长度为 1 的子序列，接下来将相邻子序两两进行归并操作，形成$N/2(+1)$ 个长度为 2（或1）的有序子序列；然后再继续进行相邻子序列两两归并操作，如此一直循环，直到剩下 1 个长度为 $N$的序列，则该序列为原序列完成排序后的结果，如下图所示。 归并排序的核心在于归并操作的实现。归并操作的过程如下：首先申请额外的空间用于放置两个子序列归并后的结果，接着设置两个指针分别指向两个已排序子序列的第一个位置，然后比较两个指针指向的元素，将较小的元素放置到已申请的额外空间内，并将当前位置向后移动一格，重复以上过程，直到某一个子序列的指针指向该序列的结尾。这时候将另一个指针所指向序列的剩余元素全部放置到额外空间内，归并操作结束。 下面举个栗子 其实从相反的角度来看，归并排序可以看成是分治法的逆向过程。 基数排序桶排序如果已知 $N$ 个关键字的取值范围是在0到 $M-1$ 之间，而$M$比$N$小得多，则桶排序算法将为关键字的每个可能取值建立一个“桶”，即建立$M$个桶；在扫描$N$个关键字时，将每个关键字放入相应的桶中，然后按桶的顺序收集一遍就自然有序了。所以桶排序效率比一般的排序算法高——当然需要的额外条件是已知关键字的范围，并且关键字在此范围内是可列的，个数还不能超过内存空间所能承受的限度。 【例子】已知某门公共选修课有1500学生选修，其成绩为分布于[0，100]之间的整数。现需要将学生名单按其成绩从低到高顺序打印出来。 【分析】若将学生名单按成绩排序再打印，则至少需要 $O(NlogN)$ 的时间，这里 $N=1500$ 。而用桶排序的方法，可为每一个分数建立一个“桶”，共建101个桶——具体实现时可定义一个链表指针数组 Bucket[101]。顺序扫描学生名单，若当前这个学生的成绩是$i$分，则将他的记录插入 Bucket[ i] 所指的链表头部，这一操作只需2步。整个扫描的过程用去 $O(N)$ 的时间。然后顺序扫描每个Bucket[i]，将链表中的学生名单逐一打印，该过程用$O(N+M)$的时间，其中$M=101$是桶的个数。可见桶排序只需要$O(N+M)$的时间就可以完成名单的顺序打印，特别当$M=O(N)$时，这个时间复杂度是线性的。 基数排序基数排序是桶排序的一种推广，它所考虑的待排记录包含不止一个关键字。例如对一副牌的整理，可将每张牌看作一个记录，包含两个关键字：花色、面值。一般我们可以将一个有序列是先按花色划分为四大块，每一块中又再按面值大小排序。这时“花色”就是一张牌的“最主位关键字”，而“面值”是“最次位关键字”。 对于一般有 $K$ 个关键字的情况，基数排序通常有两种方法：主位优先法（ Most Significant Digit Sort，简称 MSD）和次位优先法（ Least Significant Digit Sort，简称 LSD）。 仍以整理扑克牌为例，顾名思义，新谓主位优先法，是先为最主位关键字（花色）建立桶，将牌按花色分别装进4个桶里；然后对每个桶中的牌，再按其次位关键字（面值）进行排序，最后将4个桶中的牌收集，顺序叠放在一起。 而次位优先法，是先为最次位关键字建立桶，即按面值建立13个桶，将牌按面值分别放于13个桶中；然后将所有桶中的牌收集，顺序叠放在一起；再为主位关键字花色建立4个桶，顺序将每张牌放人对应的花色桶中，则4个花色桶中的牌必是有序的，最后只要将它们收集，顺序叠放即可。 从上述例子可见，两种方法具有不同的特点。主位优先法基本上是分治法的思路，将序列分割成子列后，分别排序再合并结果。而次位优先法是将“排序”过程分解成“分配“和“收集”这两个相对简单的步骤，并不需要分割子列排序，故一般情况下次位优先法的效率更高一些。 单关键字的基数分解从上面可以看到，基数排序主要是对有多关键字的对象进行排序。其实可以将单个整型关键字按某种基数分解为多关键字，再进行排序。这也是“基数排序”名称的由来。例如 826 可以根据基数 10 分解为 8、2、6 这三个关键字，其中 8 是最主位关键字，6是最次位关键字；还可以根据基数 16 分解为 3、3、A 这 3 个关键字，其中第一个3是最主位关键字，A 是最次位关键字。 典型问题是给定 $N$ 个记录，每个记录的关键字为一整数，其取值范围是 0 到 M 之间。若 M 比 N 大很多（例如 $M=N^K$），这时桶排序需要 M 个桶，会造成巨大的空间浪费；而以为基数对关键字进行分解后则只需要 $R$ 个桶就可以了。让我们通过一个具体的例子来理解什么是基数分解。 【例子】给定范围在 0 到 999 之间的 10 个关键字 164,8,216,512,27,729,0,1,343,125 现用基数排序算法进行递增排序。 【分析】我们可以将每个关键字看成一个 3 位的十进制整数（不足位的在左边补 0 )，从而将每个十进制整数关键字分解成 3 个关键字，其个位数为最次位关键字，百位数为最主位关键字。这就是以 10 为基数的分解。对给定的 10 个记录用次位优先法进行基数排序，首选对最次位（个位）关键字建立 10 个桶，将记录按其个位数字的大小放入相应的桶中，如下图（a）所示。此时 10 个数字恰好均匀分布于 10 个桶中，当然一般情况下不是总有这么好的运气。每个“桶”实际上是一个链表，一趟排序后，将桶中记录重新收集成为一个新的记录链 {0，1，512，343，64，125，216，27，8，729}。接下去按下一个次位关键字（十位）排序，所得结果如下图（b）所示。注意到此时桶中记录的分布不再均匀。向桶中插入的新记录需排在链表尾部。将桶中记录收集形成新的记录链 {00，01，08，512，216，125，27，729，343，64}。最后按最主位（百位）关键字排序，结果如下图（c）所示，再收集所得的记录链就是最终有序的 {000，001，008，027，064，125，216，343，515，729}。 外部排序外部排序是指大文件排序，即待排序的数据记录以文件的形式存储在外存储器上。由于文件中的记录很多、信息容量庞大，所以整个文件所占据的存储单元往往会超过了计算机的内存量，因此，无法将整个文件调入内存中进行排序。于是，在排序过程中需进行多次的内外存之间的交换。在实际应用中，由于使用的外设不一致，通常可以分为磁盘文件排序和磁带文件排序两大类。 外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含 $N$ 个记录的文件分成若干长度为 $L(&lt;N)$ 的子文件，依次读入内存，利用内部排序算法进行排序。然后，将排序后的文件写入外存，通常将这些文件称为归并段（Run）或“顺串”；对这些归并段进行逐步归并，最终得到整个有序文件。可见外部排序的基本方法是归并排序法，下面的例子给出了一个简单的外部排序解决过程。 【例子】给定磁盘上有6大块记录需要排序，而计算机内存最多只能对3个记录块进行内排序，则外部排序的过程如下图所示。 【解析】首先将连续的3大块记录读入内存，用任何一种内部排序算法完成排序，再写回磁盘。经过2次3大块记录的内部排序，得到上图（a）的结果。然后另用一个可容纳6大块记录的周转盘，辅助最后的归并。方法是将内存分成3块，其中2块用于输入，1块用于输出，指定一个输入块只负责读取一个归并段中的记录，如上图（b）所示。归并步骤为： 当任一输入块为空时，归并暂停，将相应归并段中的一块信息写入内存 将内存中2个输入块中的记录逐一归并入输出块 当输出块写满时，归并暂停，将输出块中的记录写入周转盘 如此可将2个归并段在周转盘上归并成一个有序的归并段。上例的解决方法是最简单的归并法，事实上外部排序的效率还可以进一步提高。要提高外排的效率，关键要解决以下4个问题： 如何减少归并轮数 如何有效安排内存中的输入、输出块，使得机器的并行处理能力被最大限度地利用 如何有效生成归并段 如何将归并段进行有效归并 针对这四大问题，人们设计了多种解决方案，例如釆用多路归并取代简单的二路归并，就可以减少归并轮数；例如在内存中划分出2个输出块，而不是只用一个，就可以设计算法使得归并排序不会因为磁盘的写操作而暂停，达到归并和写周转盘同时并行的效果；例如通过一种“败者树”的数据结构，可以一次生成2倍于内存容量的归并段；例如利用哈夫曼树的贪心策略选择归并次序，可以耗费最少的磁盘读写时间等。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[日常使用 Git ，但是有一些不常用的命令就是记不住，老要去翻。现在特意列出一个命令清单，记录一下常用命令，以备不时之需 几个专用名词的译名如下： workspace：工作区 Index / Stage：暂存区 Repository：仓库区（本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 原作者：阮一峰 原文地址：常用 Git 命令清单]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端大讲座]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%89%8D%E7%AB%AF%E5%A4%A7%E8%AE%B2%E5%BA%A7%2F</url>
    <content type="text"><![CDATA[之前一直以为 Web 前端就是三剑客 JavaScript、CSS、HTML的天下，直到昨晚看见一片微信推送，特别是文章的后面两个章节，让我对前端的概念有了一个更加全面的了解，因此特意转载过来供大家学习 本文的分享主要分为以下三个部分 由于目前计算机专业还没有为 Web 前端技术设立专门的课程，每位同学对前端的了解程度也不一样，今天的讲座会以最浅显的方式来为大家介绍 “前端”，帮助大家建立一个基本的概念。 前端是什么 在回答这个问题之前，我想到了一道面试题： 当我们在浏览器中输入网址并按回车之后，接下来会发生什么？ 我们来简单地看一看 “网页展现” 的整个过程。 比如这里有一个用户，它需要访问 abc.com 这个网址。一般来说，当用户输入一个域名时，是在请求一个 HTML 资源。当他完成域名解析之后，他的浏览器会向 abc.com 这个域名所指向的 Web 服务器发出请求。 有时候 Web 服务器直接就可以返回用户的请求了；有时候 Web 服务器还需要向数据库查询一些数据，然后才能把处理结果返回给用户。 当用户的浏览器拿到服务器返回的 HTML 资源之后，就开始解析并显示 HTML 的内容了。 一般来说，HTML 页面需要 CSS 资源来描述页面的样式。比如浏览器在解析 HTML 时发现了一个 CSS 外链 abc.com/a.css，它就会去请求这个资源。 HTML 页面往往还需要加载外部的 JS 资源，比如 abc.com/a.js，此时浏览器同样会向服务器请求这个资源。 当所需的资源都加载完成之后，这个页面就可以提供完整的外观和功能了。整个过程差不多就是这个样子了。 我们看一看这张流程图，可以在中间画一道竖线，把它分成左右两个部分。 我们会发现，这道线左侧的事情发生在浏览器端，我们称之为 “前端”；右侧的事情发生在服务器端，称为 “后端”。（“前端” 之所以叫 “前端”，是因为它离用户更近一些。） 大家都学过后端开发的相关课程，对后端这一块应该都比较熟悉了。那问题来了：在上面这个过程中，后端有哪些局限？ 服务器一旦把资源提供给浏览器之后，便失去对内容的影响。 服务器无法得知用户在浏览器里做了什么，无法与用户交互。 这意味着，只有当用户下一次向服务器请求资源时，服务器才有机会再次决定用户看到的内容。那么，用户什么时候再向后端请求资源呢？ 第一种情况是 “导航动作”。比如用户刷新页面、点击链接、点击浏览器的前进/后退等等。 第二种情况是用户提交表单。表单是最传统的页面交互方式之一，提交表单时浏览器会向服务器发出新请求——这意味着浏览器会跳转到一个新的地址，服务器会在新页面中显示表单的处理结果。 还有一种特殊情况，就是服务器在给浏览器返回 HTML 资源时，在页面中插入一个特殊的标记，浏览器看到这个标记就会在一定的时间后自动刷新当前页面或跳转到其它页面，相当于服务器强制用户再次发出请求。可想而知，这种非用户意愿驱动的页面跳转行为并不讨人喜欢，因此已经不常用了。 在传统网页中，上述几种用户与服务器之间的交互方式也算够用了。不过随着网页形态的不断演进，用户对网页体验提出了更高的要求，很多时候网页不仅仅是一篇静止的文档，而更像是一个应用程序，用户随时可能与之互动。这个时候，前端的价值就体现出来了。 用户从停留在当前页面到发起新请求的这段时间内，前端可以控制页面内容。 当用户停留在当前页面时，前端有能力与用户交互。由于前端的 JS 可以监听用户在浏览器中的各种行为（比如鼠标点击、键盘输入、滚动页面等等），前端就可以针对这些行为作出相应的反馈。 在前端与用户的交互过程中，有些事情光靠前端就可以做出响应。比如我们在网页上做了一个计算器的功能，当用户输入算式之后，JS 就可以直接计算出结果并显示给用户。整个过程不需要服务器的参与就可以完成。 但有些事情，光有前端是无法完成的。此时前端就需要交给后端来处理，拿到处理结果之后再交给用户。在这个过程中，前端可以让用户一直停留在当前页面，交互过程具有良好的连续性。 那么，前端如何把任务交给后端并拿到后端处理的结果呢？主要有两种方式：Ajax 和 Socket 连接。 Ajax 是最常见的前后端交互方式。它以 “请求→响应” 的方式来完成前后端的信息传递。传统的表单交互需求几乎都可以由 Ajax 改造为 “原地提交并获取反馈” 的交互方式，不需要跳转页面，从而有效提升用户体验。 而对于实时性比较高的场景，Socket 连接就是一个更好的选择。它的工作方式是前后端建立一个持续的连接，信息可以随时由前端发向后端，或由后端推送到前端。如果我们要建立一个实时对话的应用，通常就会用到 Socket 连接了。 前端需要用到哪些技术 说到前端技术，我们通常都会说到 “三大块”： HTML CSS JS 这是前端最核心的三项技术。 接下来，我们就会说到 “前端的分层架构”。这个架构的原则就是 “让合适的技术去做合适的事情”。一个网页从逻辑上可以视为这三层的有机结合体： 结构层：这一层的作用是表述一个页面中有哪些信息，以及这些信息之间的关系是什么。这一层在技术上是由 HTML 来实现的。 表现层：这一层决定了页面中的信息会以什么样的外观呈现出来。这一层由 CSS 来实现。 行为层：这一层控制了页面如何与用户进行交互。在传统的展示型网页中，可能只需要 “结构层” 和 “表现层” 就足以提供完整的功能；而现代网页承载了越来越多的交互，这就推动 “行为层” 的能力不断增强。这一层由 JS 来实现。 我们通过一个实例来理解这个分层架构。 比如我是一个百姓网的用户，我打开了 “用户中心” 中的 “我发布的信息” 这个页面 这个页面的 HTML 描述了信息以及信息的结构。即使没有 CSS 和 JS 的辅助，这个页面仍然可以呈现出可理解的内容（参见上图）。页面顶部是一些导航元素，接下来的 “显示中的信息” 是一个标题，它又引出了一个列表。这个列表自然就是我在百姓网发布的所有信息了。（除了 “显示中的信息” 以外，页面后半段还有 “已删除的信息”，这里不再赘述。） 接下来，我们会在表现层下功夫，通过 CSS 来为页面中的各个元素设定外观。经过这一层的修饰之后，页面中的内容更加美观了；更重要的是，各元素的功能职责也更加直观易懂了（参见上图）。 这已经是一个挺不错的网页了，但接下来，我们还会通过 JS 来丰富它的功能，提升用户的使用效率。 作为信息的发布者，我可能需要修改某条信息的内容，或对它进行 “刷新” 之类的操作。在传统的交互中，我需要在这个列表中点击需要操作的信息，然后在信息的详情页选择合适的操作。 我们可以把这个流程简化一下：我们在这个列表中为每条信息添加一个操作按钮，当用户点击某条信息的操作按钮时，我们就在页面中弹出一个操作面板，用户可以直接选择想要的操作，减少了中间环节（参见上图）。 由此可见，结构层、表现层、行为层这三者各有所长，共同构造了一个功能完备、体验良好的网页出来。 除了基本的 “三大块” 之外，作为前端工程师，我们还需要掌握以下知识和技能： HTTP 相关：由于前端资源都是浏览器通过网络下载的，因此我们有必要了解相关的网络协议。 浏览器相关：前端代码运行在浏览器中，我们需要了解浏览器的各种特性，以及浏览器向我们提供的各种接口。 前端性能优化：让网页更快，减少用户的等待，这也是前端工程师面临的重要课题。优化网页的前端性能，需要我们具备上面两项知识，并且掌握性能优化相关的工具和方法。 图形图像：网页信息不仅包含文字，还包含图片、视频等多媒体信息。图片作为最常用媒体资源，需要我们掌握与其相关的技能。比如了解各种图片格式适用的场景、基本的图片处理方法等等。 前端的开发方式是怎样的 前面我们已经介绍了前端技术 “三大块”，然而在如今，当我们在编写这三块的代码时，已经不再 “裸写” 了。这意味着我们在开发阶段编写的代码与实际在浏览器环境中运行的代码已经不一样了，详细来说： 我们通过模板语言来生成 HTML。 通过 CSS 预处理器来生成 CSS 代码。 通过 ES6+ 的语法和特性来编写 JS 代码。 举例来看吧，以下三个例子展示了代码书写方式的演化。 百姓网采用了 Jade 和 Jedi 这两种模板语言。在上图的代码中，我们仅仅使用了模板语言最基本的标记语法，还没有插入使用模板语言的任何逻辑能力。仅此一步，就可以看出模板语言带来的好处。 原先我们在写 HTML 代码时，会花费大量的精力在 &lt;、/、&gt; 这样的语法噪音上；同时，识别标签的嵌套关系也很费眼。幸运的是，Jade 和 Jedi 这样的现代模板语言把前端工程师解放了出来。它们通过缩进来表达嵌套关系，层级关系一目了然；语法更精练，表现力更强。 在 CSS 方面，预处理器一方面通过更简洁的语法减轻开发者的书写负担，另一方面通过内置的逻辑能力增强了代码的表现力。举个例子，在使用原生 CSS 来写代码时，不同元素采用的相同颜色只能分散在代码各处；而采用了 CSS 预处理器之后，我们可以把相同意义的颜色通过变量的形式抽象出来，然后在代码各处调用即可。这样不仅便于后期维护，在平时读代码时也更容易理解代码意图。 在 JS 方面，我们开始享受 ES6+ 带来的新特征福利。ES（ECMAScript）是定义 JS 这门语言的标准规范，从第六版开始，ES 以每年一版的节奏持续快速地扩展着 JS 语言的能力。 在以往，如果我们要实现 “在数组中找出符合特定条件的成员” 的需求，往往需要借助 Underscore 这样的工具库，调用它的 _.find() 方法。而在 ES6 中，语言本身就扩展了数组的能力，我们只需要直接调用 Array#find() 接口即可。另外，像箭头函数这样的新语法也可以令代码进一步简化。 在 HTML、CSS、JS 这三大块，我们放弃 “裸写”，采用 “更高级” 语言的目的在于： 利用高级语言提供的 “逻辑能力” 来增强代码的表现力。 利用高级语言的 “语法糖” 和 “新特性” 来提升开发效率和舒适度。 当然，采用这些更高级的语言也不是完全没有成本的。我们在开发阶段所用的语言已经不是纯粹的 HTML、CSS、JS 了，浏览器无法直接识别和运行。因此，当我们放弃 “裸写”，也就意味着： 在部署流程中需要设立构建环节，把源码编译到浏览器环境可以运行的目标代码。 在开发阶段，需要有工具来实时监视并编译有变动的源码，以确保页面上呈现的是我们修改过的最新效果。 在百姓网，前端架构组已经搭建好了必要的开发环境，开发者们只需要关注开发本身就可以了。 在企业级的前端开发中，我们还需要了解如下知识点： 模块化：模块化是最常见的编程实践之一，令我们的代码组织更加清晰、易维护。ES6 为 JS 增加了完善的模块化方案，我们的日常开发也已经迁移到了 ES6 模块规范之下。 包管理：如何将开源社区中的优秀组件为我所用？这就不能不提 “npm” 这个最主流的 JS 包管理器。前端界优秀的开源项目几乎都发布到了 npm 的包仓库，我们日常开发中用到的第三方库也都是由 npm 来管理的。 打包工具可以把我们写的模块化的源码和第三方包整合到一起，形成页面所需的完整 JS 资源。“包管理器”、“模块化”、“打包工具” 的相互结合，基本上就是日常的 JS 代码组织方式。 组件化：在传统的前端开发中，HTML、CSS、JS 这三块的代码有各自独立的文件，这些文件往往也分散在不同的目录结构中。 如果页面功能区块的划分足够清晰，开发者就可以用 “组件” 的概念来把页面拆分，整个页面会被视为多个组件的嵌套和组合；同时，开发者也倾向于把每个组件相关的 HTML、CSS、JS 代码整合到同一个目录（或同一个文件）中，便于管理和维护。 这就是 “组件化” 的开发模式。要实现这样的开发模式，通常需要前端框架和构建工具的配合。 单页应用：HTML5 的 History API 为前端提供了控制浏览器导航行为的能力，配合 Ajax 无刷新更新页面内容的特性，我们可以在一个页面内实现应用的多视图切换，避免页面的频繁跳转，提供类似桌面应用的体验。比如 Gmail 等产品就是典型的单页应用模式，百姓网的大多数后台系统也都是单页应用。 其它实用的知识点，就留待大家在工作中慢慢发掘吧。 原文地址：给不了解前端的同学讲前端 版权归原作者所有]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 开发进阶：理解 JavaScript 作用域和作用域链]]></title>
    <url>%2F2017%2F09%2F01%2FJavaScript-%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%90%86%E8%A7%A3-JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[作用域是 JavaScript 最重要的概念之一，想要学好 JavaScript 就需要理解 JavaScript 作用域和作用域链的工作原理。恰好看见一篇不错的博文，就转载过来以供学习理解 JavaScript 作用域任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。 全局作用域（Global Scope）在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：123456789101112var authorName="山边小溪";function doSomething()&#123; var blogName="梦想天空"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(authorName); //山边小溪alert(blogName); //脚本错误doSomething(); //梦想天空innerSay() //脚本错误 所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：12345678function doSomething()&#123; var authorName="山边小溪"; blogName="梦想天空"; alert(authorName);&#125;doSomething(); //山边小溪alert(blogName); //梦想天空alert(authorName); //脚本错误 变量blogName拥有全局作用域，而authorName在函数外部无法访问到。 所有 window 对象的属性拥有全局作用域一般情况下，window 对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（Local Scope）和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域，例如下列代码中的blogName和函数innerSay都只拥有局部作用域 123456789function doSomething()&#123; var blogName="梦想天空"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(blogName); //脚本错误innerSay(); //脚本错误 作用域链（Scope Chain）在 JavaScript 中，函数也是对象，实际上，JavaScript 里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 Scope ，由 ECMA-262 标准第三版定义，该内部属性 Scope 包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数： 1234function Add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125; 在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）： 函数 Add 的作用域将会在执行时用到。例如执行如下代码： 1var total = Add(5,10); 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数内部属性 Scope 所包含的对象。 这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示： 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 作用域链与代码优化从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码： 12345function changeColor()&#123; document.getElementById("btnChange").onclick=function()&#123; document.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125; 这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下： 123456function changeColor()&#123; var doc=document; doc.getElementById("btnChange").onclick=function()&#123; doc.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125; 这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。 改变作用域函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。 with 语句是对象的快捷应用方式，用来避免书写重复代码。例如： 1234567891011121314function initUI()&#123; with(document)&#123; var bd=body, links=getElementsByTagName("a"), i=0, len=links.length; while(i &lt; len)&#123; update(links[i++]); &#125; getElementById("btnInit").onclick=function()&#123; doSomething(); &#125;; &#125;&#125; 这里使用 with 语句来避免多次书写 document ，看上去更高效，实际上产生了性能问题。当代码运行到 with 语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示： 因此在程序中应避免使用 with 语句，在这个例子中，只要简单的把 document 存储在一个局部变量中就可以提升性能。 另外一个会改变作用域链的是 try-catch 语句中的 catch 语句。当 try 代码块中发生错误时，执行过程会跳转到 catch 语句，然后把异常对象推入一个可变对象并置于作用域的头部。在 catch 代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码： 12345try&#123; doSomething();&#125;catch(ex)&#123; alert(ex.message); //作用域链在此处改变&#125; 请注意，一旦 catch 语句执行完毕，作用域链机会返回到之前的状态。try-catch 语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少 catch 语句对性能的影响。一个很好的模式是将错误委托给一个函数处理，例如： 12345try&#123; doSomething();&#125;catch(ex)&#123; handleError(ex); //委托给处理器方法&#125; 优化后的代码，handleError 方法是 catch 子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。 作者：山边小溪 出处：http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 游戏——Ping-Pong]]></title>
    <url>%2F2017%2F08%2F31%2F%E7%94%A8JavaScript%E5%86%99%E4%B8%80%E4%B8%AAPing-Pong%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[学习了一段时间 Web 前端后，就想写个项目练练手，后来就想到了这个 Ping-Pong 游戏，因为记得以前看有关电子游戏的纪录片时里面说到这个游戏是世界上第一款电子游戏，加上觉得项目难易度挺合适的，就撸起袖子加油干。游戏支持单人、双人玩家，所以欢迎各位无聊时拿来消消遣，搞搞基甚至撩撩妹，顺便找找 bug (逃)…… 项目效果在线游戏：PingPongGame GitHub 仓库：BarryLiu1995/PingPongGame 项目详情请查阅 README 文件，也欢迎各位 star，fork！ 项目情况本项目使用 JavaScript 在 Canvas 作画，同时使用 window.requestAnimationFrame() 方法告诉浏览器逐帧更新画面，以形成动画效果。这是这个项目的基本原理。而使用 JavaScript 更新 canvas 上的内容就是该项目的重点难点。scripts 目录下的 game.js 是单人游戏的业务逻辑代码，double-game.js 是依赖于 game.js 的双人游戏业务逻辑代码。 index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;link rel="stylesheet" href="styles/index.css"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Ping-Pong&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;audio preload="true" id="collide"&gt; &lt;source src="sound/PingPong.mp3" /&gt; &lt;source src="sound/PingPong.ogg" /&gt;&lt;/audio&gt;&lt;script src="scripts/game.js"&gt;&lt;/script&gt;&lt;script src="scripts/double-game.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; game.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477// RequestAnimationFrame(): a browser API for getting smooth animationsrequestAnimFrame = (function () &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) &#123; return window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();cancelRequestAnimFrame = (function () &#123; return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout&#125;)();// Initialize canvas and required variablesvar canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d"), // Create canvas context W = window.innerWidth, // Window's width H = window.innerHeight, // Window's height particles = [], // Array containing particles ball = &#123;&#125;, // Ball object paddles = [2], // Array containing two paddles mouse = &#123;&#125;, // Mouse object to store it's current position points = 0, // variable to store points particlesCount = 20, // Number of sparks when ball strikes the paddle flag = 0, // Flag variable which is changed on collision particlePos = &#123;&#125;, // Object to contain the position of collision multiplier = 0, // variable to control the direction of sparks startBtn = &#123;&#125;, // Start button object restartBtn = &#123;&#125;, // Restart button object over = 0, // flag variable, changed when the game is over init, // variable to initialize animation paddleHit, // variable about which paddle was hit gameMode = 0; // variable about how many gamer are playing// Add mousemove and mousedown events to the canvascanvas.addEventListener("mousemove", trackPosition, true);canvas.addEventListener("mousedown", btnClick, true);// Initialise the collision soundcollision = document.getElementById("collide");// Set the canvas's height and width to full screencanvas.width = W;canvas.height = H;// Function to paint canvasfunction paintCanvas() &#123; ctx.fillStyle = "black"; ctx.fillRect(0, 0, W, H);&#125;// Function for creating paddlesfunction Paddle(pos) &#123; this.name = pos; this.vx = 16; // Height and width this.h = 8; this.w = 150; // Paddle's position this.x = W / 2 - this.w / 2; this.y = (this.name == "top") ? 0 : H - this.h;&#125;// Push two new paddles into the paddles[] arraypaddles.push(new Paddle("bottom"));paddles.push(new Paddle("top"));// Ball objectball = &#123; x: 20, y: 20, r: 9, c: "white", vx: 4, vy: 8, // Function for drawing ball on canvas draw: function () &#123; ctx.beginPath(); ctx.fillStyle = this.c; ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false); ctx.fill(); &#125;&#125;;// Start Button objectstartBtn = &#123; w: 125, h: 50, x: W / 2, y: H / 2 - 25, draw: function () &#123; ctx.strokeStyle = "white"; ctx.lineWidth = "2"; ctx.strokeRect(this.x - 150, this.y, this.w, this.h); // single player game start button ctx.strokeRect(this.x + 25, this.y, this.w, this.h); // double player game start button ctx.font = "18px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStlye = "white"; ctx.fillText("Single Player", W / 2 - 87.5, H / 2); ctx.fillText("Double Player", W / 2 + 87.5, H / 2); &#125;&#125;;// Restart Button objectrestartBtn = &#123; w: 125, h: 50, x: W / 2, y: H / 2 - 25, draw: function () &#123; ctx.strokeStyle = "white"; ctx.lineWidth = "2"; ctx.strokeRect(this.x - 150, this.y, this.w, this.h); // single player game restart button ctx.strokeRect(this.x + 25, this.y, this.w, this.h); // double player game restart button ctx.font = "18px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStlye = "white"; ctx.fillText("Single Player", W / 2 - 87.5, H / 2); ctx.fillText("Double Player", W / 2 + 87.5, H / 2); &#125;&#125;;// Draw everything on canvasfunction draw() &#123; paintCanvas(); //draw Paddles on canvas for (var i = 1; i &lt; paddles.length; i++) &#123; p = paddles[i]; ctx.fillStyle = "white"; ctx.fillRect(p.x, p.y, p.w, p.h); &#125; ball.draw(); update();&#125;// Function to update positions, score and everything.// Basically, the main game logic is defined herefunction update() &#123; // Update scores updateScore(); // Move the paddles on mouse move if (mouse.x &amp;&amp; mouse.y) &#123; for (var i = 1; i &lt; paddles.length; i++) &#123; p = paddles[i]; p.x = mouse.x - p.w / 2; &#125; &#125; // Move the ball ball.x += ball.vx; ball.y += ball.vy; // Collision with paddles p1 = paddles[1]; p2 = paddles[2]; // If the ball strikes with paddles, // invert the y-velocity vector of ball, // increment the points, play the collision sound, // save collision's position so that sparks can be // emitted from that position, set the flag variable, // and change the multiplier if (collides(ball, p1)) &#123; collideAction(ball, p1); &#125; else if (collides(ball, p2)) &#123; collideAction(ball, p2); &#125; else &#123; // Collide with walls, If the ball hits the top/bottom walls, run gameOver() function if (ball.y + ball.r &gt; H) &#123; ball.y = H - ball.r; gameOver(); &#125; else if (ball.y &lt; 0) &#123; ball.y = ball.r; gameOver(); &#125; // If ball strikes the vertical walls, invert the // x-velocity vector of ball if (ball.x + ball.r &gt;= W) &#123; ball.vx = -ball.vx; ball.x = W - ball.r; &#125; else if (ball.x - ball.r &lt; 0) &#123; ball.vx = -ball.vx; ball.x = 0 + ball.r; &#125; &#125; // If flag is set, push the particles if (flag == 1) &#123; for (var k = 0; k &lt; particlesCount; k++) &#123; particles.push(new Particles(particlePos.x, particlePos.y, multiplier)); &#125; &#125; // Emit particles/sparks emitParticles(); // reset flag flag = 0;&#125;// Function for creating particles objectfunction Particles(x, y, m) &#123; this.x = x; this.y = y; this.radius = 1.2; this.vx = -1.5 + Math.random() * 3; this.vy = m * Math.random() * 1.5;&#125;// Function for updating scorefunction updateScore() &#123; console.log("ball.vx: " + ball.vx); console.log("ball.vy: " + ball.vy); console.log("points: " + points); ctx.fillStlye = "white"; ctx.font = "16px Arial, sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "top"; ctx.fillText("Score: " + points, 20, 40);&#125;// Function for emitting particlesfunction emitParticles() &#123; for (var j = 0; j &lt; particles.length; j++) &#123; var par = particles[j]; ctx.beginPath(); ctx.fillStyle = "white"; if (par.radius &gt; 0) &#123; ctx.arc(par.x, par.y, par.radius, 0, Math.PI * 2, false); &#125; ctx.fill(); par.x += par.vx; par.y += par.vy; // Reduce radius so that the particles die after a few seconds par.radius = Math.max(par.radius - 0.05, 0.0); &#125;&#125;//Function to check collision between ball and one of//the paddlesfunction collides(b, p) &#123; if (b.x &gt;= p.x &amp;&amp; b.x &lt;= p.x + p.w) &#123; if (b.y &gt;= (p.y - ball.r) &amp;&amp; p.y &gt; 0) &#123; paddleHit = 1; return true; &#125; else if (b.y &lt;= p.h + ball.r &amp;&amp; p.y == 0) &#123; paddleHit = 2; return true; &#125; else return false; &#125;&#125;//Do this when collides == truefunction collideAction(ball, p) &#123; ball.vy = -ball.vy; if (paddleHit == 1) &#123; ball.y = p.y - ball.r; particlePos.y = ball.y + ball.r; multiplier = -1; &#125; else if (paddleHit == 2) &#123; ball.y = p.h + ball.r; particlePos.y = ball.y - ball.r; multiplier = 1; &#125; // This variable relates to the increase in the speed of the ball, // so no matter how many player have will calculate this variable points++; // When there are two players, // will be based on the game to calculate their respective scores if (gameMode === 2) &#123; if (paddleHit === 1) &#123; bottomScore++; &#125; else if (paddleHit === 2) &#123; topScore++; &#125; &#125; increaseSpd(); // Collision sound will be made if (collision) &#123; if (points &gt; 0) collision.pause(); collision.currentTime = 0; collision.play(); &#125; particlePos.x = ball.x; flag = 1;&#125;// Function to increase speed after every 5 pointsfunction increaseSpd() &#123; if ((points + 1) % 5 == 0) &#123; if (Math.abs(ball.vx) &lt; 15) &#123; ball.vx += (ball.vx &lt; 0) ? -1 : 1; ball.vy += (ball.vy &lt; 0) ? -2 : 2; &#125; &#125;&#125;// Track the position of mouse cursorfunction trackPosition(e) &#123; mouse.x = e.pageX; mouse.y = e.pageY;&#125;// Function to run when the game oversfunction gameOver() &#123; ctx.fillStlye = "white"; ctx.font = "20px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; // According to the number of different players show the current score if (gameMode === 1) &#123; ctx.fillText("Game Over - You scored " + points + " points!", W / 2, H / 2 + 50); &#125; else if (gameMode === 2) &#123; if (topScore &gt; bottomScore) &#123; ctx.fillText("Player 1 Win!!! - You scored " + topScore + " points!", W / 2, H / 2 + 50); &#125; else if (topScore &lt; bottomScore) &#123; ctx.fillText("Player 2 Win!!! - You scored " + bottomScore + " points!", W / 2, H / 2 + 50); &#125; else &#123; ctx.fillText("Both are Winner!!! - You scored " + topScore + " points!", W / 2, H / 2 + 50); &#125; &#125; ctx.fillStlye = "white"; ctx.font = "35px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("Restart", W / 2, H / 2 - 100); // Stop the Animation cancelRequestAnimFrame(init); // Set the over flag over = 1; // Show the restart button restartBtn.draw(); reset();&#125;// Function for running the whole animationfunction animloop() &#123; init = requestAnimFrame(animloop); if (gameMode === 1) &#123; draw(); &#125; else if (gameMode === 2) &#123; paint(); &#125;&#125;// On button click (Restart and start)function btnClick(e) &#123; // Variables for storing mouse position on click var mx = e.pageX, my = e.pageY; // Click Single Player start button if (mx &gt;= startBtn.x - 150 &amp;&amp; mx &lt;= startBtn.x - 25 &amp;&amp; my &gt;= startBtn.y &amp;&amp; my &lt;= startBtn.y + startBtn.h) &#123; gameMode = 1; animloop(); &#125; // Click Double Player start button if (mx &gt;= startBtn.x + 25 &amp;&amp; mx &lt;= startBtn.x + 150 &amp;&amp; my &gt;= startBtn.y &amp;&amp; my &lt;= startBtn.y + startBtn.h) &#123; gameMode = 2; animloop(); &#125; // If the game is over, and the restart button is clicked if (over == 1) &#123; // Click Single Player restart button if (mx &gt;= restartBtn.x - 150 &amp;&amp; mx &lt;= restartBtn.x - 25 &amp;&amp; my &gt;= restartBtn.y &amp;&amp; my &lt;= restartBtn.y + restartBtn.h) &#123; gameMode = 1; animloop(); &#125; // Click Double Player restart button if (mx &gt;= restartBtn.x + 25 &amp;&amp; mx &lt;= restartBtn.x + 150 &amp;&amp; my &gt;= restartBtn.y &amp;&amp; my &lt;= restartBtn.y + restartBtn.h) &#123; gameMode = 2; animloop(); &#125; &#125;&#125;// Show the start screenstartScreen();// Function to execute at startupfunction startScreen() &#123; draw(); startBtn.draw();&#125;// Reset the variable when the game is overfunction reset() &#123; ball.x = 20; ball.y = 20; points = 0; over = 0; ball.vx = 4; ball.vy = 8; topScore = 0; bottomScore = 0; topLeft = false; topRight = false; bottomLeft = false; bottomRight = false; paddles[1].x = W / 2 - paddles[1].w / 2; paddles[2].x = W / 2 - paddles[2].w / 2;&#125; 此处主要内容就是根据一定逻辑更新球的运动轨迹，根据事件处理更新挡板的位置，还有碰撞发生后的一系列处理逻辑。大家可以根据注释阅读理解此处代码 double-game.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var topScore = 0, // variable to record Player1's score bottomScore = 0, // variable to record Player2's score keyNum, // variable to get keyCode topLeft = false, // variable to record whether the corresponding button is pressed topRight = false, // variable to record whether the corresponding button is pressed bottomLeft = false, // variable to record whether the corresponding button is pressed bottomRight = false; // variable to record whether the corresponding button is pressed// Set the variable when the corresponding button is pressedwindow.document.onkeydown = function (ev) &#123; var event = ev || window.event; keyNum = event.keyCode; if (keyNum === 65) &#123; topLeft = true; &#125; else if (keyNum === 68) &#123; topRight = true; &#125; else if (keyNum === 37) &#123; bottomLeft = true; &#125; else if (keyNum === 39) &#123; bottomRight = true; &#125;&#125;;// Set the variable when the corresponding button to bounce upwindow.document.onkeyup = function (ev) &#123; var event = ev || window.event; keyNum = event.keyCode; if (keyNum === 65) &#123; topLeft = false; &#125; else if (keyNum === 68) &#123; topRight = false; &#125; else if (keyNum === 37) &#123; bottomLeft = false; &#125; else if (keyNum === 39) &#123; bottomRight = false; &#125;&#125;;function paint() &#123; paintCanvas(); // Draw the top paddle ctx.fillStyle = "#ff4949"; ctx.fillRect(paddles[2].x, paddles[2].y, paddles[2].w, paddles[2].h); // Draw the bottom paddle ctx.fillStyle = "white"; ctx.fillRect(paddles[1].x, paddles[1].y, paddles[1].w, paddles[1].h); ball.draw(); Update();&#125;function Update() &#123; // Update the score updateGrade(); // Use the relevant variables to record whether // or not the two keys on the keyboard are pressed if (topLeft) &#123; if (paddles[2].x &gt;= -16) &#123; paddles[2].x -= paddles[2].vx; &#125; &#125; if (topRight) &#123; if (paddles[2].x &lt;= W - paddles[2].w + 16) &#123; paddles[2].x += paddles[2].vx; &#125; &#125; if (bottomLeft) &#123; if (paddles[1].x &gt;= -16) &#123; paddles[1].x -= paddles[1].vx; &#125; &#125; if (bottomRight) &#123; if (paddles[1].x &lt;= W - paddles[1].w + 16) &#123; paddles[1].x += paddles[1].vx; &#125; &#125; ball.x += ball.vx; ball.y += ball.vy; // Collision with paddles pa1 = paddles[1]; pa2 = paddles[2]; if (collides(ball, pa1)) &#123; collideAction(ball, pa1); &#125; else if (collides(ball, pa2)) &#123; collideAction(ball, pa2); &#125; else &#123; // Collide with walls, If the ball hits the top/bottom walls, run gameOver() function if (ball.y + ball.r &gt; H) &#123; ball.y = H - ball.r; gameOver(); &#125; else if (ball.y &lt; 0) &#123; ball.y = ball.r; gameOver(); &#125; // If ball strikes the vertical walls, invert the // x-velocity vector of ball if (ball.x + ball.r &gt;= W) &#123; ball.vx = -ball.vx; ball.x = W - ball.r; &#125; else if (ball.x - ball.r &lt; 0) &#123; ball.vx = -ball.vx; ball.x = 0 + ball.r; &#125; &#125; if (flag == 1) &#123; for (var k = 0; k &lt; particlesCount; k++) &#123; particles.push(new Particles(particlePos.x, particlePos.y, multiplier)); &#125; &#125; emitParticles(); flag = 0;&#125;function updateGrade() &#123; ctx.fillStyle = "#ff4949"; ctx.font = "16px Arial, sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "top"; ctx.fillText("Player1 Score: " + topScore, 20, 40); ctx.fillStyle = "white"; ctx.textBaseline = "bottom"; ctx.fillText("Player2 Score: " + bottomScore, 20, H - 40);&#125; 依赖于 game.js 的双人游戏业务逻辑代码，阅读完 game.js 后便可易于理解此处代码 index.css12345* &#123; padding: 0; margin: 0; overflow: hidden;&#125; 参考 Canvas Web API 接口|MDN window.requestAnimationFrame|MDN CSS3动画那么强，requestAnimationFrame还有毛线用？ 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 GitHub Pages 在线加载静态网页]]></title>
    <url>%2F2017%2F08%2F28%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub-Pages%E5%9C%A8%E7%BA%BF%E5%8A%A0%E8%BD%BD%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[相信很多前端新手在开发完一个项目后，迫不急待的希望能够把自己的项目部署到网络中。GitHub 这一神奇的网站就为我们提供了这一便利，它可以解析静态网页，免去自己购买云主机+域名的麻烦，而且操作也很简便 疑问很多童鞋在把自己的前端项目上传到 GitHub 仓库中后，希望点击 HTML 文件时能让浏览器解析出来，但现实却是点进去之后你看到的是文件的源码。所以很多新手就考虑着要不要买个云主机+域名来部署到互联网上，其实这是完全没有必要的，因为在 GitHub 这个神奇的地方还有很多你不知道的秘密（装逼脸）。 解决办法第一步：将项目上传到 GitHub 仓库 第二步：找到项目 Settings，点击进去 第三步：找到 GitHub Pages 一栏，切换 Source 的选项为 master branch 并点击 Save 第四步：保存后出现了链接，点击后复制浏览器地址栏的地址即为项目网页的地址 第五步：可以将链接放到 README 文件中供仓库的访问者预览效果 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的原型及原型链]]></title>
    <url>%2F2017%2F08%2F04%2F%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 一文中我们提到了在没有类概念的 JavaScript 语言中是通过原型来实现面向对象的继承特性。只要运用得好，这种基于原型的 JavaScript 继承模型比传统的类继承还要强大。所以我们还需详细学习一下原型的知识 JavaScript 的对象JavaScript 是基于对象的面向对象语言。因此在这里的“对象”既可以是普通对象（Object），也可以是函数对象（Function）。JS 抛弃了 Java 的类概念，而 Java 的继承恰恰是通过类来实现的。那么 JS 没有类的概念，就使用了“原型”的概念来实现继承。 字面量原型及原型链JS 可通过字面量构造对象。为了实现继承，对象里面有个_proto_属性可以指向该对象的父对象。这个父对象就是所谓的“原型”。 123456789101112131415161718192021var animal = &#123; name: '动物', eat: function()&#123; console.log(this.name + " is eating"); &#125;&#125;;animal.eat(); // animal is eatingvar dog = &#123; name: '狗', _proto_: animal&#125;;var cat = &#123; name: '猫', _proto_: animal&#125;;dog.eat(); // 狗 is eatingcat.eat(); // 猫 is eating 由上面代码我们可以看出：dog 和 cat 对象的原型都是 animal。但是 dog 和 cat 对象都没有定义 eat()方法，那怎么可以调用呢？其实当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。这几个对象通过_proto_属性建立一个原型链！ 构造函数原型及原型链但是为了迁就 C++、Java、C# 程序员，让 JavaScript 可以像 Java 那样 new （构造）出一个对象出来，于是这里做了一个变通，也提供了构造函数。例子如下： 1234567891011121314151617function Student(name,grade)&#123; this.name = name; this.grade = grade; this.sayHello = function()&#123; console.log('Hi,I'm ' + this.name); &#125;&#125;andy = new Student('Andy',5);lisa = new Student('Lisa',5);andy.sayHello(); //Hi,I'm Andylisa.sayHello(); //Hi,I'm Lisa //假设 andy 和 lisa 是同班同学，同时即将升入六年级andy.grade = 6;console.log(andy.grade); // 6console.log(lisa.grade); // 5 由上面的代码所示，我们可以看出这个所谓的构造函数已经很有 Java 类的感觉了。但是这里面存在两个问题：在对象里面定义方法，这样每创建一个对象都会一个sayHello()函数，这样来说显得对象臃肿，浪费资源；同时每个对象各自保有自己的属性和函数的副本，无法做到属性和方法共享。因此，这里有一个更加高效的办法就是把对象共享的属性和方法可以放到 Student.prototype 这个对象当中。如下： 123456789101112131415161718192021222324252627function Student(name)&#123; this.name = name;&#125;Student.prototype = &#123; grade: 5, sayHello: function()&#123; console.log(&quot;Hi, I&apos;m &quot;+this.name); &#125;&#125;;/*也可以写成Student.prototype.grade = 5;Student.prototype.sayHello = function()&#123; console.log(&quot;Hi, I&apos;m &quot;+this.name);&#125;;*/var andy = new Student(&quot;Andy&quot;);var lisa = new Student(&quot;Lisa&quot;);andy.sayHello(); //Hi, I&apos;m Andylisa.sayHello(); //Hi, I&apos;m LisaStudent.prototype.grade = 6;console.log(&quot;Andy&apos;s grade: &quot;+ andy.grade); // 6console.log(&quot;Lisa&apos;s grade: &quot;+ Lisa.grade); // 6 由上面的代码和示意图可看出这个所谓的构造函数 Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（ andy 或者 lisa ) ， 并且把这个对象的原型指针(_proto_)指向 Student.prototype 这个对象，这样一来就能找到sayHello()方法了。我们应该还知道上面的构造函数Student()对象（JS 中函数也是对象）会创建一个 prototype 对象（Student.prototype），而 new 出来的实例对象例如 andy 和 lisa 是没有这个 prototype 对象，但是他会有个 proto 属性（_proto_）指向这个构造函数对象的 prototype 对象，从而构成原型链。实例对象其实是通过原型对象与构造函数取得联系的。为了让 Java、C#、C++ 程序员降低学习成本，JavaScript 提供了语法糖： 1234567891011class Student &#123; constructor(name)&#123; this.name = name; &#125; sayHello()&#123; console.log("Hi, I'm "+this.name); &#125;&#125;var andy = new Student("andy"); andy.sayHello(); //Hi, I'm andy Object.create()123456var a = Object.create(null);console.log(a); //&#123;&#125;a.name = 'Zhiyu';var b = Object.create(a);console.log(b); //&#123;&#125;console.log(b.name); //Zhiyu 上面我们可以看出该方法是创建一个空对象，空对象的原型是create()参数。此时创建的空对象会有个(_proto_)属性指向方法参数，这样也可以构成一个原型链。 总结 JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 proto 的内置属性，用于指向创建它的函数对象的原型对象 prototype 原型和原型链是 JS 实现继承的一种模型 原型链是靠 proto 形成的，而不是 prototype 所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数 函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联 参考 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ Javascript 深入浅出原型 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ ​]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中的this关键字]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java 语言当中也有this关键字，而 JavaScript 语言当中的this关键字因为具有运行期绑定的特性，JS 当中的这个this关键字的含义要丰富的多。现在来看看这个this到底有啥奥秘…… 运行环境this关键字指定的对象具体是指什么，这完全取决于函数的调用方式，JavaScript 中的函数的调用有以下几种方式： 作为函数调用 作为对象方法调用 作为构造函数调用 作为函数调用12345var n = "Hello World!";function example()&#123; console.log(this.n);&#125;example(); //Hello World! 123456var n = 'Hello World!';function example()&#123; this.n=0;&#125;example();console.log(n); //0 我们通过上面的两个例子，我们可以明确知道：当函数直接调用时，该函数的this关键字指向的就是全局对象window。此时上面例子的全局变量n其实就是window.n。 作为对象方法调用12345678910111213141516function getAge()&#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;console.log(xiaoming.age());//27console.log(getAge()); //NaNvar fn = xiaoming.age;console.log(fn()); //NaN 123456789101112var name = 'Akita';var dogs = &#123; name:'Collie', showName: function()&#123; console.log(this.name); &#125;&#125;;console.log(dogs.showName()); //Collievar otherNmae = dogs.showName;console.log(otherName()); //Akita 如上面所示代码，当使用obj.xxx()的形式调用函数时，里面的this关键字指向的就是对象本身。但是我们还需要注意一点就是：在对象方法内部再次定义一个方法，该方法的this关键字又会重新指向全局对象window！如下代码所示： 12345678910111213var xiaoming = &#123; name: '小明', birth: 1990, age: function()&#123; function getAgeFromBirth()&#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;console.log(xiaoming.age()); //NaN 由于这是 JavaScript 一个巨大的设计错误。ECMA 决定在 strict 模式下（就是开头声明&#39;use strict&#39;;）让函数的this指向undefined。因此，在 strict 模式下你会得到的错误就不是 NaN，而是TypeError：Cannot read property &#39;birth&#39; of undefined。 作为构造函数调用12345function Student(name)&#123; this.name=name;&#125;var xiaoming = new Student('小明');console.log(xiaoming.name); //小明 上面这段代码中我们通过构造函数构造了一个新的对象xiaoming，那么this就会指向这个对象。 指定 this 指向虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25 此时利用apply()将getAge()的this指向了xiaoming这个对象，因此函数执行正确。 参考 方法 - 廖雪峰的官方网站 Javascript 深入浅出this 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ ​]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript王国之函数教主]]></title>
    <url>%2F2017%2F07%2F30%2FJavaScript%E7%8E%8B%E5%9B%BD%E4%B9%8B%E5%87%BD%E6%95%B0%E6%95%99%E4%B8%BB%2F</url>
    <content type="text"><![CDATA[本篇是JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？的续集 来源：码农翻身 微信公众号 作者：刘欣 原文地址：javascript王国之函数教主 前言本篇由BlindingDark撰写， 老刘修改，原文参见 http://www.jianshu.com/p/74120c8ec56a 拜函数教Java 小王子在 JavaScript 王国待了也有一段时间，这里虽然不像 Java 帝国那样规范严苛，但也因此千奇百怪，五光十色。 要说小王子最喜欢待的地方，那还是人来人往的 JSON 酒馆，不仅有上好的酒菜，还有机会认识到各式各样的人。这不，一来二去他已经和上回认识的眼镜官员成了朋友，甚至私底下还称兄道弟的。 这一天小王子又和眼镜大哥一起约来吃酒。才寒暄了几句，筷子还没动，酒馆门口就发生了一点骚动。只见来了一位看起来像是教书先生的精瘦男子，旁边还有些随从。 “…… 大哥，这人什么来头，气度不凡啊。”小王子悄声向旁边的眼镜官员问到。 “哈哈，他是拜函数教的邱大教主，最近他们教派的信众激增啊，真是风水轮流转。” “函数式？以前随父亲经商途中是听说过他们的事情，好像非常古老而且高深莫测啊，据说只有学者和虔诚的教徒才会加入他们，怎么最近也接收新人了？” “小弟果然是见多识广，不错，在很久以前的确是这样，不过为何有大批新教徒这种事情也不在我的管辖范围内啊，所以也不太清楚。但是毕竟我是本国语言规范审查官，还是与他打过一些交道。不妨我们邀请他来一起喝酒，你亲自问他。” 小王子本来听到眼镜大哥也不了解情况正有些失望，突然得知可以直接面对面打探对方的底细，顿时兴奋了起来。 “那太好了！” “这不是眼镜老弟么，别来无恙啊。” “主教兄，甚好甚好，要不这顿我请？小二！” 饭菜上桌，互相客套了几句之后，话题就开始了。 “主教兄，这是我最近认识的朋友，年纪轻轻就周游四方，他有些事情要问你。” “哦？”函数式主教把目光放了过来，“有何见教？” “久闻贵教派向来神秘，为何最近有如此多的新教徒加入呢？” “哈，这个嘛 … 现在的年轻人都不喜欢条条框框，本教向来以简洁强大著称，自然就受欢迎了。” 小王子心想，这个教主倒也是有话直说、自卖自夸，不过难道没了面向对象这种强大的武器，他还能变出怎么样的花儿来？ “那还敢请教教主大人，依你看要怎么实现 Animal, Cat, Dog 这些对象呢？”想了一会儿，小王子认为不如直接发问。 “这个嘛，本教派并无对象这种说法，不过如果你愿意，也可以构造一个对象出来，只需要……” “我们拜函数教不用对象～”，还没等着主教说完，旁边的妹子突然发话了。 “哦，小兰，你来说吧。”这位被叫做小兰的少女像是主教的助手，看起来深得主教信任。 “嘻嘻，教主大人说的太复杂了，其实实现你说的那些根本不用什么对象。” “哦？那该怎么做？”小王子顿时来了兴趣。 函数是一等公民“你想啊，搞出来这些猫啊狗啊的，不就是想让他们都可以吃东西么？干嘛要封装到一个对象中，太压抑了” 哦！Java 小王子恍然大悟，在自己的Java帝国，法律非常严格， 类和对象才是一等公民， 函数是不可能独立存在的， 你即使是想输出一个简单的hello world , 也必须写一个类，在类中写一个方法 ， 在这个方法中才能输出hello world 。 在这里函数已经翻身做主人，成为了一等公民，再也不用困在对象的牢笼中，声明后就可以直接使用。 “也就是说，猫、狗都可以直接拿来调用咯？” “是的呢～ 不止是猫、狗，连人都能作为参数调用呢， 只要一个对象有name这个属性就行啊”小兰的脸上还是一样的笑容。 长期在一个强类型的语言中生活，小王子对这种有点“变态”的灵活性还真不习惯， 他说：“在Java帝国，方法的参数都有确定的类型，如果你的方法写错了，IDE就能自动帮你检测， 减少了很多错误，现在可就没这种福利了。” “有得必有失嘛”小兰笑道 “你可以多写一点单元测试来保证正确性啊” “既然函数是一等公民， 我相信它不止这点能耐吧？“ “那是自然， 我们这里的函数还可以作为参数传递给另外一个函数呢！” 小王子突然想到父王给自己讲过，要在Java8中引入函数式编程， 可以把一个所谓的lambada 表达式传递给另外一个函数， 省去了创建类或匿名类的开销。 但是宫廷老师偷偷地告诉过自己：“那只是半吊子的函数式编程，每个lambda表达式其实还得和一个函数接口相匹配， JDK在背后做了类型的推断” （微信公众号码农翻身注： 参见文章《Java帝国之函数式编程（上）》和《Java帝国之函数式编程（下）》） “函数既然能作为参数，我猜肯定也能作为返回值吧？” 小王子觉得拜函数教的邱大教主在场， 这个天真活泼的小兰好像不敢给自己透露太多， 只好主动发问。 “你这个外乡人很聪明嘛， 估计有不少编程基础吧？” 小兰又展示了一段代码： 果然和自己的猜想一致！ 作为皇族，小王子确实非常聪明，他很快就想到了另外一个问题： 如果内部的eat函数访问了外部函数的变量会发生什么状况？ 按照我们 Java 帝国的理论， 函数在被调用的时候是以栈帧的方式被压入栈中的， 函数的局部变量也在栈帧当中， 当这个函数返回，对应的栈帧就会被清除，局部变量自然也不可用了。 现在这个eat函数还能再使用createEatFunction()函数的desc这个变量吗？ 或者在调用它的时候会使用外边的全局desc 变量？ 从而输出 “dog 正在吃东西”? 函数作为返回值看起来很美， 但细节着实让人费解啊？ 闭包看到小王子像上次一样又“卡”住发呆了， 眼镜官员笑着对主教和小兰说： 这小子肯定又在深思了。 小兰说：“这个外乡人确实不一般，思考很深入，让他的CPU再运转一会儿吧” 小王子没有找到答案，从思考中回来，看到大家都盯着自己看，有点不好意思， 把疑惑给大家说了。 “外乡人，Java 把你毒害得不浅， 我看你资质不错，不如忘掉Java 那丑陋的模型， 加入到我们拜函数教来吧。 将来你继承我的位置也未可知啊！” 邱大教主看了小兰一眼，意味深长地说。 小兰接口说：“还是先解释下你的疑惑吧， 你那段代码的输出应该是‘dog is eating’ , 而不是 ‘dog 正在吃东西’” 小王子说： “这我猜到了， 我就是不理解一个函数(createEatFunction)都执行完了, 为什么它的变量(desc)还能被 后面执行的函数(eat)来使用。” “要不说你的java毒中的很深啊， 你换个角度想想，局部变量在函数执行完以后还可以被访问， 那它肯定不能存在于你说的那个什么java栈帧中。” 小兰说。 “那它放在那里？” “在JavaScript 当中，有个作用域链(scope chain)的东西，它定义了一个函数激活执行的时候去哪儿找变量的值， 比如eat函数的作用域链是这样的：” （微信公众号码农翻身注： 此图只是示意图，并不严谨，例如没有表达出Activation object， Variable Object等概念） 小王子看着这个图，马上就明白了，这个eat函数没有定义desc 这个变量， 所以就沿着链去查找， 在createEatFunction作用域去查找，如果还找不到，就到global 作用域中查找…… 这个例子中，在createEatFunction的作用域中有定义，于是就直接使用了。 “可是 ”小王子不服气地说 “createEatFunction 已经执行完了， 难道它的desc 变量不删除吗？” “那肯定不能删除喽” 小兰说 “这里和你熟悉的java 有个重要的不同， 当你执行creatEatFunction的时候， eat函数才会被创建出来，此时eat函数就会把外部函数的作用域链记录下来（其中包含desc=’ is eating’)，以便执行时使用” “奥，这个作用域是在函数创建时刻发生关联的，而不是运行时刻” “没错， 这叫做静态作用域(static scope)，或者叫词法作用域（lexical scope）。当eat函数被激活执行，就可以在createEatFuncction中找到desc的值，而不是在全局中找到desc的值。 ” 小兰接着说，“我再给你看个例子， 你就理解这个静态作用域了” 小王子说： “这段代码的输出应该是2 啊， 还有什么可说的，哦，不对不对，应该输出1， 静态作用域！ 函数foo在创建的那一刻， 已经确定了它会和包含x=1的全局作用域关联 , 所以在运行的时候也只会从全局作用域查找，而不是从bar 函数的作用域中找x ” “看来你已经Get到了， 这个静态作用域是实现闭包的一个必需条件， 你听说过闭包吧？” 小王子说： “我听父王说过，但是不知道怎么回事….” 小王子说漏了嘴，赶紧打住。 小兰像没有听到一样，继续讲闭包：“闭包在JavaScript当中就是一个函数和以静态方式存储的父作用域的一个集合体，通过这个集合体，一个函数就可以访问外部函数的变量了。 ” “所以eat函数就可以访问外部函数的变量了！ 闭包这个名称有点古怪，不过背后的概念还是比较清晰的” 小王子赶紧说。 尾声“咳咳，小莱你够了。客人都被你吓到了。”这时，在旁边默默看着的邱大教主说话了。 经过这一番交谈，小王子震惊于函数式的独特之处，尤其是和Java帝国的不同。 不过毕竟是皇族，阅历丰富，他还是悟出了一点门道，“我大概明白了一点，由于 JavaScript 是动态类型，其实无论是函数还是对象，在这里都可以做为一个值来传递。函数式里面偏向对值直接进行处理，通过对这些值的传递和组合，就可以组装实现更高级的功能。” “不错不错，我看你这位朋友的来头可不一般啊，新加入的信徒大多都经过漫长的适应期才能理解，他却立即悟出这些道理来。”邱大教主对小王子赞赏有加，或许以他的智慧已经识破了小王子的身份。 “不不不，还是因为小兰妹妹讲的好啊。”小王子脸红的说道。 “这还不是多亏了我们的原型才能自由灵活的实现各种编程范式么。”眼镜大哥也参合了起来。 “哈哈哈，你又在自夸了。” “来，说了这么多 eat，不说了，吃菜吃菜～” 看来编程世界上还有这么多种形态，小王子下次要去哪里，又会见识到怎样的东西呢？或许也能给他的 Java 帝国带回一些新鲜的血液？ 附 登场人物名： 小兰 == lambda 邱大教主 == 阿隆佐.丘齐(Alonzo Church) Lambda演算发明人]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式之简单工厂模式]]></title>
    <url>%2F2017%2F07%2F28%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[想起之前学 Android 开发和 Java 开发的时候发现框架的出现能大大提高开发效率。如今学习 Web 前端开发的时候发现前端框架更加丰富。那研究各式各样的框架就成为了挺重要的学习部分，我一位学计算机的高中同学介绍说“框架是设计模式的一次实战应用”。所以这又扯到了设计模式，那什么是设计模式，后面我们将慢慢介绍各种各样有趣的设计模式 大话设计模式人物及背景 小菜：准码农一枚，正求职找工作 大鸟：小菜表哥，大学毕业后长期从事软件开发和管理工作，与小菜同住一起 什么是设计模式码农翻身作者刘欣曾在他的公众号推送给设计模式说句公道话说过 设计模式是什么东西？ 简单来讲就是久经考验的、在面向对象设计领域的成功经验的总结 因为自从上世纪70年代高级语言发展到面向对象阶段，这中间接近六十年的时间你可以想象有多少应用会被开发出来，这中间开发人员得积累了多少的经验教训。而设计模式就是这半个多世纪那些开发大牛对血与泪教训的经验总结。我同时认为，这些经验总结不单单只是程序开发经验的总结，而是取自于现实社会生活，但同时也能反哺现实生活的一种经验性知识。正因为是取自于现实社会生活，才有了如工厂模式、观察者模式、中介者模式、代理模式等如此生活化的命名方式。而 OO 语言的指导思想就是希望能够以现实人类求解日常问题的思维方法去求解软件开发的问题，那么开发出来的软件不仅容易被人理解，而且易于维护和修改，从而会保证软件的可靠性和可维护性，并能提高公共问题域中的软件模块和模块重用的可靠性。所以学习并学会合理使用设计模式就显得尤其重要了！好，下面开讲第一课！ 面试受挫小菜今年计算机专业大四了，学了不少软件开发的知识，对自己的技术能力也信心满满。这不，他自信地在各大招聘网站投下自己的简历，希望能谋得一份不错的开发工作。投递结果也如小菜预计的一样，各大公司、单位陆陆续续向他发送了面试通知。到了人家单位，前台小姐姐给了他一份题目，上面写着：“请用 C++、Java、C# 或 VB.NET 任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。”小菜心想：“这还不简单！”，三下五除二。不到一会儿就写完了，觉得也没错误，就交了卷。交卷时前台小姐姐面带微笑地说道“请回去等待进行下一轮面试的通知吧”。于是小菜只得耐心等待，可是半个月过去了，什么消息也没有，小菜很苦闷，便向他已经从事软件开发工作七年的表哥大鸟讨论可能的原因。大鸟问了题目和了解了小菜代码的细节以后，撇起嘴角，说道“小菜呀，你是真不明白吗？人家单位出题的意思，你完全都没明白，当然不会再联系你了。”这时小菜更加郁闷了，觉得自己代码应该能完美运行，越想越想不明白的小菜郁闷的看着大鸟。大鸟苦笑的指着他写下的代码： 12345678910111213141516171819202122class Program&#123; static void Main(string[] args)&#123; Console.Write(&quot;请输入数字A：&quot;); string A = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string B = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string C = Console.ReadLine(); string D = &quot;&quot;; if (B == &quot;+&quot;) D = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C)); if (B == &quot;-&quot;) D = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C)); if (B == &quot;*&quot;) D = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C)); if (B == &quot;/&quot;) D = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C)); Console.WriteLine(&quot;结果是：&quot; + D); &#125;&#125; 大鸟一一的揪出了代码中不如意的地方。比如命名不规范、没有对用户输入情况做判断、判断分支的写法效率不够高。“哦，说的没错，这个我以前听老师说过，可是从来没有在意过，我马上改，改完你再看看”小菜说道。 123456789101112131415161718192021222324252627282930313233343536class Program&#123; static void Main(string[] args)&#123; try&#123; Console.Write(&quot;请输入数字A：&quot;); string strNumA = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string strOperation = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string strNumB = Console.ReadLine(); string strResult = &quot;&quot;; switch (strOperation)&#123; case &quot;+&quot;: strResult = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C)); break; case &quot;-&quot;: strResult = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C)); break; case &quot;*&quot;: strResult = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C)); break; case &quot;/&quot;: if (strNumB != &quot;0&quot;)&#123; strResult = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C)); &#125;else&#123; strResult = &quot;除数不能为0&quot;; &#125; break; &#125; Console.WriteLine(&quot;结果是：&quot; + strResult); Console.ReadLine(); &#125;catch(Exception ex)&#123; Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message); &#125; &#125;&#125; 大鸟接过小菜写下的代码，摇摇头着说道“目前这代码实现计算器没有问题，但这样写出的代码是否符合出题人的意思呢？” 面向对象活字印刷，面向对象大鸟沉寂了一会，突然拍着小菜的肩膀说“你还记得我们古代四大发明之一的活字印刷术吗？”小菜菜点点头。“那你还知道活字印刷术发明之前民间常用的雕版印刷术吗？”这是小菜摇摇头。大鸟说道“雕版印刷术就是印书的时候，先用一把刷子蘸了墨，在雕好的板上刷一下，接着，用白纸覆在板上，另外拿一把干净的刷子在纸背上轻轻刷一下，把纸拿下来，这样一页书就印好了。那如果万一这时发现文章写的不对，需要改，那就只能为了一处的错误而去重新雕刻整块印刷板。而活字印刷术的出现就刚刚好解决了这个问题，只需把文章中的字体一个个分别雕刻出来，等后面印刷成页的时候进行排版就行了，如果需要更改，就只需要在排版的时候更改顺序。同时雕刻的单个字体还可以重复使用，还可以根据情况对文章增删内容。这样岂不是比之前方便多了！” 大鸟接着说道“开发程序也应该如此——可维护、可复用、可扩展。而在活字印刷术出现之前，要修改，必须重刻，要加字，必须重刻，要重新排列，必须重刻，印完一页后，此版已无任何可再利用价值。其实雕版印刷术的问题就在于所有的字都刻在同一版面上，按计算机专业的概念来理解，就是耦合度太高。而利用封装、继承、多态把程序的耦合度降低，将使程序更加灵活，容易修改，并且易于复用。” 业务的封装大鸟：“讲了那么多，你觉得之前那道题目你有什么想法吗？” 小菜：“我好像懂了一点，你刚才说的面向对象目的就是降低耦合度。刚才我写的代码的确还是有不合理的地方。比如代码逻辑中，既有计算逻辑也有控制台显示逻辑。这样就不利于代码的复用，维护，扩展。“ 大鸟：“不错，那你试试按你的刚才的想法去修改一下的你的代码” 小菜：“那我试试！” 123456789101112131415161718192021//Operation 运算类public class Operation&#123; public static double GetResult(double numberA,double numberB,string operation)&#123; double result = 0d; switch (operation)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; &#125; return result; &#125;&#125; 123456789101112131415161718//控制台显示类static void Main(string[] args)&#123; try&#123; Console.Write(&quot;请输入数字A：&quot;); string strNumA = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string strOperation = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string strNumB = Console.ReadLine(); string strResult = &quot;&quot;; strResult = Convert.ToString(Operation.GetResult(Convert.ToDouble(strNumA), Convert.ToDouble(strNumB),strOperation)); Console.WriteLine(&quot;结果是：&quot;+strResult); Console.ReadLine(); &#125;catch(Exception ex)&#123; Console.WriteLine(&quot;您的输入有错：&quot;+ex.Message); &#125;&#125; 小菜：“写好了，你看看！” 大鸟：“不错，这样就完全把业务和界面分离了。你现在在其他平台上写计算器的应用，就可以复用这个运算类了。但你现在只用了面向对象三大特性中的一个，还有两个没用呢？” 小菜：“面向对象三大特性不就是封装、继承和多态吗，这里我用到的应该是封装。我觉得一个个小小的计算器程序不至于用到继承和多态吧。” 大鸟：“你看来 too young too naive！” 继承和多态第二天。 小菜问道：“你说计算器这样的小程序还可以用到面向对象三大特性？继承和多态怎么可能用得上，我实在理解不了。我已经把业务和界面分离了，这不是很灵活了吗？” 大鸟：”那我问你，现在如果希望增加一个开根（sqrt）运算，你如何改？“ 小菜：”那只需要改 Operation 运算类就行了，在 switch 中加一个分支就行了。” 大鸟：“那万一你不小心改错了呢。这么说吧，如果公司把某个算法类交个你去做修改，结果一不小心改错了，结果还可能影响到了其他原有的代码。这样本来只是让你增加一个功能，却使得原有的运行良好的功能代码产生了变化，这个风险太大了 。你明白吗？“ 小菜：“哦，你的意思是我应该把加减乘除运算分离，修改其中一个不影响另外的几个，增加运算算法也不影响其他代码。” 大鸟：“对，如何用继承和多态，你应该有感觉了。” 小菜：“OK，我马上去写。” 1234567891011121314151617//Operation 运算类public class Operation&#123; private double _numberA = 0; private double _numberB = 0; public double NumberA&#123; get &#123;return _numberA;&#125; set &#123;_numberA = value;&#125; &#125; public double NumberB&#123; get &#123;return _numberB;&#125; set &#123;_numberB = value;&#125; &#125; public virtual double GetResult()&#123; double result = 0; return result;&#125; 加减乘除类 12345678910111213141516171819202122232425262728293031323334class Add : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA + NumberB; return result; &#125;&#125;class Sub : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA - NumberB; return result; &#125;&#125;class Multi : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA * NumberB; return result; &#125;&#125;class Div : Operation&#123; public override double GetResult()&#123; double result = 0; if (NumberB==0)&#123; throw new Exception(&quot;除数不能为0&quot;); &#125; result = NumberA / NumberB; return result; &#125;&#125; 大鸟：“写的不错，但是问题来了你如何让计算器知道我是希望用哪一个算法呢？” 小菜：“是哦，我还没考虑到。” 简单工厂模式大鸟：“你现在的问题其实就是如何根据用户去实例化运算类的问题。解决这个问题可以用’简单工厂模式‘，也就是说到底要实例化谁，将来会不会增加实例化的对象，比如上面提到的开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造运算实例的过程，这就像我们生活当中会的工厂，共同点都是生产某一样特定的东西。那么这个类就叫做工厂类！” 123456789101112131415161718192021//简单运算工厂类public class OperationFactory&#123; public static Operation createOperation(string operation)&#123; Operation oper = null; switch (operation)&#123; case &quot;+&quot;: oper = new Add(); break; case &quot;-&quot;: oper = new Sub(); break; case &quot;*&quot;: oper = new Multi(); break; case &quot;/&quot;: oper = new Div(); break; &#125; return oper; &#125;&#125; 大鸟：“看看代码，这样的话你只需要输入运算符号，工厂实例化出合适的对象，通过多态，返回父类的方式实现了计算器的结果。” 123456//实现加法运算过程Operation oper;oper = OperationFactory.createOperation(&quot;+&quot;);oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 大鸟：“现在就是比较完整的计算器程序了。复用性，可维护性，可扩展性都不错。如果某一天需要更改加法运算，我们只需要更改 Add 类。增加其他各种运算，比如取对数，正弦余弦，就只要增加相对应的运算类即可。同时还要记得去工厂做一下”备注“-在工厂类 switch 增加对应的分支。是不是很不错啊。“ 小菜：”厉害了我的哥，我服。看来我还是 too young too naive!“ 大鸟：“就你嘴能，来我们最后看看这几个类的结构图总结一下。” 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？]]></title>
    <url>%2F2017%2F07%2F25%2FJavaScript%E7%8E%8B%E5%9B%BD%E7%9A%84%E4%B8%80%E6%AC%A1%E6%97%85%E8%A1%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E7%B1%BB%E7%9A%84%E4%B8%96%E7%95%8C%E6%80%8E%E4%B9%88%E7%8E%A9%E8%BD%AC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[没有学习前端开发之前，一直以为 JavaScript 跟 Java 有亲缘关系，等了解了 JS 之后才发现原来半毛钱关系都没有。有一次我问一位我的高中同学，他专业是软件工程。我问他“Java 是面向对象语言，C 是面向过程语言，那么 JS 是什么？”。“基于对象”，他的回答让我很郁闷，那基于对象跟面向对象又有什么区别？这不，刚好码农翻身的最新推送解答了我的疑问 来源：码农翻身 微信公众号 作者：刘欣 原文地址：码农翻身-JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 前言作为Java 帝国的未来继承人，Java小王子受到了严格的教育， 不但精通Java语言、Java虚拟机、java类库和框架，还对各种官方的Java规范了如指掌。 近日他听说一个叫做Javascript的屌丝逆袭了， 成功地建立了一个独立的王国， 不但成了前端编程之王， 还不断地蚕食Java帝国的领地 ！ 按照小王子宫廷老师的说法： 想当年， 这家伙只是运行在浏览器中，完完全全是蹭了Java的热度这才发展起来， 现在竟然回过头来要欺负我们， 还有没有天理了？ 是可忍孰不可忍？ ！ (微信公众号码农翻身注：参见文章《Javascript：一个屌丝的逆袭》) 小王子可不这么认为， 存在必然是合理的，javascrip必有独特之处， 俗话说知己知彼，百战不殆，他觉得有必要去Javascript王国刺探一下，搜集一下情报， 看看这个曾经的浏览器中的面向对象语言是怎么回事， 为什么那么多码农趋之若鹜。 初步印象乔装打扮以后，小王子来到Javascript 王国，这里看起来一派生气勃勃的景象，人们随性而奔放， 不像Java帝国那么严肃而呆板， 让人感觉心情愉悦。 不过令小王子感到不可思议的是， 这里竟然没有官方提供的类库! 人们干活用的工具五花八门，让人眼花缭乱， 什么AngularJS, React , Backbone，Vue, Ember，JQuery, …… 互相之间还吵来吵去，争来争去，煞是热闹。 对比这下，Java帝国有着严密的统治，有着官方提供的庞大类库， 还有一统天下的Web框架 SSH/SSM ，再加上各种各样的Java规范， 码农们只需要拿来学习，干活就行。 没有了选择的烦恼， 但同时也减少了选择的权利， 是好还是坏？ 小王子自己也不知道。 小王子还注意到Javascript王国的人写程序几乎没人使用IDE， 找个趁手的文本编辑器就可以开工， 然后扔到浏览器中去运行测试，真是轻量级啊！ 唉， 我们Java帝国还在争论IntelliJ IDEA和Eclipse孰优孰劣, 实在是没有必要啊。 没有类怎么创建对象随着调查的深入，小王子愈发觉得吃惊， 这里竟然没有类的概念！ 一个面向对象的语言竟然没有类！ 这和小王子从出生就被灌输的概念可是背道而驰！ 没有类怎么创建对象 ？ 小时候宫廷老师经常说： 先写一个类， 然后才能从这个类new出一个对象出来 。 可是眼前却有着无数的javascript对象， 他们在不断地产生、消亡，一起辛苦地工作，支撑起庞大的、生机勃勃的帝国。 这些对象是从哪里来的？ 小王子百思不得其解， 正值正午时分， 小王子看到前面有一家JSON酒馆，决定先歇歇脚，美美地吃一顿再说。 小王子要了二斤熟牛肉，三碗酒，正要开始享用， 只听到旁边桌子的一个穿着长袍的人问道：哎，你说的那个对象的原型是什么？ 另一位戴眼镜的则低声说：嘘，噤声，国王刚颁布命令，原型法是我们帝国的秘密，禁止公开讨论，以防被Java帝国给学了去。 小王子心中一动， 马上把小二叫来，要来上等酒菜， 送到邻桌，请两位吃酒。 一番酒喝下来， 小王子终于获得了两人的初步信任， 原来他们还是负责审查javscript语言规范的官员。 小王子问道： “我家世代经商， 走南闯北，去过C++王国，Java帝国， C#帝国， 他们都是号称面向对象的语言， 都有class 和 object的区分， 可是到了咱们javascript王国， 我怎么连一个class 都没有看到啊？ ” 戴眼镜的官员说： “我们不用class， 那玩意儿太不直观了 ！” 小王子暗暗称奇， 可是仔细一想， 好像就是这样啊， 想当初我学习Java的时候， 费了好大的劲才接受了class这个概念，实际上面向对象的系统，不就是对象之间的交互吗？ 要类干什么？ 然后小王子问了一个关键问题： “没有class, 怎么创建对象啊” “外乡人， 没那么复杂，你想想什么是对象啊，不就是属性加上方法吗？ 你看看我们这就创建一个对象出来 ” 这位官员说着，手指头沾着酒水在桌子上写了起来： 看到没有，这个animal对象定义了一个属性name, 和一个方法 eat , 简单吧？” 的确是简单又明了，完全不需要class， 一个对象就创建了，小王子面前似乎打开了一扇新的大门。 “由于对象并不和类关联， 我们可以随意地给这个对象增加属性：” 眼镜官员补充到。 “还能这么玩？！” 小王子被惊到了，没有类的约束，这些对象也太自由了吧。 没有类怎么继承“那继承怎么实现， 继承可是面向对象的重要概念啊” 眼镜官员说： “简单啊，继承不就是让两个对象建立关联嘛！ 在我们javascript王国，每个对象都有一个特殊的属性叫做proto， 你可以用这个属性去关联另外一个对象（这个对象就是所谓的原型了） ， 来我给你画一下” 这段酒水写成的代码不长，但是却深深地震撼了小王子， 因为其中信息量非常巨大，隐藏了“原型”的秘密， 小王子不由得陷入了深思： 对象dog 的原型是animal (注意：也是一个对象)， 对象cat的原型也是animal 。 无论是dog还是cat ，都没有定义eat()方法， 那怎么可以调用呢？ 当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。 这里的这几个对象肯定是通过proto建立了一个原型链！ 嗯， 我师父给我讲JVM虚拟机的时候， 也提到了一个对象在执行方法的时候，需要查找方法的定义，这个查找的次序也是先从本对象所属的类开始， 然后父类， 然后父类的父类…… 直到Object, 思路是一模一样的！ 只不过Java 的方法定义是在class中， 而这个javascript 的方法就在对象里边， 现在我觉得似乎在对象里更加直观一点啊。 属性和方法应该类似，也是沿着原型链向上查找， 不过这里dog的name属性似乎覆盖了animal的name属性， 还有那个this, 在调用dog.eat()的时候，应该是指向dog这个对象的。 看来面向对象的理念都是想通的啊。 想着想着，小王子脸上竟然露出了笑容。 看到小王子像程序卡住一样，不动了， 穿长袍的官员推了小王子一把： 外乡人， 你怎么了？ 小王子意识到自己的失态， 赶紧说： “哦，没啥， 我觉得你们使用的这个’原型‘的办法很精妙啊， 完全不用类就实现了继承。” 眼镜官员一愣： “外乡人， 看来你悟性不错， 帝国的秘密已经被你给洞察了， 不过很多新来的程序员就不容易体会到这一点， 于是我们就做了一个变通， 让javascript可以像Java那样new 出对象出来。说来惭愧， 这完全是为了迁就那些C++,Java, C#程序员啊 ” 向Java靠拢小王子说：”什么变通办法？ 难道你们也开始使用类了吗？“ “不不， 我们提供了一个叫做构造函数的东西。还是给你写点儿代码吧 ” 官员说着，又蘸着酒水写了起来： 小王子说道： “那个function 已经有点 class的感觉了啊, 天呐我竟然看到了this这个关键字， 对了那个Student是你故意写的大写吗？ ” “是啊 ， 这样以来看起来就像Java的类了。但是，中间有个问题，你看出来了吗？ ” 小王子想了一阵：“ 是不是说每个新创建对象都有一个sayHello函数？ 在Java中函数都是定义在class 上的。 如果定义对象上， 那就意味着每个对象都有一份， 太浪费了。” “是的，所以我们得提供一种更加高效的办法， 把这个sayHello函数放到另外一个地方去！ ” “放到哪里？ ” “记得我们刚才说的原型链吗？ 当一个对象调用方法的时候，会顺着链向上找，所以我们可以创建一个原型对象，其中包含sayHello函数， 让andy, lisa这些从Student创建起来的对象指向这个原型就ok了。” “可是你这里只有构造函数Student, 在哪里创建原型对象呢？ 怎么把andy,lisa 这些对象的proto指向原型对象呢？ 不会让我手工来指定吧。” 眼镜官员瞪了一眼小王子说： “我们javascript帝国肯定不会这么麻烦程序员的， 我们可以把这个原型对象放到Student.prototype这个属性中（注意，不是proto）， 这样一来，每次当你创建andy,lisa这样的对象时， javascript 就会自动的把原型链给建立起来！” 小王子面露难色：“唉，这理解起来有点难啊。” “还是画个图吧， 当你去new Student的时候，javascript会建立这样的关系链：” 小王子说： “明白了，这个所谓的构造函数Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（andy或者lisa) ， 并且把这个对象的原型(proto)指向 Student.prototype这个对象，这样一来就能找到sayHello()方法了。” 眼镜官员回答：“没错，这个地方容易让人混淆的就是proto和prototype这两个属性， 唉，我也不知道最早为什么这么干， 实在是不优雅。” “是啊，这个构造函数再加上prototype的概念，实在是让人费解， 所以我们商量着提供一点语法糖降低程序员的负担。” 长袍官员附和到。 语法糖听到语法糖，小王子觉的很亲切， 因为 Java 中也提供了很多方便程序员的语法糖。 当长袍官员写出javascript的语法糖的时候， 小王子不由得大吃一惊： 这语法糖已经把javascript变得非常像Java, C#，C++的类了， 看来javascript帝国为了“讨好”程序员， 已经努力的在改变了， 我们java帝国看来得加油啊。 小王子现在明白了Javascript是一个基于原型实现的面向对象的语言， 根本没有类的概念， 新的方式给小王子的思维观念带来了重大的冲击。 在这里待久了，他又了解到javascript强大的函数式编程，越来越喜欢javascript, 都有点乐不思蜀了。 小王子还会回到Java帝国吗？]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列查找(哈希表)基础讲解]]></title>
    <url>%2F2017%2F07%2F21%2F%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[还记得上个月面试官问我能不能谈谈哈希表，然后我就说了”数组+链表“。然后就再也憋不出任何一句话了，因为数据结构我刚好学到二叉树，一段黑历史了。不说了，现在补上之前没有填上的坑…… 引子相信大家多多少少肯定会对查找算法有些了解，比如顺序查找、二分查找、利用“二叉搜索树”查找等等。顺序查找适用于数据量不大的时候；二分查找虽然时间复杂度较为乐观，但前提是数据元素已经按照关键字排序并且存储在连续的地址空间中；二叉搜索树查找具有相当不错的时间复杂度，但有时需要附加条件。那这样我们就需要一种适应性广而速度又快的查找算法。这就是本篇要讲的散列查找。 其实我们生活中有许多例子也是运用到了散列查找的精髓。举个栗子，我们琢磨一下查英文字典的过程，其实这个过程结合了散列查找、二分查找和顺序查找这几种查找方法。 基本概念讲解基本概念之前，我们再回到查字典这个例子。我们会根据所查单词的首字母去字典的检索表获取该单词所在位置大概在整本字典的哪一部分。然后再翻到大概页面仔细查找相对应的单词。而在散列查找的概念，上面所说的单词首字母就是散列查找中的“关键词”(key)。然后通过“散列函数”求出关键词所在的存储位置(value)。但我们也得重点说明一下查字典时我们事先“估计”关键词的“大致位置”，而散列函数“计算”的是关键词的“准确位置”。 散列查找之所以能够通过计算来快速定位要找的关键词，一个基本的前提是在存放的时候也要通过同样的“计算方法”来定位存储的位置。 从抽象的数据类型的角度看，上表实际上就是一张符号表(Symbol Table)，我们也称它为散列表或哈希表(Hash Table)。它定义为“名字-属性”对的集合。名字和属性的含义随着应用的不同而不同， 符号表的抽象数据类型描述为： 类型名称：符号表(SymbolTable) 数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合 操作集：对于一个具体的符号表 $ Table \in SymbolTable $，一个给定名字 $Name \in NameType$，属性 $Attr \in AttributeType$，以及正整数 $TableSize$，符号表的基本操作主要有 SymbolTable CreateTable(int TableSize)-创建空的符号表，其最大长度为 TableSize boolean IsIn(SymbolTable Table,NameType Name)-查找指定名字Name 是否在符号表中，若是返回true；否则返回false AttributeType Find(SymbolTable Table,NameType Name)-获取符号表Table中指定名字Name对应的属性 boolean Modify(SymbolTable Table,NameType Name,AttributeType Attr)-将Table中指定名字Name的属性修改为Attr。成功返回true；找不到Name则返回false boolean Insert(SymbolTable Table,NameType Name,AttributeType Attr)-向Table中插入一个新名字Name及其属性Attr。成功则返回true；若Name已存在则返回false boolean Delete(SymbolTable Table,NameType Name)-从Table中删除一个名字Name 及其属性。成功返回true；找不到Name则返回false 散列(Hashing)是一种重要的查找算法。它的基本思想是：以数据对象的关键词 key 为自变量，通过一个确定的函数关系 $h$ ,计算出对应的函数值 $h(key)$ ，把这个值解释为数据对象的存储地址，并按此存放，即“$存储位置=h(key)$”。 在查找某数据对象时，有函数 $h$ (也称为哈希函数)对给定值 key 计算出地址，将 key 与该地址单元中数据对象关键字进行比较，确定查找是否成功。因此散列法又称为“关键字-地址转换法”。 说到这里，读者可能会有疑问：如果有两个（或更多）关键词通过某散列函数计算出相同的存储位置，那又该怎么办？总不能把多个多个关键词对应的信息都存放在相同的位置吧？我们把这种情况叫做冲突。因此，我们还需要研究解决冲突的方法。这就引出了后面我们要讲的散列查找法的两个基本内容： 1.如何构造散列函数 2.如何解决冲突 散列函数的构造方法一个“好”的散列函数一般应考虑下列两个因素： 1.计算简单，以便提高转换速度 2.关键词对应的地址空间分布均匀，以尽量减少冲突。 关键词可分为数字型关键词和字符串型关键词这两种类型 数字关键词的散列函数构造构造这类散列函数只不过把原来的数字按某种规律转换成另一个数字 直接定址法h(key)=a \times key + b (a、b为常数)这类函数计算简单，分布均匀，不会产生冲突，但要求地址集合与关键词集合大小相同，因此对于较大的关键词集合不适用。 除留余数法假设散列表长为 TableSize（TableSize 的选取，通常由关键词集合的大小 $n$ 允许最大装填因子 $\alpha$ 决定），选择一个正整数 $p \leq TableSize$ ，散列函数为： h(key)= key \bmod p设散列表空间大小为 $m$ ，填入表中的元素个数是 $n$，则称 $\alpha = n/m$ 为散列表的装填因子。一般散列表大小设计使得 $\alpha=0.5 \sim0.8$为宜 使用除留余数法，选取合适的 $p​$ 很重要，一般选取 $p​$ 为小于或等于散列表表长 $TableSize​$ 的某个最大素数比较好。用素数求得的余数作为散列地址，比较均匀分布在整个地址空间上的可能性比较大。 大家也可能注意到如果 $p &lt; TableSize$ ，则意味着地址 $p \sim TableSize -1$ 是不能通过散列函数直接映射到的。 数字分析法如果数字关键词的位数比较多，我们可以根据实际情况将关键词中随机性比较大的位数提取出来形成一个新的关键词。例如 11 位手机号，前 3 位和中间 4 位在一定范围内很容易发生重复。所以直接选取最后 4 位作为散列地址。如果 4 位正整数太大，不适合作为地址，可以结合前面的除留余数法再做一次转换。 字符串关键词的散列函数构造简单的散列函数——ASCII 码加和法 h(key)=(\sum key[i]) \bmod TableSize函数很简单，然而均匀性也较差。但仔细研究一下你会发现关键词集合元素可能性个数大大超过存储的散列地址个数。显然冲突会是很严重的，特别是关键词集合元素个数比较大的情况下。 简单的改进——前 3 个字符移位法我们改进一下上面的散列函数 h(key)=(key[0]+key[1]\times 27+key[2]\times 27^{2})这里我们先假设字符串的每个字符只有不分大小的英文字母（26个）和空格符（1个）。函数仅考虑关键词的前 3 个字符。若忽略空格符不急，则前 3 位所有可能的不同组合为 $26^{3}=17576$ 种，似乎该数字不大。但是现实生活中英文不是随机的，真正的英文单词中前 3 位的不同组合大约不到 3000 种。这样不仅难以确定 $TableSize$ 大小而且具有相同的前 3 个字符的不同关键词一定会发生冲突。显然这个还不是很合适。 好的散列函数——移位法 h(key)=(\sum_{i=0}^{n-1}key[n-i-1]\times32^i)\bmod TableSize这个散列函数涉及关键词的所有 $n$ 个字符，并且分布得很好。每位字符占 5 位(即 $2^5=32$)。具体实现时并不需要一一做乘法运算，而是通过将每位字符转换成 二进制 ASCII 码值，通过一次左移 5 位来完成，低位补 0 ，得到的二进制结果再转换成十进制数值，这就是字符 ASCII 码值乘以一次 32 的结果。 处理冲突的方法在前面的散列函数构造过程中，我们努力使散列地址均匀分布于整个地址空间，但是实际应用中，冲突不可避免只能减少。因此我们应该研究如何解决冲突的问题。 开放定址法假如你打算在某个小区买套房子住，根据你的生辰八字(关键词)，风水先生(散列函数)告诉你 8-801 最适合你。正准备下单的时候，开发商却告诉你说该房子已被人预定（冲突发生）。此时我们可能会看看其他附近其他套房子。这就是开放定址法。 所谓开放地址法，就是一旦产生了冲突，即改地址已经存放了其他数据元素，就去寻找另一个空的散列地址。在没有装满的散列表中，空的散列地址是有的，但是怎么去找，这是我们应该考虑的因素之一 一般来说，如果关键词经过散列函数得出散列地址后发现有冲突，那么就需要试探性散列函数去试试其他附近的散列地址是否是空的。如果还发生冲突的话就再次使用试探性散列函数再去试试其他散列地址。试探性散列函数的基本公式是： p_i(key)=(h(key)+d_i)\bmod TableSize (1\leq i < TableSize)上面式子中，$i$ 表示冲突次数。根据 $d_i$ 的选取方式不同，我们可以得到不同的解决冲突方法。上面的地址必须对 $TableSize$ 取余。 线性探测法我们举个栗子，某个关键词 $key$ 经过散列函数 $h$ 获得散列地址 $h(key)$ 。但是发现该散列地址不是空的，发生了第一次冲突，此时 $d_1=1$ 。这时候我们就需要使用试探性散列函数去获取试探性散列地址 $p_1(key)$ 。如果 $p_1(key)$ 散列地址也不是空的，就发生了第二次冲突,此时 $d_2=2$ 求得 $p_2(key)$ 散列地址再去尝试。以此类推，我们可以得出 $d_i=i$ ，确定 $d_i$ 取值之后再不断用试探性散列函数去尝试新的散列地址直到没有发生冲突为止。这就是线性试探法。 线性试探法可能使第 $i$ 个散列地址的同义词存入第 $i+1$ 个散列地址，也就说本应存入第 $i$ 个散列地址的数据对象变成了第 $i+1$ 个散列地址的同义词。因为线性试探就是不断在发生冲突的地方附近一一试探，因此极容易出现很多元素在相邻的散列地址上“堆积”起来的叫做“一次聚集”的现象，这种现象会大大降低查找效率。为减轻这种一次聚集效应，可采用下面讲解的平方探测法或双散列探测法。 平方探测法按上面的流程，如果 $d_i =\pm i^{2}$ ，即 $d_i$ 的取值依次为 $1^{2}$，$-1^{2}$ ，$2^{2}$ ，$-2^{2}$ ，… ，$q^{2}$ ，$-q^{2}$ 且 $q \leq [TableSize/2]$ 去不断试探下一个存储地址的形式就是平方探测法。我们需要注意一点的就是散列表长度 $TableSize$ 是某个 $4k+3$ ($k$ 是正整数)形式的素数时能保证平方探测法可以探查到这个散列空间。这个是平凡探测法的理论基础。 双散列探测法如果公式 $p_i(key)$ 中的 $d_i=i \times h_2(key)$ ，其中 $h_2(key)$ 是另一个散列函数。我们就把它叫做双散列探测法。而第二个散列函数 $h_2(key)$ 的选取至关重要，要确保 $h_2(key)$ 都不能是 0 值，否则所有探测都是同一个位置。我们同时也需要保证所有的散列存储单元都应该能够被探测到，一般形如 h_2(key)=p-(key \bmod p)(p是小于TableSize 的素数)的 $h_2(key)$ 函数具有良好的探测效果。采用双散列探测法会增加探测过程中的计算量，但其期望的探测次数比较少，这使得它在理论上很有吸引力。不过平方探测法不需要计算第二个散列函数，从而在实践中可能更简单又实用。 再散列法开放地址法的装填因子 $\alpha$ 会严重影响查找效率，由于表长在一定时间是定值，$\alpha$ 与“填入表中的元素个数”成正比，所以 $\alpha$ 越大填入表中的元素越多，产生冲突的可能性就越大。减少冲突是提高查找速度的直接因素，因为散列表的查找过程基本上与建表过程相同。一些关键词可通过散列函数转换的地址直接找到，另一些关键词在散列函数得到的地址上产生了冲突，需要按处理冲突的方式进行查找。因此加倍扩大散列表减少冲突是一种提高查找效率的方法，此方法的过程就叫做再散列(Rehashing)。 再散列需要新建一个新的两倍大的散列表，再将原表中的数据重新计算分配到新表中。这个过程集中花费时间长，体现在交互系统的现象就是使人感觉系统有“停顿”现象。这种现象在一些实时系统中是致命的，例如医用的生命保障系统中，设备的短暂“停顿”可能导致严重后果，所以需谨慎使用。此时可以采用不需要再散列的“分离链接法”。 分离链接法分离链接法(Separate Chaining)是解决冲突的另一种方法，其做法是将所有关键词为同义词(散列地址一致的关键词)的数据对象通过结点链接存储在同一个单链表中。 最后懂得基本的数据结构与算法是程序猿的必备素养，学习数据结构与算法的方式也有多种多样。浙江大学计算机系的数据结构的网络课程是个相当不错在线课程，课程还提供了在线编程平台PTA，感兴趣的朋友可以去看看。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个故事讲完 Https]]></title>
    <url>%2F2017%2F07%2F20%2F%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps%2F</url>
    <content type="text"><![CDATA[想起上个月面试官问我了不了解 Https，当时对 HTTP 都不太熟的我只能说”No”。当我看完计算机网络教材的时候，又恰巧看见了微信公众号码农翻身的此篇推送，让我受益良多。 来源：码农翻身 微信公众号 作者：刘欣 原文地址：码农翻身-一个故事讲完https 序言今天来聊一聊https 安全传输的原理。 在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。 这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。 此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心…… 张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America …… Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样….. 两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。 总是有一种被偷看的感觉有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。 张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！” Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ” 张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！” （码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥） 一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！” Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？” 张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？ “奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？” “哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ” 张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！ 可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！ RSA：非对称加密Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。 这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。 更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。 有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ） 反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。 这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。 非对称加密+对称加密两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？” Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了” “回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走 (1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ” Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。” 于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！ 中间人攻击张大胖把和Bill 聊天的情况给老婆汇报了一次。 老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?” 张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。” 老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密， 那中间人不就可以解密看到消息了？＂ 张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！ 看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！ 你到底是谁但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？ 可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。 怎么声明呢？ 张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。 这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！ 这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！ 可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？ 张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。 天无绝人之路， 张大胖很快就找到了突破口： 数字签名。 简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。 可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？” 张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名： 这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书” 张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！ 如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。 虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。 中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？ 难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？ 如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。” 张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！ 不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。 （公众号码农翻身注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。） HTTPS终于可以介绍 HTTPS 了，前面已经介绍了 HTTPS 的原理， 你把张大胖替换成浏览器， 把 Bill 替换成某个网站就行了。 一个简化的（例如下图没有包含Pre-Master Secret）HTTPS 流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单：]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络入门]]></title>
    <url>%2F2017%2F07%2F19%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一直对人工智能感兴趣，但苦于找不到简洁易懂的入门资料。前几天拜读了阮一峰博客中的此篇博文，觉得非常不错，故转载过来，希望那些想了解神经网络的人都能有所收获 眼下最热门的技术，绝对是人工智能。 人工智能的底层模型是”神经网络“。许多复杂的应用（比如模式识别、自动控制）和高级模型（比如深度学习）都基于它。学习人工智能，一定是从它开始。 什么是神经网络呢？网上似乎缺乏通俗的解释。 前两天，我读到 Michael Nielsen 的开源教材《神经网络与深度学习》（Neural Networks and Deep Learning），意外发现里面的解释非常好懂。下面，我就按照这本书，介绍什么是神经网络。 感知器历史上，科学家一直希望模拟人的大脑，造出可以思考的机器。人为什么能够思考？科学家发现，原因在于人体的神经网络。 外部刺激通过神经末梢，转化为电信号，转导到神经细胞（又叫神经元）。 无数神经元构成神经中枢。 神经中枢综合各种信号，做出判断。 人体根据神经中枢的指令，对外部刺激做出反应。 既然思考的基础是神经元，如果能够”人造神经元”（artificial neuron），就能组成人工神经网络，模拟思考。上个世纪六十年代，提出了最早的”人造神经元”模型，叫做“感知器”（perceptron），直到今天还在用。 上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3…），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。 为了简化模型，我们约定每种输入只有两种可能：1 或 0。如果所有输入都是1，表示各种条件都成立，输出就是1；如果所有输入都是0，表示条件都不成立，输出就是0。 感知器的例子下面来看一个例子。城里正在举办一年一度的游戏动漫展览，小明拿不定主意，周末要不要去参观。 他决定考虑三个因素。 天气：周末是否晴天？ 同伴：能否找到人一起去？ 价格：门票是否可承受？ 这就构成一个感知器。上面三个因素就是外部输入，最后的决定就是感知器的输出。如果三个因素都是 Yes（使用1表示），输出就是1（去参观）；如果都是 No（使用0表示），输出就是0（不去参观）。 权重和阈值看到这里，你肯定会问：如果某些因素成立，另一些因素不成立，输出是什么？比如，周末是好天气，门票也不贵，但是小明找不到同伴，他还要不要去参观呢？ 现实中，各种因素很少具有同等重要性：某些因素是决定性因素，另一些因素是次要因素。因此，可以给这些因素指定权重（weight），代表它们不同的重要性。 天气：权重为8 同伴：权重为4 价格：权重为4 上面的权重表示，天气是决定性因素，同伴和价格都是次要因素。 如果三个因素都为1，它们乘以权重的总和就是 8 + 4 + 4 = 16。如果天气和价格因素为1，同伴因素为0，总和就变为 8 + 0 + 4 = 12。 这时，还需要指定一个阈值（threshold）。如果总和大于阈值，感知器输出1，否则输出0。假定阈值为8，那么 12 &gt; 8，小明决定去参观。阈值的高低代表了意愿的强烈，阈值越低就表示越想去，越高就越不想去。 上面的决策过程，使用数学表达如下。 上面公式中，x表示各种外部因素，w表示对应的权重。 决策模型单个的感知器构成了一个简单的决策模型，已经可以拿来用了。真实世界中，实际的决策模型则要复杂得多，是由多个感知器组成的多层网络。 上图中，底层感知器接收外部输入，做出判断以后，再发出信号，作为上层感知器的输入，直至得到最后的结果。（注意：感知器的输出依然只有一个，但是可以发送给多个目标。） 这张图里，信号都是单向的，即下层感知器的输出总是上层感知器的输入。现实中，有可能发生循环传递，即 A 传给 B，B 传给 C，C 又传给 A，这称为“递归神经网络”（recurrent neural network），本文不涉及。 矢量化为了方便后面的讨论，需要对上面的模型进行一些数学处理。 外部因素 x1、x2、x3 写成矢量 &lt;x1, x2, x3&gt;，简写为 x 权重 w1、w2、w3 也写成矢量 (w1, w2, w3)，简写为 w 定义运算 w⋅x = ∑ wx，即 w 和 x 的点运算，等于因素与权重的乘积之和 定义 b 等于负的阈值 b = -threshold 感知器模型就变成了下面这样。 神经网络的运作过程一个神经网络的搭建，需要满足三个条件。 输入和输出 权重（w）和阈值（b） 多层感知器的结构 也就是说，需要事先画出上面出现的那张图。 其中，最困难的部分就是确定权重（w）和阈值（b）。目前为止，这两个值都是主观给出的，但现实中很难估计它们的值，必需有一种方法，可以找出答案。 这种方法就是试错法。其他参数都不变，w（或b）的微小变动，记作Δw（或Δb），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组w和b，就是我们要的值。这个过程称为模型的训练。 因此，神经网络的运作过程如下。 确定输入和输出 找到一种或多种算法，可以从输入得到输出 找到一组已知答案的数据集，用来训练模型，估算w和b 一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正 可以看到，整个过程需要海量计算。所以，神经网络直到最近这几年才有实用价值，而且一般的 CPU 还不行，要使用专门为机器学习定制的 GPU 来计算。 神经网络的例子下面通过车牌自动识别的例子，来解释神经网络。 所谓”车牌自动识别”，就是高速公路的探头拍下车牌照片，计算机识别出照片里的数字。 这个例子里面，车牌照片就是输入，车牌号码就是输出，照片的清晰度可以设置权重（w）。然后，找到一种或多种图像比对算法，作为感知器。算法的得到结果是一个概率，比如75%的概率可以确定是数字1。这就需要设置一个阈值（b）（比如85%的可信度），低于这个门槛结果就无效。 一组已经识别好的车牌照片，作为训练集数据，输入模型。不断调整各种参数，直至找到正确率最高的参数组合。以后拿到新照片，就可以直接给出结果了。 输出的连续性上面的模型有一个问题没有解决，按照假设，输出只有两种结果：0和1。但是，模型要求w或b的微小变化，会引发输出的变化。如果只输出0和1，未免也太不敏感了，无法保证训练的正确性，因此必须将”输出”改造成一个连续性函数。 这就需要进行一点简单的数学改造。 首先，将感知器的计算结果wx + b记为z。 123&gt; z = wx + b&gt;&gt; 然后，计算下面的式子，将结果记为σ(z)。 123&gt; σ(z) = 1 / (1 + e^(-z))&gt;&gt; 这是因为如果z趋向正无穷z → +∞（表示感知器强烈匹配），那么σ(z) → 1；如果z趋向负无穷z → -∞（表示感知器强烈不匹配），那么σ(z) → 0。也就是说，只要使用σ(z)当作输出结果，那么输出就会变成一个连续性函数。 原来的输出曲线是下面这样。 现在变成了这样。 实际上，还可以证明Δσ满足下面的公式。 即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。 原作者：阮一峰 原文地址：神经网络入门 - 阮一峰的网络日志]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 基础扫盲]]></title>
    <url>%2F2017%2F07%2F03%2FRxJava-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2%2F</url>
    <content type="text"><![CDATA[前几天浏览了一下稀土 App，发现有个挺不错的新闻 App 实战实例。正好最近想学习一下完整项目的源码（特别是后台代码，就是各种框架等等）。然后想起以前很多大牛都谈起过 RxJava、Retrofit、Gson 等等框架，所以现在决定来学习学习这些常用的框架 RxJava 到底是什么一个词概括：异步。说到底它就是一个实现异步操作的库。那什么是异步操作，我之前在Android 消息传递机制这篇博文中讲过 Android 是单线程模型。进程启动时，也就是 App 启动后默认就只有一个线程运行，而该线程就是我们说的主线程，也叫 UI 线程。顾名思义，UI 线程就是用来更新界面显示，而如果运行当中具有耗时操作如网络请求，数据库读写，文件下载等这些耗时操作都需要在其他线程当中去完成，完成之后再更新在 UI 界面中显示出来。这就是异步加载，而 Android 中我们有现成的方式去完成这一操作，如 AsyncTask 、Handler。那为什么还要用 RxJava？ RxJava 好在哪里还是用一个词概括：简洁。异步操作很关键的一点是要注意程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和 Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 假设有这样一个需求：界面上有一个自定义的视图 ImageCollectorView ，它的作用是显示多张图片，并能使用addImage(Bitmap)方法来任意增加显示的图片。现在需要程序将一个给出的目录数组folders中每个目录下的.png图片都加载出来并显示在 ImageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种： 1234567891011121314151617181920new Thread()&#123; @Override public void run()&#123; super.run(); for(File folder:folders)&#123; File[] files = folder.listFiles(); for(File file:files)&#123; if(file.getName().endsWith(".png"))&#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable()&#123; @Override public void run()&#123; mImageCollcetorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava，就可以写成：123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File,Observable&lt;File&gt;&gt;()&#123; @Override public Observable&lt;File&gt; call(File file)&#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File,Boolean&gt;()&#123; @Override public Boolean call(File file)&#123; return file.getName().endsWith(".png"); &#125; &#125;) .map(new Func1&lt;File,Bitmap&gt;()&#123; @Override public Bitmap call(File file)&#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;()&#123; @Override public void call(Bitmap bitmap)&#123; mImageCollectorView.addImage(bitmap); &#125; &#125;); 那看到这里有人可能说了这代码敲得更多了，哪来的简洁。注意，我们这里说的简洁指的是逻辑上的简洁，不是单纯的代码量少。观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显。 RxJava 原理与使用简析原理RxJava 的异步实现是通过一种通用概念下的观察者模式来实现的。那么我们了解一下设计模式当中的观察者模式。 观察者模式面向的需求是：A 对象(观察者)对 B 对象(被观察者)的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者(例如 A 不需要每过 2ms 就检查一次 B 的状态)，而是采用注册(Register)或者称为订阅(subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过setOnClickListener()方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。它有四个基本概念：Observable(被观察者)、Observer(观察者)、subscribe(订阅)、事件。Observable 与 Observer 通过 subscribe 订阅这一动作联系在一起，从而使 Observable 可以在需要的时候发出事件来通知Observer。RxJava 的事件回调方法除了普通事件 onNext() 之外，还定义了两个特殊的事件 onCompleted() 和 onError()。这些方法具体内容如下： onCompleted()——事件队列完结。RxJava 不仅把每个事件单独处理，还会把他们看做一个队列。RxJava 规定如果队列处理完毕，需要回调此方法作为标志 onError()——事件队列异常。在事件处理过程中出现异常时，此方法会被回调，同时事件停止发出 在一个正确运行的事件序列中， onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是， onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 使用1.创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;()&#123; @Override public void onNext(String s)&#123; Log.d(TAG,"Item:"+s); &#125; @Override public void onCompleted()&#123; Log.d(TAG,"Completed!"); &#125; @Override public void onError(Throwable e)&#123; Log.d(TAG,"Error!"); &#125;&#125; 其实 RxJava 中还有一个实现了 Observer 接口的抽象类 Subscriber。这两个类基本使用方式一样，而且在subscribe()时 Observer 对象先被转换成 Subscriber 对象再使用。但他们的区别对于使用者来说主要有两点： onStart()——这是 Subscriber 增加的方法。它会在subscribe()刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， 该方法就不适用了，因为它总是在subscribe()所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用doOnSubscribe()方法。 unsubscribe()——这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如onPause()、onStop()等方法中）调用unsubscribe()来解除引用关系，以避免内存泄露的发生。 2.创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。它有三种方法来创建一个 Observable，并为它定义事件触发规则 create() 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;()&#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber)&#123; subscriber.onNext("Hello"); subscriber.onNext("Hi"); subscriber.onNext("Aloha"); subscriber.onCompleted(); &#125;&#125;); create()方法的参数 OnSubscribe 相当于一个计划表，当 Observable 被订阅时 OnSubscribe 的call()方法会被自动调用，事件序列就会依照设定依次触发(对于上面的代码，就是观察者 Subscriber 将会被调用三次onNext()和一次onCompleted())。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 just() 123456Observable observable = Observable.just("Hello","Hi","Aloha");//将会依次调用//onNext("Hello");//onNext("Hi");//onNext("Aloha");//onCompleted(); from(T[] t) 1234567String[] words = &#123;"Hello","Hi","Aloha"&#125;;Observable observable = Observable.from(words);//将会依次调用//onNext("Hello");//onNext("Hi");//onNext("Aloha");//onCompleted(); 3.subscribe()订阅创建了 Observable 和 Observer 之后，再用subscribe()方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer);//或者observable.subscribe(subscriber); 我们再来关注一下subscribe()方法的内部实现 123456public Subscription subscribe(Subscriber subscriber)&#123; ...... subscriber.onStart(); onSubscriber.call(subscriber); //事件发送逻辑开始运行 return subscriber;&#125; 4.线程控制在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler (调度器)。 在 RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate()——直接在当前线程运行，相当于不指定线程。这是默认的情况。 Schedulers.newThread()——总是启用新线程，并在新线程执行操作。 Schedulers.io()——I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和newThread()差不多，区别在于该方法的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下该方法比newThread()更有效率。不要把计算工作放在该方法中，可以避免创建不必要的线程。 Schdeulers.computation()——计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()——它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制了。 subscribeOn()指定subscribe()所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn() 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。举个例子 123456789Observable.just(1,2,3,4) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action&lt;Integer&gt;()&#123; @Override public void call(Integer number)&#123; Log.d(TAG,"number:"+number); &#125; &#125;) 上面这段代码中，由于subscribeOn(Schedulers.io())的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于observeOn(AndroidScheculers.mainThread())的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种使用方式非常常见，它适用于多数的『后台线程取数据，主线程显示』的程序策略。 总结对于 RxJava，我们应该记住两个关键字：异步、简洁。而 RxJava 还有一些比较重要的关键点需要理解，但本篇仅仅用于向初学者普及 RxJava 的一些简单原理和使用方法，更多内容大家可以查看给 Android 开发者的 RxJava 详解。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的新天地]]></title>
    <url>%2F2017%2F06%2F27%2F%E6%88%91%E7%9A%84%E6%96%B0%E5%A4%A9%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[本篇更新自简书博客 开篇尬谈 真是没想到，时间过得可真快。距离上篇博文的发布正好两个月了。关注我的网友可能会问“说好的持续更新呢”（泪目，啪啪打脸），其实说不定关注我的网友都可能忘了我这茬事（别说了，人艰不拆）。哈哈，跟大家开开玩笑先。我跟大家聊聊我自从上次更新博文之后为什么那么久没更新以及中间遇到的事吧 我干什么去了 其实自从4.27号更新以后，我们专业的课程基本都已经结课了。后面陆陆续续的当然就是各种各样的考试（其实要考试的科目也不多，总共4科）。基本五月份开始就是一星期一门期末考试。而我很自信的整个学期都没有怎么去上专业课，基本都是在图书馆捣鼓我的开发。估计这段生活经历也是我过得最大胆的一次，因为之前无论在老师还是在家长、同学、朋友面前我给大家留下的都是一个好学生的印象。接下来大家可能都能猜到：五月份就基本边自己学习开发边复习课程准备期末考试。就这样一个月就过去了，但是我这个专业对我来说还有一个大 bug ，就是六月份还得去湖北十堰进行专业实践实习半个月，这属于教学计划，很难申请不去这个实习。没办法我就把这次实习看成一次旅行，因为我已经对本专业没有任何感觉了，就很陌生。六月中旬就回到广州了，这也是我本人第一次出省，顺便说一下本人真的很喜欢北方的那种人文氛围，除了一开始去到那里对吃辣，澡堂，厕所这几样东西不习惯之外（其实后面也习惯了），真的感觉是我好像就像那里的本地人一样。对周围的一切事物感觉很舒服，很适应。 回到广州之后基本上这个学期也就结束了。之后我就开始尝试寻找 Android 开发工程师的实习。那几天就不断的在各大招聘 App 上投简历，想着广撒网，看能不能钓上大鱼。喜悦的是陆陆续续能收到一些面试通知，但经历的几次面试来说，就只有少数几个是比较正规的实习生招聘面试，其余都是培训机构（又一次泪目）。所以在这里还是要提醒一下大家现在很多培训机构都在招聘 App 上以招聘实习生的名义去找培训生。可能会有人说培训班这条路是进入 IT 行业比较常见的一种方式，特别对于非科班生来说。一开始不了解培训机构的我也是这么认为，可后面去仔细了解过后深思熟虑，觉得培训班这条路子并不适合我个人。因为很有可能在培训班学到的知识还不如我自己学习来的更有效果（在学习上我从小到大就是一个很有自主性的人，对学习有自己的规划）。况且培训班的学习目的很强，不利于以后的职业的多方向发展。但是培训班那种学习的氛围也是很让人羡慕。综合来看，最起码现在来说走培训班这条路并不是我现在最明智的选择。而在仅有的几次正规实习生招聘面试中我也收获到了一些面试经验以及自我肯定，面试中两位技术面试官先后考验我开发技术的问题。第一位面试官问的都是 Android 开发的知识，比较基础，没有问到很偏的问题。第二位面试官就问的都是专业基础知识，比如操作系统，数据结构，排序算法等等。其实两位面试官问的问题我都有接触过，但因为有些知识点在学习之后没有去实际应用，就忘得特别快，而我刚好从湖北十堰回来没有好好准备面试。所以总体面试表现一般。这也是我现在自学 Android 开发最大的问题——没有在实际项目中去应用自己学到的知识。那这里肯定有人会说那就去找项目做啊？其实我自己也有一些想做的项目，但是每次一做项目就会有各种各样的问题难以用谷歌或百度搜索解决问题，即使找到解决办法又还得自己去验证技术的准确性，导致整个项目进度拖得太慢，后面因为没有阶段性结果就难以坚持下去。这时候就好希望能有人给我一个方向性的指导。这也是我为什么想找实习的原因：一是希望在实际项目中加深对知识的理解；二是希望能认识一些技术大牛对自己指导一下，提高开发效率。面试官最后对我的评价就是专业基础一般。仅仅这个评价对我来说就是肯定了我自己在前两个月自学专业基础课程的努力。因为毕竟在两三个月前自己还是对计算机网络以及算法，数据结构知识略知一二。当然这个评价不足以让我获得想要的工作，所以后面还是需要继续提高水平。 记得知乎上有个程序猿这么说“如果自学不能为你带来一份工作，那么你也可能不适合这份职业”。也记得其他人说过开发这种东西是需要时间积累，就是所谓的厚积薄发。总之，我选择了自己的道路就希望能一直走下去。 个人博客预告 我现在说说我的个人博客吧。从湖北回来后我就有了想搭建独立博客的想法，因为老觉得搭建独立博客平台逼格更大（哈哈，请允许我装装13先），说不定还能提高我更新博客的主动性，以后打算博文更新在我搭建的博客上。就这样用一两天的时间待在宿舍上谷歌，百度搜索教程初步成功搭建好了个人博客。域名是阿里买的，文档托管在 GitHub pages ，框架用的是 hexo，主题用的是 material。欢迎大家来我的博客踩踩！谢谢大家。 刘志宇的新天地 因为评论系统集成的是网易云跟帖，因为主题的原因现在还存在 PC 访问网页可能无法评论博文以及评论控件时隐时现的问题。这些问题还得通过后面的更新解决 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
</search>
