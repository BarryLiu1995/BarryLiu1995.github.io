<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的2017]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%88%91%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[今天是2017年的最后一天，有些话想聊一聊，也就算个人的年度总结吧 2017的那些选择关注过我博客的各位童鞋应该都知道，我本不是计算机相关专业的学生。因为喜欢，就完完全全抛弃了自己的专业，在图书馆花了一整年的时间学习软件开发。先是学习了半年多时间的Android开发，因为一开始的目标就是想弄个有趣的 app 出来，结果因为六七月份找实习的时候发现情况不太好，就尝试了往前端开发方向发展了。最终在10月份的时候成功找到一份实习，接着在11月底找到一份待遇还算不错的正式工作。一开始决定往软件开发方向发展时，自己都不知道结果会是怎么样，而且当时已经是大三了，没有那么多时间给自己学习，所以一开始的时候还是很忐忑，家里人一开始也不是很支持我往开发方向发展。然而到今年底，也可以说是上帝眷顾自己的努力吧，算比较幸运的找到了一份待遇、工作氛围、工作内容都挺满意的工作，最高兴的还算是父母终于肯定了自己的付出。自己一年来的努力算是没有辜负当初自己做出这个选择时下定的决心，没有忘记当初是为了什么才做出这个决定。 2017年的那些人话说，今年一整年都在忙着学习开发，等到了今天回过头来看。发现自己还有半年就算是结束了自己16年的学生生涯。想想一下子不去教室上课了，还真的是很伤感。因为今年平时都忙着学习开发，自己的专业课基本都逃了，已经忘记了上课是一种什么感觉了，然而今年一过，后面就再也不用去上课了。所以好多东西，都是过去了才懂得珍惜。这也让我想起了高考完几天后，在家里收拾着高三一整年的资料书籍，突然不知怎么的，看着这一大堆书籍、资料，觉得高考考完，好像自己的生活就没了意义，于是就好想回到课堂上跟大家一起做“三五”，好想和高三(1)班的同学一起聊天、玩耍。如今大学快毕业了，发现跟自己很好的那帮同学还是以前的高中同学，毕竟他们和你度过了青春中最美好的六个年华。所以呀，过年回家的时候就特别期待着班级聚会，想看看大家，特别是当年那个自己特别喜欢的女生变什么样了。而等到上大学之后，特别是今年去了湖北十堰，九、十月份秋招的时候跑了一些宣讲会、十月份到十二月份实习，就发现等你见过各色各样的人之后，你会觉得找到一个打心底里跟自己能敞开心扉的人其实很难，而当你跟中学时代的那一帮同学度过了最美好的时光后，你也会发现，从某种情况下你跟他们的关系已经超越了同学的层面。所以上大学后，就越发珍惜以前的超越同学的情谊，一有时间我就会找那帮同学聊聊天。而大学同学，大多数人都只是从你生活“路过”而已。 2017年的那些看过的电视剧、电影今年年初的时候看了两部日剧《逃避虽可耻》、《求婚大作战》和一部日影《你的名字。》。看完这些后就非常喜欢这两部电视剧和电影里带给人的那种感觉。特别是《你的名字。》，感觉日本人的生活气息是特别空灵的那种，也特别祥和。所以那时就决定以后有机会一定要去日本感受一下那种不一样的生活气息。年底的时候在同学推荐下又看了《请回答1988》，剧里面透露出来的亲情、爱情、友情真是很让人羡慕，虽然生活算不上富裕，但能够遇上如此有爱的邻居，和邻居家的孩子一起长大，最后到相爱相知，我想这就已经足够了。 2017年的科比今年还有一件重要的事就是科比球衣退役。想想前年还坐在电脑前看科比球员生涯的最后一场比赛，到球衣退役那天，发现仅仅两年多的时间，科比却感觉明显老了一些。想想当年为什么喜欢科比，或许只是因为投入关键球后他那龇牙咧嘴的狠劲。还有早年，Nike 09年的广告《只要心够绝》让我喜欢上了科比的那种竞争精神。现在他已退役了，但科比精神仍在！话说，今年双十一的时候入了科比14年的低帮球鞋，突然就找回以前打球的欲望了，这大概就是球星的力量吧。 展望2018既然现在我已是程序员的身份了，希望新的一年戒骄戒躁，脚踏实地干实事。还有提醒自己记得注意自己的身体，多多锻炼，有机会去报个班学跳舞。有机会能多带父母走走，有闲钱可以入个MBP，有机会多出去看看外面的世界…..嗯，大概就这样吧。记住，少说套话多干实事！]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript与文字编码]]></title>
    <url>%2F2017%2F12%2F28%2F%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[在学习阮一峰的 字符串的扩展|ECMAScript 6 入门 章节的时候其中有一处“JavaScript 共有 6 种方法可以表示一个字符”。然后想起之前看的一篇关于文字编码的文章，所以现在打算重新复习一下文字编码 文字编码在物理层面上，我们存入计算机的所有文件都是以二进制形式保存的。但现实生活中，我们会发现计算机中保存的文件形式各式各样，有音频文件、文本文件、视频文件、还有我们程序员熟悉的源代码文件等等。由此可以看出，不同文件的差别只是我们解读二进制的方式不同。然而即使同为一个类别的文件，解读二进制文件又会有不同。其中我们以网页开发中最常接触到的文本文件的编码方式拿来细说。这里所说的文本文件，一般是指基于字符编码的文件。计算机发展到现在为止，出现的字符编码就有 ASCII、GB2312、Unicode等等。 ASCII使用 8 个二进制位进行编码的方案，最多可以给 256 个字符（包括字母、数字、标点符号、控制字符及其他符号）分配数值。基本的 ASCII 字符集共有 128 （0~127）个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。因为这 128 个基本字符就可以用 7 位二进制表示。所以多出来的最高位设为 0 （在数据传输时可用作奇偶校验位）。剩下的 128 个拿来扩充 ASCII 字符集，为了以后方便加入新的字符。这些扩充字符的编码最高为均为 1 的二进制数字（即十进制 128~255），称为扩展 ASCII 码。由于这些基本 ASCII 字符集字符数目有限，在实际应用中往往无法满足要求。国际标准化组织（ISO）制定了新的标准，该标准是兼容了基本 ASCII 字符集，在不同国家地区有不同具体的方案。 Unicode为了解决不同国家地区间编码方案的不同引起的不便，于是就有了这样一个想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会乱码了。 Unicode 就是在这种背景下诞生了。Unicode 规定了每个字符的编号，这个编号也叫做“码点”（code point)。它从 0 开始，目前 Unicode 的最新版本一共收入了 109449 个符号，其中的中日韩文字为 74500 个。这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以放 65536 （$2^{16}$)个字符，称为一个平面（plane）。目前，一共有 17 （$2^{5}$)个平面，也就是说，整个 Unicode 字符集的大小现在是 $2^{21}$ 个。其中最前面的 65536 个字符位，称为基本平面（缩写BMP），它的码点范围是从 0 ~ $2^{16}-1$，写成十六进制就是从 U+0000 ~ U+FFFF 。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（缩写SMP），码点范围从 U+010000 ~ U+10FFFF。 Unicode 只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。 UTF-32最直观的编码方法就是，每个码点使用 4 个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。例如码点 597D U+597D = 0x0000 597D UTF-32 的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比 ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成UTF-32。 UTF-8UTF-32 太过于浪费空间，所以急需一种节省空间的表示方案，这导致了 UTF-8 的诞生。UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。 字节 编号范围 0x0000 - 0x007F 1 0x0080 - 0x07FF 2 0x0800 - 0xFFFF 3 0x010000 - 0x10FFFF 4 我们来看看 UTF-8 具体是如何存储字符的，如下面的字符 we 发 财 🤑 上面的字符对应的十进制编码如下 其中 20 是空格的编码，可以看到一个英文还是 1 个字节，一个中文用了 3 个字节，而一个 Emoj 用了 4 个字节。它怎么知道每次应该读取多少个字节呢？如下图所示： 如果一个字节是 0 开头，表示这个字节就表示一个字符，如果是 3 个 1 开头表示这个字符要占 3 个字节，有多少个 1 就表示当前字符占用了多少个字节。这个就是 UTF-8 的存储特点，UTF 规定了每个字符的编号，而 UTF-8 定义了字符应该怎么存储。从 Unicode官网 可以查到，“我”的UTF编码是6211，如下图所示： 6211 怎么变成 UTF-8 编码呢？因为 6211 落在下面这个范围： U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX 所以是这么转的： “我”的 UTF-8 就是 E6 88 91 UTF-16UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000到U+FFFF），要么是 4 个字节（U+010000到U+10FFFF）。 但是现在面临一个问题就是：当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？然而在基本平面内，从 U+D800 ~ U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段被拿来映射辅助平面的字符。当我们遇到两个字节，发现它的码点在 U+D800 ~ U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00 ~ U+DFFF之间，这四个字节必须放在一起解读。 到此，我们可以看出，UTF-8 的优点在于 1 个英文只要 1 个字节，但是 1 个中文却是 3 个字节，UTF-16 的优点在于编码长度固定，1 个中文只要 2 个字节，但是 1 个英文也要 2 个字节。所以对于英文网页 UTF-8 编码更加有利，而对于中文网页使用 UTF-16 应该更加有利。因为绝大部分的中文都是落在 U+0000 ~ U+FFFF。 Base64早期电子邮件的 SMTP（Simple Mail Transfer Protocol） 协议仅限于传送 7 位的 ASCII 码。许多其他非英语国家的文字以及多媒体资源就无法传送，所以说早期的电子邮件就只能传送英文文字。或许是早期电子邮件的诞生的时候，美国人民以为只有他们自己会传送文字以取消传统的电报业务。 于是后来就提出了通用互联网邮件扩充（MIME）。MIME 并没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。因此在这种情况下，Base64 就诞生了。 Base64 可以把原本 ASCII 码的控制字符甚至 ASCII 码之外的字符都转成可打印的 6 bit 字符，也就是说用 6 bit 字符表达了原本 8 bit 字符。我们看看下面的图片： 像表格中那样，8 Bit$\times$3 的字符串可以每 6 个 bit 分成一组，每一组 bit 对应一个十进制的 index，每一个 index 值又对应了 Base64 的字符。由于 6 bit 的二进制代码共有 64 种不同的值，从 0 到 63。用 A 表示 0 ，用 B 表示 1 ，等等。26 个大写字母排列完毕后，接下去再排 26 个小写字母，再后面是 10 个数字，最后用“+”表示 62，而用“/”表示 63。再用两个连在一起的等号 “==” 和一个等号 “=” 分别表示最后一组的代码只有 8 bit 或 16 bit。 JavaScript 与编码JavaScript使用哪种编码JavaScript 语言采用 Unicode 字符集，但是它编码使用的既不是 UTF-16，也不是UTF-8，更不是 UTF-32，而是 UCS-2。他们之间是什么关系呢？我们讲讲一些历史。 互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。 UCS 的开发进度快于 Unicode，1990 年就公布了第一套编码方法 UCS-2，使用 2 个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以 2 个字节就够用了。）UTF-16 编码迟至 1996 年 7 月才公布，明确宣布是 UCS-2 的超集，即基本平面字符沿用 UCS-2 编码，辅助平面字符定义了 4 个字节的表示方法。 两者的关系简单说，就是 UTF-16 取代了 UCS-2 ，或者说 UCS-2 整合进了 UTF-16。所以，现在只有 UTF-16，没有 UCS-2。 ###JavaScript为什么不使用 UTF-16 那么，为什么 JavaScript 不选择更高级的 UTF-16，而用了已经被淘汰的 UCS-2 呢？答案很简单：非不想也，是不能也。因为在 JavaScript 语言出现的时候，还没有 UTF-16 编码。 JavaScript 字符函数的局限由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。所以当遍历字符串的时，必须对码点做一个判断，然后手动调整。 String.prototype.replace() String.prototype.substring() String.prototype.slice() … 上面的字符函数都只对 2 字节的码点有效。要正确处理 4 字节的码点要手动处理。 ES6JavaScript 的下一个版本 ECMAScript 6（ES6），大幅增强了 Unicode 支持，基本上解决了上面的问题。新增了以下特点： ES6能够自动识别 4 字节的码点 允许直接用码点表示 Unicode 字符 新增了几个专门处理 4 字节码点的函数 对正则表达式添加了 4 字节码点的支持 Unicode 正规化 参考 字符编码|百度百科 文字编码的那些事|掘金 Unicode 与 JavaScript 详解|阮一峰的网络日志 《计算机网络》谢希仁著（第七版） 漫画：什么是 Base64 算法|算法爱好者]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习日记(四)]]></title>
    <url>%2F2017%2F11%2F24%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[本文章将记录后面几个月的学习笔记 2017.11.23节流与防抖他们的出现主要是为了解决一些短时间内连续执行的事件带来性能上的不佳和内存的消耗巨大等问题。 节流——在一定时间内触发一次 防抖——在一定时间之后才触发指定函数 用途 当我们做 keyup 向后台请求检验的时候，可以使用防抖函数，不然我们每按一次键盘就请求一次，请求太频繁，这样当我们结束按键盘的时候再去请求，请求少很多了，性能自然不用说 resize 窗口大小调整的时候，我们可以采用防抖技术也可以使用节流 mousemove 鼠标移动事件我们既可以采用防抖也可以使用节流 scroll 滚动条触发的事件，当然既可以采用防抖也可以采用节流 连续高频发的事件都可以采用这两种方式去解决，优化页面性能 2017.11.25Three.js 中关于Mesh、Geometry、Material的关系1var mesh = new THREE.Mesh(new THREE.Geometry(), new THREE.Material()); 使用几何形状（Geometry）和材质（Material）之后，我们就能使用他们来创建物体了。最常用的一种物体就是网格（Mesh），网格是由顶点、边、面等组成的物体；其他物体包括线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等。创建物体需要指定几何形状和材质，其中，几何形状（Geometry）决定了物体的顶点位置等信息，材质（Materia 决定了物体的颜色、纹理等信息。 DOM——Document类型JavaScript 通过 Document 类型表示文档，这里文档指的可以是 HTML 页面或者其他基于 XML 的文档。不过最常见的应用还是作为 HTMLDocument （继承自 Document 类型）实例的document对象。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。其子节点可能是一个 DocumentType（&lt;!DOCTYPE&gt;标签，且最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。 12345&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 123456var html = document.documentElement;alert(html===document.childNodes[0]); //truealert(html===document.firstChild); //truevar body = document.body;alert(body === html.firstChild); //true 2017.11.28计算机文件 一般来说，计算机文件可以分为两类：文本文件和二进制文件。 图形文件及文字处理程序等计算机程序都属于二进制文件。这些文件含有特殊的格式及计算机代码。ASCII 则是可以用任何文字处理程序阅读的简单文本文件。 广义的二进制文件即指文件，由文件在外部设备的存放形式为二进制而得名。狭义的二进制文件即除文本文件以外的文件。文本文件是一种由很多行字符构成的计算机文件。文本文件存在于计算机系统中，通常在文本文件最后一行放置文件结束标志。文本文件的编码基于字符定长，译码相对要容易一些；二进制文件编码是变长的，灵活利用率要高，而译码要难一些，不同的二进制文件译码方式是不同的。 计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值（可以看作是自定义编码）。从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)，基于字符，每个字符在具体编码中是固定的，ASCII码是8个比特的编码，UNICODE一般占16个比特。而二进制文件可看成是变长编码的，因为是值编码，多少个比特代表一个值，完全由自己决定。 ASCII 是计算机最早的文字编码方案，所以对他的支持是全球范围内的，所以使用全球任何一款文字处理程序都可以打开此 ASCII 文件，所以把它称为纯文本文件。而一些特殊的比如 GBK、BIG5、GB18030文字编码方案都不是全球范围内都支持使用的，比如在国内出售的计算机预装的Window操作系统内置的字符编码方式就肯定不会有GB18030这种日文文字编码方案 文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点。一般认为，文本文件编码基于字符定长，译码容易；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。在windows下，文本文件不一定是ASCII来存贮的，因为ASCII码只能表示128的标识，打开一个txt文档，然后另存为，有个选项是编码，可以选择存贮格式，一般来说UTF-8编码格式兼容性要好一些。 2017.11.30HTML5 Geolocation用HTML5 Geolocation API(地理位置应用程序接口)获得的经纬度参数，传入到腾讯地图，并显示出来后，会发现会有一定的偏移，这是因为我国把美国卫星的GPS的地球坐标，进行偏移的算法，计算后，得出了一个火星坐标。为了让火星坐标能正确的显示，又给每部导航软件加入了这个算法，可以在大家的地图上还原位置；而自己写的程序里没有加入此算法，所以出现了偏移问题，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。 2017.12.6URI与URL的区别统一资源标志符 URI 就是在某一规则下能把一个资源独一无二地标识出来。拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是 URI 的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是 URI ，通过身份证号能让我们能且仅能确定一个人。那统一资源定位符 URL 是什么呢。也拿人做例子然后跟 HTTP 的 URL 做类比，就可以有： 动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人 可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL 是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用下面编码来标识他 身份证号：123456789 所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是 URl 的一种实现，而 URL 就是用定位的方式实现的 URI 。 2017.12.8CGI(Common Gateway Interface)What is CGI? CGI stands for Common Gateway Interface. This is not to be confused with the other CGI, which stands for Computer Generated Imagery, which is the technology that they use for special effects and explosions and things in major motion pictures. This is CGI, the Common Gateway Interface. This is the technology that allows web browsers to submit forms and interact with programs on a web server. So, when you see a web form like this one here, and you fill it in and you press the button and it goes, what happens from this point is CGI. The web browser submits the data to the server. The server passes that data on to an application. The application responds and it goes back up the chain, back to your web browser, and your web browser gets some kind of result and maybe something happens on the backend, like a database thing or sending an email or something like that. CGI is used for simple interactive applications. More complicated applications like Google Maps or Gmail or something like that, use another technology called Ajax, which sometimes actually uses CGI on the backend to communicate with the applications on the server. But CGI is used for simple interactive applications. CGI applications can be written in any programming language. The most common ones are languages like Perl and PHP and Python and things like that that tend to be simple languages. Because CGI applications tend to be simple applications. For this reason, CGI applications are often called CGI scripts, because the languages that they tend to be written in, tend to be what are called scripting languages. They tend to be very simple languages. And for this reason, they’re often called CGI scripts. Of course, they can be written in any language. Sometimes more complex languages like ASP or Java or even C++ can be used, but it’s important to note that CGI applications run in the server. They do not run in the web browser. So, the technology that’s used by the CGI application must be supported by the web server. And the requirements of running applications on the server and the security restrictions and things like that must all be followed according to the rules of the server and not according to the rules of your local computer or your application. And this is because CGI applications run in the server and not in the web browser. So, we’ll cover more of the details as we move along in this course, but in a nutshell, that’s what CGI is. 2017.12.10插入标记IE标准的innerHTML、outerHTML、innerText、outerText这四个插入标记，其中前两个已经被列为了HTML5的标准，而后面两个却没有得到这样的待遇。同时还有一个这样的问题需要注意到：设置这四个属性的时候，得到的结果却不是设置时所敲下的字符文本，原因在于结果返回的字符串是根据原始HTML字符串创建的DOM树经过序列化之后的结果。 2017.12.17页面大小、视口大小和浏览器窗口大小 IE9+、Safari、Firefox中，outerWidth和outerHeight表示浏览器窗口本身的大小。而在Opera中，这两个属性表示的是Opera中单个标签页对应的浏览器窗口 innerWidth和innerHeight在除了Chrome浏览器之外的浏览器中都表示该容器中页面视图区的大小（减去边框宽度） Chrome浏览器中，innerWidth、innerHeight、outerWidth、outerHeight都表示视图区大小 IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过它通过 DOM 提供了页面视图区域的相关信息：在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientXXX保存了页面视图区的大小。在IE6 中这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientXXX取得相同信息 2017.12.26ShellShell 中文翻译为“壳层”。在计算机科学中，Shell 指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中，提供访问内核所提供的服务的程序。Shell 也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的接口。因此与之相对的是程序内核(Core)，内核不提供和用户的交互功能。通常将 Shell 分为两类：命令行与图形界面。命令行壳层提供一个命令行界面(CLI)；而图形壳层提供要给图形用户界面(GUI)。相关信息可参考 壳层|维基百科 Node.js 的异步I/O和事件驱动的理解 异步I/O——非阻塞的服务器我们可以想象成一个无限 loop 循环，这个 loop 会一直跑下去。一个新请求来了，这个 loop 就接了这个请求，把这个请求传给其他的进程（比如传给一个搞数据库查询的进程），然后响应一个回调（callback）。完事了这 loop 就接着跑，接其他的请求。如果请求处理完成，loop 就把结果传回用户的浏览器，接着继续跑。 事件驱动——服务器只在用户那边有事件发生的时候才响应]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
        <tag>计算机网络</tag>
        <tag>Three.js</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP和MVVM的图示]]></title>
    <url>%2F2017%2F10%2F14%2FMVC-MVP%E5%92%8CMVVM%E7%9A%84%E5%9B%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[最近学习 Vue，里面提到了 MVVM 架构，在阮老师网站上找到一篇不错的关于软件架构的说明 软件架构复杂的软件必须有清晰合理的架构，否则无法开发和维护。 MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。 昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。 MVCMVC模式的意思是，软件可以分成三个部分。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下。 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 实例：Backbone.js实际项目往往采用更灵活的方式，以 Backbone.js 为例。 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 作者：阮一峰 原文地址：MVC，MVP 和 MVVM 的图示]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈cookie]]></title>
    <url>%2F2017%2F10%2F11%2F%E8%B0%88%E8%B0%88cookie%2F</url>
    <content type="text"><![CDATA[今天被4399面试官问到了 cookie 的相关知识，之前不是很了解，现在补补… 什么是cookiecookie 译为“小甜饼，具体种类称为酥性甜饼干，这是一种中档配料的产品……”。咦，跑偏了，开个玩笑先，虽然面试过程不爽，但还是得笑对人生（生无可恋）。 我们知道HTTP是无状态的，也就说同个客户端即使多次向同个服务器发出请求，服务器也做出响应了，但他们始终都是形同陌路的“陌生人”。因此，当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，cookie 会记录如身份识别号码、密码、用户在 Web 站点购物的方式或用户访问该站点的次数等关键信息，所以 cookie 使得基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。打个比喻就像各大网站如 Google、百度、网易等给客户端颁发一个通行证，客户端需要访问网站时带上自己的通行证。这样服务器就能认出这个客户端是哪个老相好了。然而也因为 cookie 将包含但不限于上述的一些重要信息保存在用户浏览器上的小文本文件上，使 cookie 技术成为广大网民和开发人员争论的一个焦点。 cookie原理 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会把 cookie 带过去，服务端会辨别用户身份，当然服务器也可以修改 cookie 内容（后面会谈到这点）。cookie 的产生是通过扩展 HTTP 协议来实现的，服务器通过在 HTTP 响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的 cookie。然而纯粹的客户端脚本如 JavaScript 也可以生成 cookie。而 cookie 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的 cookie ，如果某个 cookie 所声明的作用范围（这个作用范围由 cookie 的 path 和 domain 同时决定）大于等于将要请求的资源所在的位置，则把该 cookie 附在请求资源的 HTTP 请求头上发送给服务器。 cookie的不可跨域名性很多网站都会使用 cookie。例如，Google 会向客户端颁发 cookie，Baidu 也会向客户端颁发cookie。那浏览器访问 Google 会不会也携带上 Baidu 颁发的 cookie 呢？或者 Google 能不能修改Baidu 颁发的 cookie 呢？ 答案是否定的。cookie具有不可跨域名性。根据 cookie 规范，浏览器访问 Google 只会携带 Google 的 cookie，而不会携带 Baidu 的 cookie。Google 也只能操作 Google 的 cookie，而不能操作 Baidu 的 cookie。 cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 cookie 而不会操作 Baidu的 cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站 cookie 的依据是域名。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 cookie。 需要注意的是，虽然网站 images.google.com与网站 www.google.com 同属于Google，但是域名不一样，二者同样不能互相操作彼此的 cookie。 注意：用户登录网站 www.google.com 之后会发现访问 images.google.com 时登录信息仍然有效，而普通的 cookie 是做不到的。这是因为 Google在后端进行了相关处理。 cookie属性cookie 的属性比较多，我们可以看下下面这张图 name这个显而易见，就是代表 cookie 的名字的意思，一个域名下绑定的 cookie ，name 不能相同，相同的 name 的值会被覆盖掉 value这个就是每个 cookie 拥有的一个属性，它表示该属性的值 domain这个是指的域名，这个代表的是，cookie 绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，还有值得注意的点，统一个域名下的二级域名也是不可以交换使用 cookie 的，比如，你设置 www.baidu.com 和 image.baidu.com ，依旧是不能公用的 pathpath这个属性默认是/，当你设置成比如/blog的时候，其实它会给 “domain+path” 范围内绑定 cookie Expires/Max-Age该属性决定 cookie 的有效期，一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除，这就是上图中的—— session (会话储存)。 如果你想要 cookie 存在一段时间，那么你可以通过设置 Expires 属性为未来的一个时间节点，Expires 这个是代表当前时间的，这个属性已经逐渐被我们下面这个主人公所取代——Max-Age。 Max-Age，是以秒为单位的，Max-Age 为正数时，cookie 会在 Max-Age 秒之后被删除。在 Max-Age 之前 cookie 是保存到硬盘上，即使关闭浏览器后再次打开，这些 cookie 仍然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。当 Max-Age 为负数时，表示的是临时储存，不会生出 cookie 文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭， cookie 就会消失，当 Max-Age 为 0 时，又会发生什么呢，删除 cookie ，因为cookie 机制本身没有设置删除 cookie ，失效的 cookie 会被浏览器自动从内存中删除，所以，它实现的就是让 cookie 失效。 secure这个属性译为安全，http 不仅是无状态的，还是不安全的协议，容易被劫持。所以当这个属性设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输。但需要强调一下这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性 HttpOnly这个属性是面试的时候常考的，如果这个属性设置为 true，就不能通过 JavaScript 脚本来获取 cookie 的值，能有效的防止xss 攻击,看 MDN 的官方文档： 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问有HttpOnly 标记的Cookie，Cookie只需要发送给服务端。如果包含服务端session信息的Cookie不想被客户端Javascript使用，那么就需要使用HttpOnly 标记 关于JavaScript操作cookiedocument.cookie 可以对 cookie 进行读写： 12console.log(document.cookie); //读取浏览器中的cookiedocument.cookie='myname=liuzhiyu;path=/;domain=.baidu.com'; // 写入 cookie 服务端如何去设置cookie 服务端就是通过 setCookie 来设置 cookie 的，注意点，要设置多个 cookie 时，得多写几个 setCookie ，我们还可以从上图看到，请求可以携带 cookie 给后端。 cookie与session本片开头已说过 HTTP 是一个不保存状态的协议。session 是服务器端使用的一种记录客户端状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 session。客户端浏览器再次访问时只需要从该 session 中查找该客户的状态就可以了。如果说 cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session对浏览器的要求虽然 session 保存在服务器中，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 session 需要使用 cookie 作为识别标志。HTTP 协议是无状态的，session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 cookie，它的值为该 session 的 id。session 依据该cookie 来识别是否为同一用户。该 cookie 为服务器自动生成的，它的 MaxAge 属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。 session中不使用cookieURL 地址重写是对客户端不支持 cookie 的解决方案。URL 地址重写的原理是将该用户 session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 session 的 id。这样即使客户端不支持 cookie，也可以使用 session 来记录用户状态。 cookie session 区别 cookie 数据存放在客户的浏览器上，session数据放在服务器上 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存20个 cookie。 鉴于上述区别我们建议 将登陆信息等重要信息存放为 SESSION 其他信息如果需要保留，可以放在 COOKIE 中 参考cookie 与 session 的区别详解 把cookie聊清楚|稀土掘金 Cookie/Session机制详解|CSDN 最后，如果本文有任何知识性错误，欢迎各位小哥哥小姐姐提出！ 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是一个函数]]></title>
    <url>%2F2017%2F09%2F30%2F%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前几天在图书馆粗略的浏览了一本叫做《代码揭秘：从C/C++的角度探秘计算机系统》的书籍。里面有一章节从计算机的底层讲解了函数的本质。恰好码农翻身公众号的推送《我是一个函数》生动的讲解了函数的知识，故转载过来学习 我和邻居我是一个函数， 生活在内存当中，我的家–用你们的”黑话”来说–就是进程的地址空间， 我的邻居也是一个函数，其中有一段很有趣的代码。 我经常去拜访他，去的时候当然不能空着手，我会携带四个数字作为礼物送给他计算， 耐心等待他在 CPU 中忙活半天，最后，作为回赠的礼物，他告诉我一个地址，让我去那里取结果。 拜访的次数多了，我慢慢地琢磨出了我这个邻居做的事情： 房贷计算。 我给他发的四个参数分别是房贷总额，利率，贷款年限，还款方式（等额本息是 1， 等额本金是 2） 他告诉我的是一个地址，其实就是一个列表，存放着每个月应还的月供、本金和利息。 用你们的“黑话”来说就是这样： List calculateHouseLoan(float total, float intrestRate, int years ,int loanType) 所有的调用都发生在本机内的一个进程中， 大家把这种方式称为本地过程调用。 这种调用方式速度飞快，眨眼间就可完成。 有时候，房贷计算邻居会惊呼道： 我赛，你给我发了一个多大的数啊， 800万的贷款总额！ 我就知道，帝都的房价又涨了！ 日子过了一天又一天， 房价也涨了一天又一天。 邻居搬走了一天早上， 我睡了一觉醒来感觉不太对劲，头晕晕的，一般情况下这就表示昨天夜里系统重启了。 还没等我清醒过来， 我就接到上司（调用我的函数）的命令，又要计算房贷了，我忍着头晕赶紧去找邻居，可是这一次却换成了陌生人， 他笑眯眯的说：“是不是要找你的邻居房贷计算啊” “是啊” “他已经搬走了！” “啊？ 他搬到哪儿去了？ 我怎么计算房贷？ ” “ 他搬到另外一台机器去住了，具体位置我也不清楚，不过从 IP 看应该是在同一个机房吧” 说实话这个消息让我吃惊不小，我听人说过，想和网络上的机器通信，那可比本机的同一进程内的通信麻烦太多了。 之前我们生活在同一个进程中，每个函数的住处（地址）对大家来说都是可见的，想要调用了，直接去函数的住处去执行代码即可。 现在这个函数都搬走了，新的地址我也不知道，就是知道了，跨域网络的调用，据说得使用什么socket，建立连接，在连接上按双方商量好格式、次序来发送数据， 接收数据，听着就头大， 打死我也搞不定。 （码农翻身老刘注： socket的故事参见《张大胖和socket》） 陌生人看出了我的担心， 笑着说： “放心吧， 我是他的客户端代理，你尽管把那四个参数交给我，我来帮你搞定” 这家伙自称为客户端代理的家伙竟然知道那个四个参数，也许能行，对我来说反正调用方式没什么变化， 于是我将信将疑地像以前把4个参数传递过去， 他马上就忙活起来，建立连接，发送数据，接收数据，过了很久（我感觉比平时要慢了100倍）他才说房贷已经计算好了，数据在地址XXXX处， 你去拿吧。 我去那个地方一查，和往常一样，每月的还款结果已经整整齐齐的摆在那里了。 “你这个房贷计算的客户端代理还真不含糊啊， 既然你是客户端代理， 难道还有服务器端代理人？ ” “没错， 我还有个好基友，在服务器端忙活， 我和他约定好了消息的格式， 你交给我的数据其实我都通过socket发给他了，由他来调用真正的房贷计算， 然后再把结果发回来。” “难道这就是传说中的远程过程调用（RPC)）？ ” 我问道 ”是的， 我们这两个代理人把脏活累活都帮着你们做了，把那些复杂的网络细节都给隐藏起来了， 在你们看来和本地调用一样。 对了，有人会把我称为 Stub，把我的好基友称为 Skeleton，我和他之间的交互是通过 socket 进行的， 有些 RPC 的代理人可能不用这么底层的东西，直接用 http，不过没关系，只要两端的代理人约定好就行了，关键是要给你们提供一个舒适的体验。” “我想到一个问题， 如果我传递给你的不是简单的 float、int 型的参数， 而是内存中的对象， 怎么处理？” “当然要做序列化了， 要不然怎么通过网络发送啊， 其实 float，int 也得做序列化， 把内存中的值和对象变成二进制流，这样才能发送出去。到了我的好基友那边，他还得做反序列化，把而二进制流再转化为对象， 然后才能调用真正的函数， 唉，这工作实在是麻烦啊。” 我对他表示了深切的同情和敬意， 为了我们能做透明的远程调用，这些代理们真不容易。 “我听说还能用 XML 和 JSON ？” 我问道 “你知道的不少嘛 ！ 有些人在使用 Http 作为通信协议的时候， 喜欢把对象变成文本，例如XML/JSON，可读性比较好，但是你要知道，虽然应用层的 HTTP 中看起来时文本， 但是到了底层通道例如 TCP 发送出去的时候，那还得变成二进制流， 到了目的地再把他们转化成文本。”（码农翻身老刘注： 参加《序列化：一个老家伙的咸鱼翻身》） 聊了半天，我们越来越熟， 我无意间谈起了他的身世， 他说 ： “我们这些代理人啊，出生的方式主要有两种， 一种就是程序员们一行行代码的把我们给敲出来、费心而费力， 另外一种就是自动生成。” “自动生成，具体怎么做？” “拿Java来举个例子， 你可以先定义一个接口(interface), 让这个接口扩展自java.rmi.Remote， 然后写个实现类， 最后用一个工具rmic就可以自动生成客户端和服务器端的代理人了 ， 是不是很简单？ ” 1234567891011121314public interface HouseLoanCalculator extends Remote&#123; public List calculate(float total,float interestRate,int years,int loanType) throws RemoteException;&#125;public class HouseLoanCalculatorImpl extends UnicastRemoteObject implements HouseLoanCalculator&#123; @Override public List calculate(float total,float interestRate, int years,int LoanType) throws RemoteException&#123; //实现房贷计算 &#125;&#125; （码农翻身老刘注： 从JDK5.0开始， 连这个rmic这一步都可以省略， 完全由JVM自动生成，运行时可以把客户端代理人下载到客户端） 网络的世界远比单机精彩， 不知不觉我已经和这个代理人聊了将近800毫秒， 我的上司已经等不及了，他抱怨地说： “这次怎么这么慢？ 难道人类在调试，在你这里加了断点？” 我说 ：“没有调试， 原来是本地过程调用，现在变成远程过程调用了！” 作者：码农翻身刘欣 出处：我是一个函数|码农翻身]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法大杂烩]]></title>
    <url>%2F2017%2F09%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%A7%E6%9D%82%E7%83%A9%2F</url>
    <content type="text"><![CDATA[学习数据结构之后那么算法也是必须需要了解的，甚至对于某些开发人员来说算法是他们开发工作中最为重要的一部分。数据结构和算法又是密不可分的，特定的算法需要特定的数据结构才能发挥出应有的效率。其中，熟悉各种基本的排序算法是程序猿的基本技能之一 引子“算法+数据结构=程序”，这是一名瑞士的计算机科学家 Nicklaus Wirth 提出的著名公式，而他本人也凭借这一句话获得了图灵奖。百科百科上有这么一句评价“这个公式对计算机科学的影响程度足以类似物理学中爱因斯坦的 $E=MC^2$ ” 。而排序算法又是各类算法中最为基础但也较为有用的算法之一，因此对它的了解也显得十分必要和重要。为了叙述方便，本文随后讨论的排序问题都约定为从小到大的排序。 选择排序简单选择排序简单选择排序（Simple Selection Sort）是一种直观的排序算法，其思想是在未排序的序列中选出最小的元素和序列的首位元素交换，接下来在剩下的未排序序列中再选出最小元素与序列的第二位元素交换，以此类推，最后形成从小到大的已排序序列。 下列给出 C 语言实现： 12345678910111213141516void Swap(ElementType *a,ElementType *b)&#123; ElementType t=*a; *a = *b; *b=t;&#125;void SimpleSelectionSort(ElementType A[], int N)&#123; int i,j,min; for(i=0;i&lt;N-1;i++)&#123; min=i; for(j=i+1;j&lt;N;j++)&#123; if(A[j]&lt;A[min])&#123; min=j; //min记录最小元素位置 &#125; Swap(&amp;A[i],&amp;A[min]); //将第 i 个元素与最小元素交换 &#125; &#125;&#125; 可以看出，因为循环中嵌套循环，故其时间复杂度为 $O(N^2)$ 。最好情况下移动元素的次数为 0 次，这时序列已有序。最坏的情况下为 $3(N-1)$ 次（除了最后一个元素外，每个元素都要经过 3 步交换位置）。 堆排序堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。我们知道堆是一种特殊的二叉树，每个子结点的值总是小于（或者大于）它的父结点，相应地分为最大堆和最小堆。由于堆是一个完全二叉树，一般情况下堆排序都是用数组的方式来实现。 堆排序的核心思想是：利用最大堆（或者最小堆）输出堆顶元素，即最大值（或最小值），将剩余元素重新生成最大堆（或者最小堆），继续输出堆顶元素，重复此过程，直到全部元素都已输出，得到的输出元素序列即为有序序列。 实现堆排序方法一种简单的做法是额外开辟一个辅助的数组空间，将堆顶元素逐一放入辅助数组里，最后再把辅助数组的内容复制回原始的数组。这种方法的额外空间复杂度是 $O(N)$ 。下面我们讨论一种更聪明的方法，只用 $O(1)$ 的额外空间即可。 如下图所示，首先将一个无序的序列生成一个最大堆，如图（a）所示。接下来我们不需要将堆顶元素输出，只要将它与堆的最后一个元素对换位置即可，如图（b）所示。这时我们确知最后一个元素 99 一定是递增序列的最后一个元素，而且已经在正确的位置上。 现在问题变成了如何将剩余的元素重新生成一个最大堆——也很简单，只要依次自上而下进行过滤，使其符合最大堆的性质。图（c）是调整后形成的新的最大堆。要注意的是，99 已经被排除在最大堆之外，即在调整的时候，堆中元素的个数应该减 1 。结束第 1 轮调整后，再次将当前堆中的最后一个元素 22 与堆顶元素换位，如图（d）所示，再继续调整成新的最大堆……如此循环，直到堆中只剩 1 个元素，即可停止，得到一个从小到大排列的有序序列。 插入排序简单插入排序简单插入排序的核心思想就是：将待排序的一组序列分为已排好序的和未排好序的两个部分；初始状态时，已排序序列仅包含第一个元素，为排序序列中的元素为除去第一个以外 $N-1$ 个元素；此后将为排序序列中的元素逐一插入到已排序的序列中。如此往复，经过 $N-1$ 次插入后，未排序序列中元素个数为 0，则排序完成。 具体到第 $k-1$ 次插入，对应待插入元素应为第 $k$ 个元素，也就是未排序序列中的第一个元素，插入的基本过程是：将它和第 $k-1$ 个元素（也就是已排序序列的最后一个元素）进行比较，若 大于第 $k-1$ 个记录，则该次循环结束；否则，将两个元素交换，再比较该数和第 $k-2$ 个元素之间 的大小，依此往复，直到该数比它当前位置的前一个元素大，或该数已交换到了第 1 个位置，则第 $k-1$次循环结束。 下面我们来看一个例子。下表显示了对 {44，12，59，36，62，43，94，7，35，52，85} 进行简单插入排序的前 3 次循环的情况。在第 2 次循环结束后，已排序序列中有 3 个记录。第 3 次循环第 1 步，将未排序序列中的第一个记录 36 和已排序组中的最后一个记录59进行比较，因满足 $36&lt;59$ ，因此交换这两个记录；第 2 步，36仍然小于一个记录 44 ，则继续交换；直到大于前一个记录 12 ，则停止交换，第 3 次循环结束。已排序序列中新增记录 36，未排序序列中删除该记录，记录数量减 1 。 下面给出代码实现： 1234567891011void InsertionSort(ElementType A[],int N)&#123; int P,i; ElementType temp; for(P=1;P&lt;N;P++)&#123; temp=A[P]; //取出未排序序列中的第一个元素 for(i=P;i&gt;0&amp;&amp;A[i-1]&gt;temp;i--)&#123; A[i]=A[i-1]; //依次与已排序序列中元素比较并右移 &#125; A[i]=temp; //放进合适的位置 &#125;&#125; 由该算法代码可以看出，空间复杂度上，简单插入排序仅需要常数个额外空间；时间复杂度上，函数中有 2 个嵌套的循环，每个循环进行 $O(N)$ 次比较和交换，因此整个简单插入排序的平均时间复杂度为 $O(N^2)$ 。在最坏的情况下，对应每一个 P ,要进行P- 1 次比较和交换，总共要花费 $O(N^2)$ 次操作；在最好的情况下，也就是对已经排好序的序列进行排序，第二个循环在第一个$(A[i-1]&gt;temp)$ 比较时就跳出，因此总共花费 $O(N)$ 次操作。此外，简单插入排序是稳定的排序，我们发现，数值相同的两个记录不会发生相对位置上的改变。 希尔排序简单插入排序效率不高的一个重要原因是每次只交换相邻的两个元素，这样只能消去一对错位的元素。希尔排序对插人排序进行改进，试图通过每次交换相隔一定距离的元素，达到排序效率上的提升。 希尔排序的基本原理是，将待排序的一组元素按一定间隔分为若干个序列，分别进行插入排序。开始时设置的“间隔”较大，在每轮排序中将间隔逐步减小，直到“间隔”为 1 ，也就是最后一步是进行简单插入排序。 希尔排序将“间隔”定义为一组增量序列，用来分割待排序列，即将位置之差等于当前增量的元素归属于同一个子序列，并分别进行插入排序；排好后再选取下一个增量，划分子序列再次排序，直到最后一个增量（一般为1)。 【例子】对于待排序列 {44，12，59，36，62，43，94，7，35，52，85}，我们可设定增量序列为 {5，3，1}。 【解析】第一个增量为 5，因此 {44，43，85}、{12，94}、{59，7}、{36，35}、{62，52} 分别隶属于同一个子序列，子序列内部进行插入排序；然后选取第二个增量3，因此 {43，35，94，62}、{12，52，59，85}、{7，44，36} 分别隶属于同一个子序列；最后一个增量为 1，这一次排序相当于简单插入排序，但是经过前两次排序，序列已经基本有序，因此此次排序时间效率就提高了很多。希尔排序过程如下： 希尔排序算法的整体时间复杂度和增量序列的选取有关，目前并没有统一的最优增量序列。但使用增量序列 {[$N/2$]，[$N/2^2$]，…，1} 进行希尔排序时，最差情况下时间复杂度为 $O(N^2)$ ；而当使用增量序列 {$2^k-1$，…，7，3，1} 时，最差情况下时间复杂度为 $O(N^{3/2})$ ，其平均时间复杂度尚无定论，猜想结果为 $O(N^{5/4})$ 。除此之外，还有不少其他的增量序列选取方法，在各自特定的排序对象中有较好的时间复杂度的表现。 交换排序冒泡排序冒泡排序估计是很多非计算机相关专业学生都知道的排序算法，这也是交换排序中比较简单的方式。对元素个数为$N$的待排序序列进行排序时， 共进行 $N-1$ 次循环。在第 $k$ 次循环中，对从第 1 到第 $N-k$ 个元素从前往后进行比较，每次比较相邻的两个元素，若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变。这样一次循环下来 ， 就把第 $k$ 大的元素移动到第 $N-k$ 个位置上，称为第 $k$ 趟的冒泡。整个过程一共进行 $N-1$ 趟冒泡 ，直到第 1 个和第 2 个元素比较完成 ，最终剩余最小的元素 ，留在第 1 个位置上，排序结束。 我们来看下例中对给定初始序列的冒泡排序过程，会有十分直观的理解：第 1 趟冒泡后,最大的记录 94 被移动到了第 $N$ 个位置上，它将不参与接下来的冒泡；第 2 趟冒泡后，剩余 $N-1$ 个记录中最大的记录 85 被移动到了第 $N-1$ 个位置上；经过 $N-1$ 趟冒泡后，剩余的最小记录 7 留在第 1 个位置上，排序结束，如下表所示。 快速排序快速排序也是交换排序的一种，但和冒泡排序不同的是，冒泡排序只比较相邻两个记录 的顺序，而快速排序的原理是：将未排序元素根据一个作为基准的“主元”（Pivot）分为两个子序列，其中一个子序列的记录均大于主元，而另一个子序列均小于主元，然后递归地对这两个 子序列用类似的方法进行排序。本质上，快速排序使用分治法，将问题的规模减小，然后再分别进行处理。 首先，子序列的划分方法我们可以参考利用函数递归求取集合的中位数问题的解答。求得中位数后，将该中位数设置为待排序序列的主元，将比主元大的元素从右向左放置，而比主元小的元素从左向右放置。 下表给出了进行一趟主元调整的过程，具体步骤为： 选择一个主元，并与最后一个元素交换。 设置两个指针 Low 和 High ，初值分别指向第一和倒数第二个元素。 Low 从左向右扫描，其位置左侧为已遍历或交换过的比主元小的元素；High从右往左扫描 ， 其位置右侧为已遍历或交换过的比主元大的元素。首先从 Low 指向的位置向右扫描，若遇到比主元大的元素，则停止；然后从 High 指向的位置向左搜索，若遇到比主元小的元素，则停止。 若 Low 和 High 没有错位（即Low&lt;High)，则 High 和 Low 指向的元素互换位置。 重复3、4直至 High 和 Low 错位，将基准与 A[Low] 对换位置。这就完成了一次划分，以主元为边界分别划分成大于和小于主元的两个子序列。 递归地对两个子序列用同样方法进行快排直至当前子序列只有一个元素时结束递归，这样就达到了分而治之的算法目的。 归并排序归并排序是建立在归并操作基础上的一种排序方法。归并操作，是指将两个已排序的子序列合并成一个有序序列的过程。 归并排序的基本原理是：将大小为 $N$ 的序列看成 $N$ 个长度为 1 的子序列，接下来将相邻子序两两进行归并操作，形成$N/2(+1)$ 个长度为 2（或1）的有序子序列；然后再继续进行相邻子序列两两归并操作，如此一直循环，直到剩下 1 个长度为 $N$的序列，则该序列为原序列完成排序后的结果，如下图所示。 归并排序的核心在于归并操作的实现。归并操作的过程如下：首先申请额外的空间用于放置两个子序列归并后的结果，接着设置两个指针分别指向两个已排序子序列的第一个位置，然后比较两个指针指向的元素，将较小的元素放置到已申请的额外空间内，并将当前位置向后移动一格，重复以上过程，直到某一个子序列的指针指向该序列的结尾。这时候将另一个指针所指向序列的剩余元素全部放置到额外空间内，归并操作结束。 下面举个栗子 其实从相反的角度来看，归并排序可以看成是分治法的逆向过程。 基数排序桶排序如果已知 $N$ 个关键字的取值范围是在0到 $M-1$ 之间，而$M$比$N$小得多，则桶排序算法将为关键字的每个可能取值建立一个“桶”，即建立$M$个桶；在扫描$N$个关键字时，将每个关键字放入相应的桶中，然后按桶的顺序收集一遍就自然有序了。所以桶排序效率比一般的排序算法高——当然需要的额外条件是已知关键字的范围，并且关键字在此范围内是可列的，个数还不能超过内存空间所能承受的限度。 【例子】已知某门公共选修课有1500学生选修，其成绩为分布于[0，100]之间的整数。现需要将学生名单按其成绩从低到高顺序打印出来。 【分析】若将学生名单按成绩排序再打印，则至少需要 $O(NlogN)$ 的时间，这里 $N=1500$ 。而用桶排序的方法，可为每一个分数建立一个“桶”，共建101个桶——具体实现时可定义一个链表指针数组 Bucket[101]。顺序扫描学生名单，若当前这个学生的成绩是$i$分，则将他的记录插入 Bucket[ i] 所指的链表头部，这一操作只需2步。整个扫描的过程用去 $O(N)$ 的时间。然后顺序扫描每个Bucket[i]，将链表中的学生名单逐一打印，该过程用$O(N+M)$的时间，其中$M=101$是桶的个数。可见桶排序只需要$O(N+M)$的时间就可以完成名单的顺序打印，特别当$M=O(N)$时，这个时间复杂度是线性的。 基数排序基数排序是桶排序的一种推广，它所考虑的待排记录包含不止一个关键字。例如对一副牌的整理，可将每张牌看作一个记录，包含两个关键字：花色、面值。一般我们可以将一个有序列是先按花色划分为四大块，每一块中又再按面值大小排序。这时“花色”就是一张牌的“最主位关键字”，而“面值”是“最次位关键字”。 对于一般有 $K$ 个关键字的情况，基数排序通常有两种方法：主位优先法（ Most Significant Digit Sort，简称 MSD）和次位优先法（ Least Significant Digit Sort，简称 LSD）。 仍以整理扑克牌为例，顾名思义，新谓主位优先法，是先为最主位关键字（花色）建立桶，将牌按花色分别装进4个桶里；然后对每个桶中的牌，再按其次位关键字（面值）进行排序，最后将4个桶中的牌收集，顺序叠放在一起。 而次位优先法，是先为最次位关键字建立桶，即按面值建立13个桶，将牌按面值分别放于13个桶中；然后将所有桶中的牌收集，顺序叠放在一起；再为主位关键字花色建立4个桶，顺序将每张牌放人对应的花色桶中，则4个花色桶中的牌必是有序的，最后只要将它们收集，顺序叠放即可。 从上述例子可见，两种方法具有不同的特点。主位优先法基本上是分治法的思路，将序列分割成子列后，分别排序再合并结果。而次位优先法是将“排序”过程分解成“分配“和“收集”这两个相对简单的步骤，并不需要分割子列排序，故一般情况下次位优先法的效率更高一些。 单关键字的基数分解从上面可以看到，基数排序主要是对有多关键字的对象进行排序。其实可以将单个整型关键字按某种基数分解为多关键字，再进行排序。这也是“基数排序”名称的由来。例如 826 可以根据基数 10 分解为 8、2、6 这三个关键字，其中 8 是最主位关键字，6是最次位关键字；还可以根据基数 16 分解为 3、3、A 这 3 个关键字，其中第一个3是最主位关键字，A 是最次位关键字。 典型问题是给定 $N$ 个记录，每个记录的关键字为一整数，其取值范围是 0 到 M 之间。若 M 比 N 大很多（例如 $M=N^K$），这时桶排序需要 M 个桶，会造成巨大的空间浪费；而以为基数对关键字进行分解后则只需要 $R$ 个桶就可以了。让我们通过一个具体的例子来理解什么是基数分解。 【例子】给定范围在 0 到 999 之间的 10 个关键字 164,8,216,512,27,729,0,1,343,125 现用基数排序算法进行递增排序。 【分析】我们可以将每个关键字看成一个 3 位的十进制整数（不足位的在左边补 0 )，从而将每个十进制整数关键字分解成 3 个关键字，其个位数为最次位关键字，百位数为最主位关键字。这就是以 10 为基数的分解。对给定的 10 个记录用次位优先法进行基数排序，首选对最次位（个位）关键字建立 10 个桶，将记录按其个位数字的大小放入相应的桶中，如下图（a）所示。此时 10 个数字恰好均匀分布于 10 个桶中，当然一般情况下不是总有这么好的运气。每个“桶”实际上是一个链表，一趟排序后，将桶中记录重新收集成为一个新的记录链 {0，1，512，343，64，125，216，27，8，729}。接下去按下一个次位关键字（十位）排序，所得结果如下图（b）所示。注意到此时桶中记录的分布不再均匀。向桶中插入的新记录需排在链表尾部。将桶中记录收集形成新的记录链 {00，01，08，512，216，125，27，729，343，64}。最后按最主位（百位）关键字排序，结果如下图（c）所示，再收集所得的记录链就是最终有序的 {000，001，008，027，064，125，216，343，515，729}。 外部排序外部排序是指大文件排序，即待排序的数据记录以文件的形式存储在外存储器上。由于文件中的记录很多、信息容量庞大，所以整个文件所占据的存储单元往往会超过了计算机的内存量，因此，无法将整个文件调入内存中进行排序。于是，在排序过程中需进行多次的内外存之间的交换。在实际应用中，由于使用的外设不一致，通常可以分为磁盘文件排序和磁带文件排序两大类。 外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含 $N$ 个记录的文件分成若干长度为 $L(&lt;N)$ 的子文件，依次读入内存，利用内部排序算法进行排序。然后，将排序后的文件写入外存，通常将这些文件称为归并段（Run）或“顺串”；对这些归并段进行逐步归并，最终得到整个有序文件。可见外部排序的基本方法是归并排序法，下面的例子给出了一个简单的外部排序解决过程。 【例子】给定磁盘上有6大块记录需要排序，而计算机内存最多只能对3个记录块进行内排序，则外部排序的过程如下图所示。 【解析】首先将连续的3大块记录读入内存，用任何一种内部排序算法完成排序，再写回磁盘。经过2次3大块记录的内部排序，得到上图（a）的结果。然后另用一个可容纳6大块记录的周转盘，辅助最后的归并。方法是将内存分成3块，其中2块用于输入，1块用于输出，指定一个输入块只负责读取一个归并段中的记录，如上图（b）所示。归并步骤为： 当任一输入块为空时，归并暂停，将相应归并段中的一块信息写入内存 将内存中2个输入块中的记录逐一归并入输出块 当输出块写满时，归并暂停，将输出块中的记录写入周转盘 如此可将2个归并段在周转盘上归并成一个有序的归并段。上例的解决方法是最简单的归并法，事实上外部排序的效率还可以进一步提高。要提高外排的效率，关键要解决以下4个问题： 如何减少归并轮数 如何有效安排内存中的输入、输出块，使得机器的并行处理能力被最大限度地利用 如何有效生成归并段 如何将归并段进行有效归并 针对这四大问题，人们设计了多种解决方案，例如釆用多路归并取代简单的二路归并，就可以减少归并轮数；例如在内存中划分出2个输出块，而不是只用一个，就可以设计算法使得归并排序不会因为磁盘的写操作而暂停，达到归并和写周转盘同时并行的效果；例如通过一种“败者树”的数据结构，可以一次生成2倍于内存容量的归并段；例如利用哈夫曼树的贪心策略选择归并次序，可以耗费最少的磁盘读写时间等。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习日记(三)]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[本文章将记录九月至十一月的学习笔记 2017.9.18网络协议分层模型国际标准化组织 ISO 于 1977 年成立了专门机构。他们就提出一个试图使各种计算机在世界范围内互连成网的标准框架，即著名的开放系统互连基本参考模型 OSI/RM (Open Systems Interconnection Reference Model)，简称为 OSI 。开放系统互连参考模型 OSI/RM 是个抽象的概念。在1983年形成了开放系统互连基本参考模型的正式文件，即著名的 ISO 7498 国际标准，也就是所谓的七层协议的体系结构。 OSI 试图达到一种理想境界，即全世界的计算机网络都遵循这个统一的标准，因而全世界的计算机将能够很方便地进行互连和交换数据。然而到了 20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来了，但由于因特网已抢先在全世界覆盖了相当大的范围，而与此同时却几乎找不到有什么厂家生产出符合 OSI 标准的商用产品。所以因特网使用的 TCP/IP 协议（族）成为了事实上的国际标准。 OSI 的七层协议体系结构（如下图a）的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP体系结构则不同，它现在已经得到了非常广泛的应用。TCP/IP 是一个四层的体系结构（如下图b），它包含应用层、运输层、网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题）。不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层基本上和一般的通信链路在功能上没有多大差别，对于计算机网络来说，这一层并没有什么特别新的具体内容。因此在学习计算机网络的原理时往往釆取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构（如下图c）， 这样既简洁又能将概念阐述清楚。 2017.9.20关于box-sizing: border-box设置该属性后盒装模型的border和padding就被包含在了宽高之内。 关于_proto_和prototype的关系知乎由这样一个有趣的比喻，来源于js中proto和prototype的区别和关系？ 2017.9.23apacheApache 是世界上使用排名第一的 Web 服务器软件。他可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。 CMS 系统随着网络应用的丰富和发展，很多网站往往不能迅速跟进大量信息衍生及业务模式变革的脚步，常常需要花费许多时间、人力和物力来处理信息更新和维护工作；遇到网站扩充的时候，整合内外网及分支网站的工作就变得更加复杂，甚至还需重新建设网站；如此下去，用户始终在一个高成本、低效率的循环中升级、整合……于是一套专业的内容管理系统 CMS 应运而生，来有效解决用户网站建设与信息发布中常见的问题和需求。 div#div1 以及 div #div1 区别 内存泄漏的含义在分配了一块内存空间之后，如果不再需要时就应当考虑将其释放。如果被分配的内容空间不再需要时，程序员没有将其释放，那么这块空间将随同程序运行而一直存在。这就像某人处在一个封闭的空间内，手里握着一定数量的气球，当气球（内存空间）不再需要而将线剪断但却没有戳爆气球，任气球四处飘动，最后这个封闭的空间一定会被那些无用的气球占满空间。回到计算机系统，对于一个需要长时间运行的操作系统，如果运行在操作系统上的应用程序只是一味的分配空间，使用完后却不回收空间，那么最终系统资源无疑将被耗尽，最后整个系统将陷入瘫痪。 线程池在计算机中时常存在这样一种情况，因为需要建立的对象特别多，特别是一些很耗资源的对象需要被频繁地创建和销毁。为了提高效率，节省资源，可以考虑利用已有的对象而非新建对象，这就是“池化资源”技术的初衷。例如数据库服务和网络服务中，我们常常需要建立一个连接对象来发送请求并获取结果。但如果每次操作都新建一个连接对象，使用完又都立刻关闭连接，这样就会造成系统的性能低下。一个解决方案是可以在应用程序启动时建立足够的连接对象，并将这些连接对象组成一个“池”，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，就让它们在请求队列等待。甚至还可以让应用程序可根据池中连接的使用率，动态地增加或减少池中的连接数，但这个动态范围也是有限的。如此一来，连接池技术就会重复利用资源，节省内存开支，从而提高服务效率。 2017.9.26V8引擎和Node环境的不同JavaScript 中 global 对象是单体内置对象，即不依赖宿主环境的对象。而 window 对象依赖浏览器。我的理解是 window 对象是 global 的一个子对象。浏览器环境下，global 对象指的就是 window 对象 2017.9.29OOP 2017.10.1jQuery 遍历 parent()—当前元素的直接父元素 parent()—当前元素的所有父元素 parentsUtil()—当前元素到某一元素之间的所有父元素 children()—当前元素的直接子元素 find()—当前元素下所有子元素中的某个元素 contents()—当前元素下所有子元素，包括子元素的子元素 html()—当前元素的文本内容，为一个字符串值 CSS 权重计算 第一等：代表内联样式，如: style=&quot;...&quot;，权值为1000。 第二等：代表 ID 选择器，如：#content，权值为100。 第三等：代表类，伪类和属性选择器，如.content、:hover、:focus，权值为10。 第四等：代表元素选择器和伪元素选择器，如::afer，权值为1。 具体可详细查看：关于CSS权重(优先级)的理解 electron 是什么 根据官网的描述，electron 是一种可以使用网页技术来开发跨平台桌面应用的解决方案！感受一下，用你已知的技巧html、javascript、css就能写桌面应用，具体内容可查阅 用electron写桌面应用 word-break CSS 属性 word-break 指定了怎样在单词内断行，具体可查阅word-break|MDN white-spacewhite-space CSS 属性是用来设置如何处理元素中的空白，具体可查阅white-space|MDN bootstrap 栅格模式 form的enctype属性enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 application/x-www-form-urlencoded。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。具体可查阅HTML form 标签的 enctype 属性 cellpadding与cellspacing的区别 iframe 标签iframe 元素会创建包含另外一个文档的内联框架（即行内框架） 2017.10.2超链接伪类为了保证 :link、:visited、:hover、active这几个伪类能够起到对应的作用，他们的使用顺序有个记忆的口诀就是 LoVeHAte，具体可查阅 CSS中超链接伪类link,visited,hover,active的顺序分析 link 和 @import 区别可查阅 css link和@import区别 2017.10.3关于 JavaScript 的 forEach 循环语句用法可参考 forEach 方法 (Array) (JavaScript)|MSDN.aspx) 如何跳出循环可参考 踩坑 - Javascript的forEach和Jquery的each跳出循环问题 2017.10.5C语言的指针与数组在C语言中，数组名本身就是数组的第一个元素（下标为 0 ）的地址。在访问内存方面，指针和数组几乎是相同的，当然也有不同：指针变量是以地址作为储存内容的变量，而数组名的值是一个特殊的固定地址，可以把它看作是指针常量，不能改变指针常量的值。 JavaScript中关于小数整数化处理 抛弃小数点后面的数字——parseInt((7/2),10) 向上取整——Math.ceil(7/2) 向下取整——Math.floor(7/2) 四舍五入——Math.round(7/2) 2017.10.6置换元素与非置换元素 置换元素——浏览器根据元素的标签和属性，来决定元素的具体显示内容 非置换元素——浏览器中的大多数元素都是不可置换元素，即其内容直接展示给浏览器 2017.10.7作用域JavaScript 中只有函数作用域和全局作用域。 2017.10.8Bootstrap是什么Bootstrap 包含了扁平化设计 UI + 响应式栅格系统 + css 样式 + 基本HTML组件 + JavaScript 组件 + 其他实用工具在内的一个前端工具集合 IE 8 的支持CSS 3的某些属性border-radius、box-shadow、transform、transistion等肯定不被支持，还有 CSS 3 的媒体查询的支持需要 Respond.js 配合 CSS 3 媒体查询使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。具体内容可查询 CSS3 @media 查询|菜鸟教程 CSS hackCSS hack由于不同厂商的浏览器，比如 Internet Explorer、Safari、Mozilla Firefox、Chrome 等，或者是同一厂商的浏览器的不同版本，如 IE6 和 IE7 ，对 CSS 的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的 CSS ，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack 为不同版本的浏览器定制编写不同的 CSS 效果。 2017.10.10v-if 与 v-show简单来说，v-if是动态的向 DOM 树内添加或者删除 DOM 元素；v-show 是通过设置 DOM 元素的 display 样式属性控制显隐 2017.10.11container 与 container-fluid 不同container 与 container-fluid 是 Bootstrap 中两种不同类型的容器，两者的区别是 container 会根据屏幕宽度的变化通过媒体查询设置一个固定的宽度。而 container-fluid 的宽度自动设置为其父容器宽度的100%，并且相对于其父容器居中。 2017.10.13银行家算法在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己所拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是系统资源，客户就相当于要申请资源的进程。 银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。 安全序列是指一个进程序列 ${P_1,…,P_n}$ 是安全的，即对于每一个进程 $P_i(1\leq i \leq n)$ ，它以后尚需要的资源量不超过系统当前剩余资源量与所有进程当前占有资源量之和。即在分配过程中，不会出现某一进程后续需要的资源量比其他所有进程及当前剩余资源量总和还大的情况。 存在安全序列则系统是安全的，如果不存在则系统不安全，但不安全状态不一定引起死锁。 2017.10.15Array检测数组 浏览器时多线程，JavaScript 在浏览器的执行时单线程，浏览器开多个标签页面每个页面都有一个单独的 window，如果你在一个 HTML 文件中用 iframe 标签嵌套了其他的 HTML ，那么当前页面就是 2 个 window 2017.10.17Object转换方法所有对象都具有 toLocalString()、toString()、valueOf()方法，其中数组调用toString方法时数组内的每一项都会先调用这个方法 Function类型JavaScript中函数也是对象，因此函数名字实际上也是一个指向函数对象的指针 函数声明式与函数表达式JavaScript中定义了一个叫执行环境的概念，环境中定义的所有变量和函数都保存在这个对象中。其中函数定义方式的差别会导致执行环境初始化函数的过程发生区别，通过函数声明定义的函数会在执行环境初始化早期就先加载改函数对象，从而使得在执行环境中的任何代码之前就可用。而通过函数表达式定义的函数得在执行到该函数定义语句的时候才可用，而在这之前都不可用。这是函数声明式与函数表达式之间唯一的差别。 作为一个值的函数在 JavaScript 中不妨把函数变量当做一个有特殊功能的对象变量。所以函数的使用很灵活，比如把函数名当做另一个函数的参数，或者还可以是该函数当做另一个函数的结果返回。123function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument);&#125; 如果某个对象数组，我们需要根据某个对象属性对数组进行排序。而传递给数组 sort()方法的比较函数要接收两个参数。要解决这个问题，我们可以定义一个函数，它接受一个属性名，然后根据这个属性名来创建一个比较函数12345678910111213function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1=object1[propertyName]; var value2=object2[propertyName]; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125; 函数提升应该注意到的地方因为函数声明与函数表达式在函数提升的表现不同，应该注意一下情况的出现，这属于无效语法123456789if(condition)&#123; function sayHi()&#123; alert("Hi!"); &#125;&#125;else&#123; function sayYo()&#123; alert("Yo!"); &#125;&#125; 命名函数表达式1234567var factorial = (function f(num)&#123; if (num&lt;=1)&#123; return 1; &#125;else&#123; return num*f(num-1); &#125;&#125;); 上述代码解决了严格模式下arguments.callee失效的问题 2017.10.18JSONPJSONP (JSON with Padding) 是 JSON 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。为什么我们从不同的域（网站）访问数据需要一个特殊的技术(JSONP)呢？这是因为同源策略。同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。 CNAME 记录DNS 的记录类型有A、AAAA、CNAME 等。其中A记录是域名到 IPV4 地址的映射；AAAA记录是域名到 IPV6地址的映射；CNAME 记录就是把域名映射到另一个域名，而另一个域名也会有个映射到IP地址的记录。CNAME记录解析只是在中间多了一个步骤而已。 2017.10.19Node.js 和 NPM 的关系Node.js 是 JavaScript 的一种运行环境，是对 Google V8 引擎进行的封装。是一个服务器端的javascript的解释器。他们之间是包含关系。比如说你安装好 Node.js ，你打开命令行输入npm -v会显示 NPM 的版本号，说明 NPM 已经安装好。其实 NPM 是 Node.js 的包管理器（Node Package Manager）。我们在Node.js 上开发时，会用到很多别人已经写好的 JavaScript 代码，如果每当我们需要别人的代码时，都根据名字搜索一下，下载源码，解压，再使用，会非常麻烦。于是就出现了包管理器NPM。大家把自己写好的源码上传到 NPM 官网上，如果要用某个或某些个，直接通过 NPM 安装就可以了，不用管那个源码在哪里。并且如果我们要使用模块A，而模块A又依赖模块B，模块B又依赖模块C和D，此时 NPM 会根据依赖关系，把所有依赖的包都下载下来并且管理起来。试想如果这些工作全靠我们自己去完成会多么麻烦！ 前端工程化的理解目前来说，Web业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？…前端工程化是前端架构中重要的一环，主要就是为了解决上述大部分问题的。而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。前端工程化主要应该从模块化、组件化、规范化、自动化四个方面来思考，下面一一展开…….，具体可查看 谁能介绍下web前端工程化|知乎 2017.10.26正则表达式 ^和\b的区别 RegExp 的 exec 方法以及 String 的 match 方法RegExp 对象的主要方法是exec()，该方法是专门为捕获组而设计的。该方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。返回的数组虽然是 Array 对象的实例，但包含两个额外的属性：index 和 input。其中 index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。 而 match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 String Object 中执行一次匹配。如果没有找到任何匹配的文本，match()将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 在局部匹配下，String 对象的 match()方法与 RegExp 对象的 exec() 方法得到的结果都是一个匹配工作进行一次的包含信息的结果数组。而且多次执行 exec() 都是同样的结果，因为 lastIndex 属性不会自动更新。 但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。总之 RegExp 对象的 exec() 无论是全局还是局部匹配，每次执行都只会返回一个匹配工作进行一次的包含信息的结果数组。 错题解答请给出这段代码的运行结果（） 1234567var bb=1;function aa(bb)&#123; bb=2; alert(bb);&#125;aa(bb); //2alert(bb); //1 函数体内，bb 并没有使用 var 来定义，按理说这个 bb 在预处理的时候应该是 window 的属性。但在这里，函数声明的时候，带了一个参数 bb ，也就是相当于在函数体内声明了var bb。所以，函数里的 bb 就是函数活动对象的属性。所以函数执行时会输出 2。函数执行完后，函数的活动对象被销毁，也就是局部的这个 bb 被删除了，执行流进入到 window ，再输出 bb ，值就是1了。如果声明函数时，把参数那里的bb去掉，这段代码执行起来，结果就是弹出 2 2 void 操作符因为undefined在 JavaScript 中不是保留字。换言之，你可以写出： 12345function joke()&#123; var undefined='hello world'; console.log(undefined); //hello world&#125;console.log(undefined); //undefined 于是，采用void方式获取undefined便成了通用准则。同时还有一个常见的功能，填充href。下面是一个微博截图，它的转发, 收藏， 讨论都是超链接，但是用户并不希望点击它们会跳转到另一个页面，而是引发出一些交互操作。 理论上而言，这三个超链接都是没有 URL 的，但如果不写的话，呵呵，点击它会刷新整个页面。于是便用上了href=&quot;javascript:void(0)的方式，确保点击它会执行一个纯粹无聊的void(0)。另一种情况是，如果我们要生成一个空的src的image，最好的方式似乎也是src=&#39;javascript:void(0)&#39;。 2017.10.28ECMAScript 变量因为 ECMAScript 是变量是松散类型的，所以换句话说每个变量仅仅是一个用于保存值的占位符而已 2017.10.30Object.keys(obj)Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 123456/* Object 对象 */ let obj = &#123; foo: "bar", baz: 42 &#125;, keys = Object.keys(obj);// CCAC: Chrome Console Auto Copycopy(keys); // ["foo","baz"] 更多内容可参考Object.keys()|MDN Class 表达式采用 Class 表达式，可以写出立即执行的 Class123456789let person=new class&#123; constructor(name)&#123; this.name=name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); //张三 2017.10.31webpack entry的三种形式的值 字符串——单一入口文件 数组——多文件入口 对象——entry对象内的多个入口文件原本是要与一个个的输出文件一一对应。但如果output为单一输出文件，那么每一个入口文件打包后会覆盖掉其他的入口文件打包后输出的文件，因为他们都同名，所以为了应对这种情况，需要给output的filename属性值加上 [hash]、[name]、[chunkhash]占位符 2017.11.1UglifyJSUglifyJs 是一个js 解释器、最小化器、压缩器、美化器工具集（parser, minifier, compressor or beautifier toolkit）。由于webpack本身集成了UglifyJS插件（webpack.optimize.UglifyJsPlugin），其命令webpack -p即表示调用UglifyJS来压缩代码，还有不少webpack插件如html-webpack-plugin也会默认使用 UglifyJS。 2017.11.3./ ../ / 的区别 ./——当前目录 ../——父级目录 /——当前目录 2017.11.8setTimeout() Or setInterval()一般认为使用超时调用来模拟间歇调用是一种最佳方法，以为当使用间歇调用时会出现后一个间歇调用可能会在前一个间歇调用结束之前启动。 BabelBabel 可以让你使用 ES2015/16/17 写代码而不用顾忌浏览器的问题，Babel 可以帮你转换代码。首先安装必要的几个 Babel 库 npm i --save-dev babel-loader babel-core babel-preset-env先介绍下我们安装的三个库 babel-loader——用于让 webpack 知道如何运行 babel babel-core——可以看做编译器，这个库知道如何解析代码 babel-preset-env——这个库可以根据环境的不同转换代码 CSS expressionIE5 及其以后版本支持在 CSS 中使用 expression，用来把 CSS 属性和 Javascript 表达式关联起来，这里的 CSS 属性可以是元素固有的属性，也可以是自定义属性。就是说 CSS 属性后面可以是一 Javascript 表达式，CSS属性的值等于 Javascript 表达式计算的结果。 在表达式中可以直接引用元素自身的属性和方法，也可以使用其他浏览器对象。123&lt;style type="text/css"&gt; #container &#123; width: expression((documentElement.clientWidth &lt; 725) ? "725px" : "auto" ); &#125;&lt;/style&gt; 2017.11.11Three.js WebGl OpenGl 之间的联系提到 Three.js，就必须说一下 OpenGL 和 WebGL。OpenGL 大概许多人都有所听闻，它是最常用的跨平台图形处理开源库。WebGL 就是基于 OpenGL 设计的面向 web 的 3D 图形标准，它提供了一系列 JavaScript API，通过这些 API 进行图形渲染，系统硬件会加速 3D 渲染，从而获得较高性能。而 Three.js 是 JavaScript 编写的 WebGL 第三方库，通过对 WebGL 接口的封装与简化而形成的一个易用的图形库。而因为 WebGL 的使用需要对计算机图形学有一个比较深入的了解，这对普通前端开发人员来说快速上手 WebGL 是个不小的挑战。但是Three.js 对 WebGL 提供的接口进行了非常好的封装，简化了很多细节，大大降低了学习成本。并且，几乎没有损失 WebGL 的灵活性。 2017.11.13package.json 中 devDependencies 和 dependencies 的区别我们在使用npm install xxx安装模块或插件的时候，有两种命令把他们写入到 package.json 文件中，比如 npm install xxx --save-dev npm install xxx --save 其中后缀为--save-dev安装的插件会被写入到 devDependencies 对象里面去，而后缀为--save安装的插件，则被写入到 dependencies 对象里面去。devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。例如 babel 插件是将 ES6 语法转换成兼容性更好的 ES5 语法，所以只是开发阶段使用这个插件，但是不需要部署到服务器这个部署生产环境中，所以安装这个插件的时候都是使用npm install b 2017.11.16实时渲染和离线渲染画面渲染可以分为两种，一是3D游戏里的实时渲染(Real-time Rendering)，二就是动画电影用到的离线渲染(Offline Rendering)。前者因为需要保证速度而不得不在画质上做出妥协，后者则可以为了追求真实感而不计成本。 2017.11.20一种常见的声明变量的方式1var d = d || &#123;&#125;; 此种用法一般用于函数内部，根据函数是否有对应的参数传入，如果又对应的参数就是其本身，如果没有 d 为一个空对象]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
        <tag>Web前端</tag>
        <tag>计算机网络</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[日常使用 Git ，但是有一些不常用的命令就是记不住，老要去翻。现在特意列出一个命令清单，记录一下常用命令，以备不时之需 几个专用名词的译名如下： workspace：工作区 Index / Stage：暂存区 Repository：仓库区（本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 原作者：阮一峰 原文地址：常用 Git 命令清单]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端大讲座]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%89%8D%E7%AB%AF%E5%A4%A7%E8%AE%B2%E5%BA%A7%2F</url>
    <content type="text"><![CDATA[之前一直以为 Web 前端就是三剑客 JavaScript、CSS、HTML的天下，直到昨晚看见一片微信推送，特别是文章的后面两个章节，让我对前端的概念有了一个更加全面的了解，因此特意转载过来供大家学习 本文的分享主要分为以下三个部分 由于目前计算机专业还没有为 Web 前端技术设立专门的课程，每位同学对前端的了解程度也不一样，今天的讲座会以最浅显的方式来为大家介绍 “前端”，帮助大家建立一个基本的概念。 前端是什么 在回答这个问题之前，我想到了一道面试题： 当我们在浏览器中输入网址并按回车之后，接下来会发生什么？ 我们来简单地看一看 “网页展现” 的整个过程。 比如这里有一个用户，它需要访问 abc.com 这个网址。一般来说，当用户输入一个域名时，是在请求一个 HTML 资源。当他完成域名解析之后，他的浏览器会向 abc.com 这个域名所指向的 Web 服务器发出请求。 有时候 Web 服务器直接就可以返回用户的请求了；有时候 Web 服务器还需要向数据库查询一些数据，然后才能把处理结果返回给用户。 当用户的浏览器拿到服务器返回的 HTML 资源之后，就开始解析并显示 HTML 的内容了。 一般来说，HTML 页面需要 CSS 资源来描述页面的样式。比如浏览器在解析 HTML 时发现了一个 CSS 外链 abc.com/a.css，它就会去请求这个资源。 HTML 页面往往还需要加载外部的 JS 资源，比如 abc.com/a.js，此时浏览器同样会向服务器请求这个资源。 当所需的资源都加载完成之后，这个页面就可以提供完整的外观和功能了。整个过程差不多就是这个样子了。 我们看一看这张流程图，可以在中间画一道竖线，把它分成左右两个部分。 我们会发现，这道线左侧的事情发生在浏览器端，我们称之为 “前端”；右侧的事情发生在服务器端，称为 “后端”。（“前端” 之所以叫 “前端”，是因为它离用户更近一些。） 大家都学过后端开发的相关课程，对后端这一块应该都比较熟悉了。那问题来了：在上面这个过程中，后端有哪些局限？ 服务器一旦把资源提供给浏览器之后，便失去对内容的影响。 服务器无法得知用户在浏览器里做了什么，无法与用户交互。 这意味着，只有当用户下一次向服务器请求资源时，服务器才有机会再次决定用户看到的内容。那么，用户什么时候再向后端请求资源呢？ 第一种情况是 “导航动作”。比如用户刷新页面、点击链接、点击浏览器的前进/后退等等。 第二种情况是用户提交表单。表单是最传统的页面交互方式之一，提交表单时浏览器会向服务器发出新请求——这意味着浏览器会跳转到一个新的地址，服务器会在新页面中显示表单的处理结果。 还有一种特殊情况，就是服务器在给浏览器返回 HTML 资源时，在页面中插入一个特殊的标记，浏览器看到这个标记就会在一定的时间后自动刷新当前页面或跳转到其它页面，相当于服务器强制用户再次发出请求。可想而知，这种非用户意愿驱动的页面跳转行为并不讨人喜欢，因此已经不常用了。 在传统网页中，上述几种用户与服务器之间的交互方式也算够用了。不过随着网页形态的不断演进，用户对网页体验提出了更高的要求，很多时候网页不仅仅是一篇静止的文档，而更像是一个应用程序，用户随时可能与之互动。这个时候，前端的价值就体现出来了。 用户从停留在当前页面到发起新请求的这段时间内，前端可以控制页面内容。 当用户停留在当前页面时，前端有能力与用户交互。由于前端的 JS 可以监听用户在浏览器中的各种行为（比如鼠标点击、键盘输入、滚动页面等等），前端就可以针对这些行为作出相应的反馈。 在前端与用户的交互过程中，有些事情光靠前端就可以做出响应。比如我们在网页上做了一个计算器的功能，当用户输入算式之后，JS 就可以直接计算出结果并显示给用户。整个过程不需要服务器的参与就可以完成。 但有些事情，光有前端是无法完成的。此时前端就需要交给后端来处理，拿到处理结果之后再交给用户。在这个过程中，前端可以让用户一直停留在当前页面，交互过程具有良好的连续性。 那么，前端如何把任务交给后端并拿到后端处理的结果呢？主要有两种方式：Ajax 和 Socket 连接。 Ajax 是最常见的前后端交互方式。它以 “请求→响应” 的方式来完成前后端的信息传递。传统的表单交互需求几乎都可以由 Ajax 改造为 “原地提交并获取反馈” 的交互方式，不需要跳转页面，从而有效提升用户体验。 而对于实时性比较高的场景，Socket 连接就是一个更好的选择。它的工作方式是前后端建立一个持续的连接，信息可以随时由前端发向后端，或由后端推送到前端。如果我们要建立一个实时对话的应用，通常就会用到 Socket 连接了。 前端需要用到哪些技术 说到前端技术，我们通常都会说到 “三大块”： HTML CSS JS 这是前端最核心的三项技术。 接下来，我们就会说到 “前端的分层架构”。这个架构的原则就是 “让合适的技术去做合适的事情”。一个网页从逻辑上可以视为这三层的有机结合体： 结构层：这一层的作用是表述一个页面中有哪些信息，以及这些信息之间的关系是什么。这一层在技术上是由 HTML 来实现的。 表现层：这一层决定了页面中的信息会以什么样的外观呈现出来。这一层由 CSS 来实现。 行为层：这一层控制了页面如何与用户进行交互。在传统的展示型网页中，可能只需要 “结构层” 和 “表现层” 就足以提供完整的功能；而现代网页承载了越来越多的交互，这就推动 “行为层” 的能力不断增强。这一层由 JS 来实现。 我们通过一个实例来理解这个分层架构。 比如我是一个百姓网的用户，我打开了 “用户中心” 中的 “我发布的信息” 这个页面 这个页面的 HTML 描述了信息以及信息的结构。即使没有 CSS 和 JS 的辅助，这个页面仍然可以呈现出可理解的内容（参见上图）。页面顶部是一些导航元素，接下来的 “显示中的信息” 是一个标题，它又引出了一个列表。这个列表自然就是我在百姓网发布的所有信息了。（除了 “显示中的信息” 以外，页面后半段还有 “已删除的信息”，这里不再赘述。） 接下来，我们会在表现层下功夫，通过 CSS 来为页面中的各个元素设定外观。经过这一层的修饰之后，页面中的内容更加美观了；更重要的是，各元素的功能职责也更加直观易懂了（参见上图）。 这已经是一个挺不错的网页了，但接下来，我们还会通过 JS 来丰富它的功能，提升用户的使用效率。 作为信息的发布者，我可能需要修改某条信息的内容，或对它进行 “刷新” 之类的操作。在传统的交互中，我需要在这个列表中点击需要操作的信息，然后在信息的详情页选择合适的操作。 我们可以把这个流程简化一下：我们在这个列表中为每条信息添加一个操作按钮，当用户点击某条信息的操作按钮时，我们就在页面中弹出一个操作面板，用户可以直接选择想要的操作，减少了中间环节（参见上图）。 由此可见，结构层、表现层、行为层这三者各有所长，共同构造了一个功能完备、体验良好的网页出来。 除了基本的 “三大块” 之外，作为前端工程师，我们还需要掌握以下知识和技能： HTTP 相关：由于前端资源都是浏览器通过网络下载的，因此我们有必要了解相关的网络协议。 浏览器相关：前端代码运行在浏览器中，我们需要了解浏览器的各种特性，以及浏览器向我们提供的各种接口。 前端性能优化：让网页更快，减少用户的等待，这也是前端工程师面临的重要课题。优化网页的前端性能，需要我们具备上面两项知识，并且掌握性能优化相关的工具和方法。 图形图像：网页信息不仅包含文字，还包含图片、视频等多媒体信息。图片作为最常用媒体资源，需要我们掌握与其相关的技能。比如了解各种图片格式适用的场景、基本的图片处理方法等等。 前端的开发方式是怎样的 前面我们已经介绍了前端技术 “三大块”，然而在如今，当我们在编写这三块的代码时，已经不再 “裸写” 了。这意味着我们在开发阶段编写的代码与实际在浏览器环境中运行的代码已经不一样了，详细来说： 我们通过模板语言来生成 HTML。 通过 CSS 预处理器来生成 CSS 代码。 通过 ES6+ 的语法和特性来编写 JS 代码。 举例来看吧，以下三个例子展示了代码书写方式的演化。 百姓网采用了 Jade 和 Jedi 这两种模板语言。在上图的代码中，我们仅仅使用了模板语言最基本的标记语法，还没有插入使用模板语言的任何逻辑能力。仅此一步，就可以看出模板语言带来的好处。 原先我们在写 HTML 代码时，会花费大量的精力在 &lt;、/、&gt; 这样的语法噪音上；同时，识别标签的嵌套关系也很费眼。幸运的是，Jade 和 Jedi 这样的现代模板语言把前端工程师解放了出来。它们通过缩进来表达嵌套关系，层级关系一目了然；语法更精练，表现力更强。 在 CSS 方面，预处理器一方面通过更简洁的语法减轻开发者的书写负担，另一方面通过内置的逻辑能力增强了代码的表现力。举个例子，在使用原生 CSS 来写代码时，不同元素采用的相同颜色只能分散在代码各处；而采用了 CSS 预处理器之后，我们可以把相同意义的颜色通过变量的形式抽象出来，然后在代码各处调用即可。这样不仅便于后期维护，在平时读代码时也更容易理解代码意图。 在 JS 方面，我们开始享受 ES6+ 带来的新特征福利。ES（ECMAScript）是定义 JS 这门语言的标准规范，从第六版开始，ES 以每年一版的节奏持续快速地扩展着 JS 语言的能力。 在以往，如果我们要实现 “在数组中找出符合特定条件的成员” 的需求，往往需要借助 Underscore 这样的工具库，调用它的 _.find() 方法。而在 ES6 中，语言本身就扩展了数组的能力，我们只需要直接调用 Array#find() 接口即可。另外，像箭头函数这样的新语法也可以令代码进一步简化。 在 HTML、CSS、JS 这三大块，我们放弃 “裸写”，采用 “更高级” 语言的目的在于： 利用高级语言提供的 “逻辑能力” 来增强代码的表现力。 利用高级语言的 “语法糖” 和 “新特性” 来提升开发效率和舒适度。 当然，采用这些更高级的语言也不是完全没有成本的。我们在开发阶段所用的语言已经不是纯粹的 HTML、CSS、JS 了，浏览器无法直接识别和运行。因此，当我们放弃 “裸写”，也就意味着： 在部署流程中需要设立构建环节，把源码编译到浏览器环境可以运行的目标代码。 在开发阶段，需要有工具来实时监视并编译有变动的源码，以确保页面上呈现的是我们修改过的最新效果。 在百姓网，前端架构组已经搭建好了必要的开发环境，开发者们只需要关注开发本身就可以了。 在企业级的前端开发中，我们还需要了解如下知识点： 模块化：模块化是最常见的编程实践之一，令我们的代码组织更加清晰、易维护。ES6 为 JS 增加了完善的模块化方案，我们的日常开发也已经迁移到了 ES6 模块规范之下。 包管理：如何将开源社区中的优秀组件为我所用？这就不能不提 “npm” 这个最主流的 JS 包管理器。前端界优秀的开源项目几乎都发布到了 npm 的包仓库，我们日常开发中用到的第三方库也都是由 npm 来管理的。 打包工具可以把我们写的模块化的源码和第三方包整合到一起，形成页面所需的完整 JS 资源。“包管理器”、“模块化”、“打包工具” 的相互结合，基本上就是日常的 JS 代码组织方式。 组件化：在传统的前端开发中，HTML、CSS、JS 这三块的代码有各自独立的文件，这些文件往往也分散在不同的目录结构中。 如果页面功能区块的划分足够清晰，开发者就可以用 “组件” 的概念来把页面拆分，整个页面会被视为多个组件的嵌套和组合；同时，开发者也倾向于把每个组件相关的 HTML、CSS、JS 代码整合到同一个目录（或同一个文件）中，便于管理和维护。 这就是 “组件化” 的开发模式。要实现这样的开发模式，通常需要前端框架和构建工具的配合。 单页应用：HTML5 的 History API 为前端提供了控制浏览器导航行为的能力，配合 Ajax 无刷新更新页面内容的特性，我们可以在一个页面内实现应用的多视图切换，避免页面的频繁跳转，提供类似桌面应用的体验。比如 Gmail 等产品就是典型的单页应用模式，百姓网的大多数后台系统也都是单页应用。 其它实用的知识点，就留待大家在工作中慢慢发掘吧。 原文地址：给不了解前端的同学讲前端 版权归原作者所有]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 开发进阶：理解 JavaScript 作用域和作用域链]]></title>
    <url>%2F2017%2F09%2F01%2FJavaScript-%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%90%86%E8%A7%A3-JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[作用域是 JavaScript 最重要的概念之一，想要学好 JavaScript 就需要理解 JavaScript 作用域和作用域链的工作原理。恰好看见一篇不错的博文，就转载过来以供学习理解 JavaScript 作用域任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。 全局作用域（Global Scope）在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：123456789101112var authorName="山边小溪";function doSomething()&#123; var blogName="梦想天空"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(authorName); //山边小溪alert(blogName); //脚本错误doSomething(); //梦想天空innerSay() //脚本错误 所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：12345678function doSomething()&#123; var authorName="山边小溪"; blogName="梦想天空"; alert(authorName);&#125;doSomething(); //山边小溪alert(blogName); //梦想天空alert(authorName); //脚本错误 变量blogName拥有全局作用域，而authorName在函数外部无法访问到。 所有 window 对象的属性拥有全局作用域一般情况下，window 对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（Local Scope）和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域，例如下列代码中的blogName和函数innerSay都只拥有局部作用域 123456789function doSomething()&#123; var blogName="梦想天空"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(blogName); //脚本错误innerSay(); //脚本错误 作用域链（Scope Chain）在 JavaScript 中，函数也是对象，实际上，JavaScript 里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 Scope ，由 ECMA-262 标准第三版定义，该内部属性 Scope 包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数： 1234function Add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125; 在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）： 函数 Add 的作用域将会在执行时用到。例如执行如下代码： 1var total = Add(5,10); 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数内部属性 Scope 所包含的对象。 这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示： 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 作用域链与代码优化从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码： 12345function changeColor()&#123; document.getElementById("btnChange").onclick=function()&#123; document.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125; 这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下： 123456function changeColor()&#123; var doc=document; doc.getElementById("btnChange").onclick=function()&#123; doc.getElementById("targetCanvas").style.backgroundColor="red"; &#125;;&#125; 这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。 改变作用域函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。 with 语句是对象的快捷应用方式，用来避免书写重复代码。例如： 1234567891011121314function initUI()&#123; with(document)&#123; var bd=body, links=getElementsByTagName("a"), i=0, len=links.length; while(i &lt; len)&#123; update(links[i++]); &#125; getElementById("btnInit").onclick=function()&#123; doSomething(); &#125;; &#125;&#125; 这里使用 with 语句来避免多次书写 document ，看上去更高效，实际上产生了性能问题。当代码运行到 with 语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示： 因此在程序中应避免使用 with 语句，在这个例子中，只要简单的把 document 存储在一个局部变量中就可以提升性能。 另外一个会改变作用域链的是 try-catch 语句中的 catch 语句。当 try 代码块中发生错误时，执行过程会跳转到 catch 语句，然后把异常对象推入一个可变对象并置于作用域的头部。在 catch 代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码： 12345try&#123; doSomething();&#125;catch(ex)&#123; alert(ex.message); //作用域链在此处改变&#125; 请注意，一旦 catch 语句执行完毕，作用域链机会返回到之前的状态。try-catch 语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少 catch 语句对性能的影响。一个很好的模式是将错误委托给一个函数处理，例如： 12345try&#123; doSomething();&#125;catch(ex)&#123; handleError(ex); //委托给处理器方法&#125; 优化后的代码，handleError 方法是 catch 子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。 作者：山边小溪 出处：http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 游戏——Ping-Pong]]></title>
    <url>%2F2017%2F08%2F31%2F%E7%94%A8JavaScript%E5%86%99%E4%B8%80%E4%B8%AAPing-Pong%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[学习了一段时间 Web 前端后，就想写个项目练练手，后来就想到了这个 Ping-Pong 游戏，因为记得以前看有关电子游戏的纪录片时里面说到这个游戏是世界上第一款电子游戏，加上觉得项目难易度挺合适的，就撸起袖子加油干。游戏支持单人、双人玩家，所以欢迎各位无聊时拿来消消遣，搞搞基甚至撩撩妹，顺便找找 bug (逃)…… 项目效果在线游戏：PingPongGame(http://barryliu1995.studio/PingPongGame/) GitHub 仓库：BarryLiu1995/PingPongGame 项目详情请查阅 README 文件，也欢迎各位 star，fork！ 项目情况本项目使用 JavaScript 在 Canvas 作画，同时使用 window.requestAnimationFrame() 方法告诉浏览器逐帧更新画面，以形成动画效果。这是这个项目的基本原理。而使用 JavaScript 更新 canvas 上的内容就是该项目的重点难点。scripts 目录下的 game.js 是单人游戏的业务逻辑代码，double-game.js 是依赖于 game.js 的双人游戏业务逻辑代码。 index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;link rel="stylesheet" href="styles/index.css"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Ping-Pong&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;audio preload="true" id="collide"&gt; &lt;source src="sound/PingPong.mp3" /&gt; &lt;source src="sound/PingPong.ogg" /&gt;&lt;/audio&gt;&lt;script src="scripts/game.js"&gt;&lt;/script&gt;&lt;script src="scripts/double-game.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; game.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477// RequestAnimationFrame(): a browser API for getting smooth animationsrequestAnimFrame = (function () &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) &#123; return window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();cancelRequestAnimFrame = (function () &#123; return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout&#125;)();// Initialize canvas and required variablesvar canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d"), // Create canvas context W = window.innerWidth, // Window's width H = window.innerHeight, // Window's height particles = [], // Array containing particles ball = &#123;&#125;, // Ball object paddles = [2], // Array containing two paddles mouse = &#123;&#125;, // Mouse object to store it's current position points = 0, // variable to store points particlesCount = 20, // Number of sparks when ball strikes the paddle flag = 0, // Flag variable which is changed on collision particlePos = &#123;&#125;, // Object to contain the position of collision multiplier = 0, // variable to control the direction of sparks startBtn = &#123;&#125;, // Start button object restartBtn = &#123;&#125;, // Restart button object over = 0, // flag variable, changed when the game is over init, // variable to initialize animation paddleHit, // variable about which paddle was hit gameMode = 0; // variable about how many gamer are playing// Add mousemove and mousedown events to the canvascanvas.addEventListener("mousemove", trackPosition, true);canvas.addEventListener("mousedown", btnClick, true);// Initialise the collision soundcollision = document.getElementById("collide");// Set the canvas's height and width to full screencanvas.width = W;canvas.height = H;// Function to paint canvasfunction paintCanvas() &#123; ctx.fillStyle = "black"; ctx.fillRect(0, 0, W, H);&#125;// Function for creating paddlesfunction Paddle(pos) &#123; this.name = pos; this.vx = 16; // Height and width this.h = 8; this.w = 150; // Paddle's position this.x = W / 2 - this.w / 2; this.y = (this.name == "top") ? 0 : H - this.h;&#125;// Push two new paddles into the paddles[] arraypaddles.push(new Paddle("bottom"));paddles.push(new Paddle("top"));// Ball objectball = &#123; x: 20, y: 20, r: 9, c: "white", vx: 4, vy: 8, // Function for drawing ball on canvas draw: function () &#123; ctx.beginPath(); ctx.fillStyle = this.c; ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false); ctx.fill(); &#125;&#125;;// Start Button objectstartBtn = &#123; w: 125, h: 50, x: W / 2, y: H / 2 - 25, draw: function () &#123; ctx.strokeStyle = "white"; ctx.lineWidth = "2"; ctx.strokeRect(this.x - 150, this.y, this.w, this.h); // single player game start button ctx.strokeRect(this.x + 25, this.y, this.w, this.h); // double player game start button ctx.font = "18px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStlye = "white"; ctx.fillText("Single Player", W / 2 - 87.5, H / 2); ctx.fillText("Double Player", W / 2 + 87.5, H / 2); &#125;&#125;;// Restart Button objectrestartBtn = &#123; w: 125, h: 50, x: W / 2, y: H / 2 - 25, draw: function () &#123; ctx.strokeStyle = "white"; ctx.lineWidth = "2"; ctx.strokeRect(this.x - 150, this.y, this.w, this.h); // single player game restart button ctx.strokeRect(this.x + 25, this.y, this.w, this.h); // double player game restart button ctx.font = "18px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStlye = "white"; ctx.fillText("Single Player", W / 2 - 87.5, H / 2); ctx.fillText("Double Player", W / 2 + 87.5, H / 2); &#125;&#125;;// Draw everything on canvasfunction draw() &#123; paintCanvas(); //draw Paddles on canvas for (var i = 1; i &lt; paddles.length; i++) &#123; p = paddles[i]; ctx.fillStyle = "white"; ctx.fillRect(p.x, p.y, p.w, p.h); &#125; ball.draw(); update();&#125;// Function to update positions, score and everything.// Basically, the main game logic is defined herefunction update() &#123; // Update scores updateScore(); // Move the paddles on mouse move if (mouse.x &amp;&amp; mouse.y) &#123; for (var i = 1; i &lt; paddles.length; i++) &#123; p = paddles[i]; p.x = mouse.x - p.w / 2; &#125; &#125; // Move the ball ball.x += ball.vx; ball.y += ball.vy; // Collision with paddles p1 = paddles[1]; p2 = paddles[2]; // If the ball strikes with paddles, // invert the y-velocity vector of ball, // increment the points, play the collision sound, // save collision's position so that sparks can be // emitted from that position, set the flag variable, // and change the multiplier if (collides(ball, p1)) &#123; collideAction(ball, p1); &#125; else if (collides(ball, p2)) &#123; collideAction(ball, p2); &#125; else &#123; // Collide with walls, If the ball hits the top/bottom walls, run gameOver() function if (ball.y + ball.r &gt; H) &#123; ball.y = H - ball.r; gameOver(); &#125; else if (ball.y &lt; 0) &#123; ball.y = ball.r; gameOver(); &#125; // If ball strikes the vertical walls, invert the // x-velocity vector of ball if (ball.x + ball.r &gt;= W) &#123; ball.vx = -ball.vx; ball.x = W - ball.r; &#125; else if (ball.x - ball.r &lt; 0) &#123; ball.vx = -ball.vx; ball.x = 0 + ball.r; &#125; &#125; // If flag is set, push the particles if (flag == 1) &#123; for (var k = 0; k &lt; particlesCount; k++) &#123; particles.push(new Particles(particlePos.x, particlePos.y, multiplier)); &#125; &#125; // Emit particles/sparks emitParticles(); // reset flag flag = 0;&#125;// Function for creating particles objectfunction Particles(x, y, m) &#123; this.x = x; this.y = y; this.radius = 1.2; this.vx = -1.5 + Math.random() * 3; this.vy = m * Math.random() * 1.5;&#125;// Function for updating scorefunction updateScore() &#123; console.log("ball.vx: " + ball.vx); console.log("ball.vy: " + ball.vy); console.log("points: " + points); ctx.fillStlye = "white"; ctx.font = "16px Arial, sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "top"; ctx.fillText("Score: " + points, 20, 40);&#125;// Function for emitting particlesfunction emitParticles() &#123; for (var j = 0; j &lt; particles.length; j++) &#123; var par = particles[j]; ctx.beginPath(); ctx.fillStyle = "white"; if (par.radius &gt; 0) &#123; ctx.arc(par.x, par.y, par.radius, 0, Math.PI * 2, false); &#125; ctx.fill(); par.x += par.vx; par.y += par.vy; // Reduce radius so that the particles die after a few seconds par.radius = Math.max(par.radius - 0.05, 0.0); &#125;&#125;//Function to check collision between ball and one of//the paddlesfunction collides(b, p) &#123; if (b.x &gt;= p.x &amp;&amp; b.x &lt;= p.x + p.w) &#123; if (b.y &gt;= (p.y - ball.r) &amp;&amp; p.y &gt; 0) &#123; paddleHit = 1; return true; &#125; else if (b.y &lt;= p.h + ball.r &amp;&amp; p.y == 0) &#123; paddleHit = 2; return true; &#125; else return false; &#125;&#125;//Do this when collides == truefunction collideAction(ball, p) &#123; ball.vy = -ball.vy; if (paddleHit == 1) &#123; ball.y = p.y - ball.r; particlePos.y = ball.y + ball.r; multiplier = -1; &#125; else if (paddleHit == 2) &#123; ball.y = p.h + ball.r; particlePos.y = ball.y - ball.r; multiplier = 1; &#125; // This variable relates to the increase in the speed of the ball, // so no matter how many player have will calculate this variable points++; // When there are two players, // will be based on the game to calculate their respective scores if (gameMode === 2) &#123; if (paddleHit === 1) &#123; bottomScore++; &#125; else if (paddleHit === 2) &#123; topScore++; &#125; &#125; increaseSpd(); // Collision sound will be made if (collision) &#123; if (points &gt; 0) collision.pause(); collision.currentTime = 0; collision.play(); &#125; particlePos.x = ball.x; flag = 1;&#125;// Function to increase speed after every 5 pointsfunction increaseSpd() &#123; if ((points + 1) % 5 == 0) &#123; if (Math.abs(ball.vx) &lt; 15) &#123; ball.vx += (ball.vx &lt; 0) ? -1 : 1; ball.vy += (ball.vy &lt; 0) ? -2 : 2; &#125; &#125;&#125;// Track the position of mouse cursorfunction trackPosition(e) &#123; mouse.x = e.pageX; mouse.y = e.pageY;&#125;// Function to run when the game oversfunction gameOver() &#123; ctx.fillStlye = "white"; ctx.font = "20px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; // According to the number of different players show the current score if (gameMode === 1) &#123; ctx.fillText("Game Over - You scored " + points + " points!", W / 2, H / 2 + 50); &#125; else if (gameMode === 2) &#123; if (topScore &gt; bottomScore) &#123; ctx.fillText("Player 1 Win!!! - You scored " + topScore + " points!", W / 2, H / 2 + 50); &#125; else if (topScore &lt; bottomScore) &#123; ctx.fillText("Player 2 Win!!! - You scored " + bottomScore + " points!", W / 2, H / 2 + 50); &#125; else &#123; ctx.fillText("Both are Winner!!! - You scored " + topScore + " points!", W / 2, H / 2 + 50); &#125; &#125; ctx.fillStlye = "white"; ctx.font = "35px Arial, sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("Restart", W / 2, H / 2 - 100); // Stop the Animation cancelRequestAnimFrame(init); // Set the over flag over = 1; // Show the restart button restartBtn.draw(); reset();&#125;// Function for running the whole animationfunction animloop() &#123; init = requestAnimFrame(animloop); if (gameMode === 1) &#123; draw(); &#125; else if (gameMode === 2) &#123; paint(); &#125;&#125;// On button click (Restart and start)function btnClick(e) &#123; // Variables for storing mouse position on click var mx = e.pageX, my = e.pageY; // Click Single Player start button if (mx &gt;= startBtn.x - 150 &amp;&amp; mx &lt;= startBtn.x - 25 &amp;&amp; my &gt;= startBtn.y &amp;&amp; my &lt;= startBtn.y + startBtn.h) &#123; gameMode = 1; animloop(); &#125; // Click Double Player start button if (mx &gt;= startBtn.x + 25 &amp;&amp; mx &lt;= startBtn.x + 150 &amp;&amp; my &gt;= startBtn.y &amp;&amp; my &lt;= startBtn.y + startBtn.h) &#123; gameMode = 2; animloop(); &#125; // If the game is over, and the restart button is clicked if (over == 1) &#123; // Click Single Player restart button if (mx &gt;= restartBtn.x - 150 &amp;&amp; mx &lt;= restartBtn.x - 25 &amp;&amp; my &gt;= restartBtn.y &amp;&amp; my &lt;= restartBtn.y + restartBtn.h) &#123; gameMode = 1; animloop(); &#125; // Click Double Player restart button if (mx &gt;= restartBtn.x + 25 &amp;&amp; mx &lt;= restartBtn.x + 150 &amp;&amp; my &gt;= restartBtn.y &amp;&amp; my &lt;= restartBtn.y + restartBtn.h) &#123; gameMode = 2; animloop(); &#125; &#125;&#125;// Show the start screenstartScreen();// Function to execute at startupfunction startScreen() &#123; draw(); startBtn.draw();&#125;// Reset the variable when the game is overfunction reset() &#123; ball.x = 20; ball.y = 20; points = 0; over = 0; ball.vx = 4; ball.vy = 8; topScore = 0; bottomScore = 0; topLeft = false; topRight = false; bottomLeft = false; bottomRight = false; paddles[1].x = W / 2 - paddles[1].w / 2; paddles[2].x = W / 2 - paddles[2].w / 2;&#125; 此处主要内容就是根据一定逻辑更新球的运动轨迹，根据事件处理更新挡板的位置，还有碰撞发生后的一系列处理逻辑。大家可以根据注释阅读理解此处代码 double-game.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var topScore = 0, // variable to record Player1's score bottomScore = 0, // variable to record Player2's score keyNum, // variable to get keyCode topLeft = false, // variable to record whether the corresponding button is pressed topRight = false, // variable to record whether the corresponding button is pressed bottomLeft = false, // variable to record whether the corresponding button is pressed bottomRight = false; // variable to record whether the corresponding button is pressed// Set the variable when the corresponding button is pressedwindow.document.onkeydown = function (ev) &#123; var event = ev || window.event; keyNum = event.keyCode; if (keyNum === 65) &#123; topLeft = true; &#125; else if (keyNum === 68) &#123; topRight = true; &#125; else if (keyNum === 37) &#123; bottomLeft = true; &#125; else if (keyNum === 39) &#123; bottomRight = true; &#125;&#125;;// Set the variable when the corresponding button to bounce upwindow.document.onkeyup = function (ev) &#123; var event = ev || window.event; keyNum = event.keyCode; if (keyNum === 65) &#123; topLeft = false; &#125; else if (keyNum === 68) &#123; topRight = false; &#125; else if (keyNum === 37) &#123; bottomLeft = false; &#125; else if (keyNum === 39) &#123; bottomRight = false; &#125;&#125;;function paint() &#123; paintCanvas(); // Draw the top paddle ctx.fillStyle = "#ff4949"; ctx.fillRect(paddles[2].x, paddles[2].y, paddles[2].w, paddles[2].h); // Draw the bottom paddle ctx.fillStyle = "white"; ctx.fillRect(paddles[1].x, paddles[1].y, paddles[1].w, paddles[1].h); ball.draw(); Update();&#125;function Update() &#123; // Update the score updateGrade(); // Use the relevant variables to record whether // or not the two keys on the keyboard are pressed if (topLeft) &#123; if (paddles[2].x &gt;= -16) &#123; paddles[2].x -= paddles[2].vx; &#125; &#125; if (topRight) &#123; if (paddles[2].x &lt;= W - paddles[2].w + 16) &#123; paddles[2].x += paddles[2].vx; &#125; &#125; if (bottomLeft) &#123; if (paddles[1].x &gt;= -16) &#123; paddles[1].x -= paddles[1].vx; &#125; &#125; if (bottomRight) &#123; if (paddles[1].x &lt;= W - paddles[1].w + 16) &#123; paddles[1].x += paddles[1].vx; &#125; &#125; ball.x += ball.vx; ball.y += ball.vy; // Collision with paddles pa1 = paddles[1]; pa2 = paddles[2]; if (collides(ball, pa1)) &#123; collideAction(ball, pa1); &#125; else if (collides(ball, pa2)) &#123; collideAction(ball, pa2); &#125; else &#123; // Collide with walls, If the ball hits the top/bottom walls, run gameOver() function if (ball.y + ball.r &gt; H) &#123; ball.y = H - ball.r; gameOver(); &#125; else if (ball.y &lt; 0) &#123; ball.y = ball.r; gameOver(); &#125; // If ball strikes the vertical walls, invert the // x-velocity vector of ball if (ball.x + ball.r &gt;= W) &#123; ball.vx = -ball.vx; ball.x = W - ball.r; &#125; else if (ball.x - ball.r &lt; 0) &#123; ball.vx = -ball.vx; ball.x = 0 + ball.r; &#125; &#125; if (flag == 1) &#123; for (var k = 0; k &lt; particlesCount; k++) &#123; particles.push(new Particles(particlePos.x, particlePos.y, multiplier)); &#125; &#125; emitParticles(); flag = 0;&#125;function updateGrade() &#123; ctx.fillStyle = "#ff4949"; ctx.font = "16px Arial, sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "top"; ctx.fillText("Player1 Score: " + topScore, 20, 40); ctx.fillStyle = "white"; ctx.textBaseline = "bottom"; ctx.fillText("Player2 Score: " + bottomScore, 20, H - 40);&#125; 依赖于 game.js 的双人游戏业务逻辑代码，阅读完 game.js 后便可易于理解此处代码 index.css12345* &#123; padding: 0; margin: 0; overflow: hidden;&#125; 参考 Canvas Web API 接口|MDN window.requestAnimationFrame|MDN CSS3动画那么强，requestAnimationFrame还有毛线用？ 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 GitHub Pages 在线加载静态网页]]></title>
    <url>%2F2017%2F08%2F28%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub-Pages%E5%9C%A8%E7%BA%BF%E5%8A%A0%E8%BD%BD%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[相信很多前端新手在开发完一个项目后，迫不急待的希望能够把自己的项目部署到网络中。GitHub 这一神奇的网站就为我们提供了这一便利，它可以解析静态网页，免去自己购买云主机+域名的麻烦，而且操作也很简便 疑问很多童鞋在把自己的前端项目上传到 GitHub 仓库中后，希望点击 HTML 文件时能让浏览器解析出来，但现实却是点进去之后你看到的是文件的源码。所以很多新手就考虑着要不要买个云主机+域名来部署到互联网上，其实这是完全没有必要的，因为在 GitHub 这个神奇的地方还有很多你不知道的秘密（装逼脸）。 解决办法第一步：将项目上传到 GitHub 仓库 第二步：找到项目 Settings，点击进去 第三步：找到 GitHub Pages 一栏，切换 Source 的选项为 master branch 并点击 Save 第四步：保存后出现了链接，点击后复制浏览器地址栏的地址即为项目网页的地址 第五步：可以将链接放到 README 文件中供仓库的访问者预览效果 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小哥哥教你撸一个JS计算器]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%B0%8F%E5%93%A5%E5%93%A5%E6%95%99%E4%BD%A0%E6%92%B8%E4%B8%80%E4%B8%AAJS%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[计算器 Demo 估计会是很多移动端、网页前端新手最佳的第一个上手项目。话说之前学 Android 时从不觉得写个计算器 Demo 会有多难。然而上星期花了几天的时间用原生 JavaScript、CSS、HTML 写了一个计算器 Demo。然而就是这么一个小小的项目还是能让我学到挺多的东西，其中最让我受益的就是明白一个良好的架构对一个软件项目来说是有多么的重要！ 项目效果建议查看效果前去查阅仓库的 README 的 to-do list 在线计算器 GitHub：MyCalculatorDemo 项目详情请看 README 文件，同时欢迎各位 star，fork！ 移动端还没有适配，显示存在异常现象 项目背景其实一开始想要写个计算器 Demo 是源于看完《大话设计模式》的简单工厂模式的那一章节，看完之后就很想实践一下。刚好书中讲解工厂模式的例子举得就是计算器，因为书中是以 c++ 完成工厂模式的构造，于是乎自己就决定按照自己的理解看能不能用 JS 来实现。 项目主要分为 JavaScript 业务逻辑代码和 HTML 界面代码，JavaScript 业务代码主要是 OperationTypeFactory.js 和 SimpleCalculatorIndex.js。OperationTypeFactory.js 是运算类型对象，增加运算类型可在此增加对应运算对象。而 SimpleCalculatorIndex.js 负责运算的业务逻辑。Index.html 是界面代码。 Index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;计算器demo By刘志宇&lt;/title&gt; &lt;style type="text/css"&gt; html, body &#123; height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125; body &#123; padding: 0; margin: 0; background-color: #AFAFAF; font: 14px/1.5 Tahoma, "Lucida Grande", Verdana, "Microsoft Yahei", STXihei, hei; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; &#125; #total &#123; width: 100%; height: 100%; min-width: 300px; max-width: 640px; margin: 0 auto; overflow: hidden; background-color: #333; box-shadow: 0px 0px 5px 2px #555555; &#125; header &#123; width: 100%; height: 25%; box-sizing: border-box; /*border-bottom: 1px solid #000;*/ /*box-shadow: 0 0 10px #000 inset,0 0 15px #333;*/ &#125; header input &#123; display: block; color: #fff; text-shadow: 0 2px 1px rgba(0, 0, 0, 0.5); height: 50%; width: 100%; background-color: transparent; border: none; font-size: 45px; font-weight: bolder; text-align: right; margin: 0 -2%; &#125; main &#123; width: 100%; height: 75%; &#125; main ul &#123; list-style: none; padding: 0; width: 100%; height: 100%; cursor: pointer; &#125; main ul li &#123; width: 25%; height: 20%; float: left; color: #fff; font-size: 26px; text-align: center; border-left: 1px solid #000; border-top: 1px solid #000; box-sizing: border-box; /*text-shadow: 0 2px 1px rgba(0, 0, 0, 0.2);*/ &#125; main ul li:before &#123; display: inline-block; content: ""; height:100%; vertical-align:middle; &#125; .sign&#123; background-color: #f5923e; &#125; .FC&#123; border-left: 1px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="total"&gt; &lt;header&gt; &lt;input type="text" id="sum" value="" readonly&gt; &lt;input type="text" id="content" value="0" readonly&gt; &lt;/header&gt; &lt;main&gt; &lt;ul id="list"&gt; &lt;li class="sign FC" onclick="Main.onreset()"&gt;AC&lt;/li&gt; &lt;li class="sign" onclick="Main.inClick('d')"&gt;&amp;larr;&lt;/li&gt; &lt;li class="sign" onclick="compute('%')"&gt;mod&lt;/li&gt; &lt;li class="sign" onclick="compute('+')"&gt;+&lt;/li&gt; &lt;li class="num FC" onclick="Main.inClick(7)"&gt;7&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(8)"&gt;8&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(9)"&gt;9&lt;/li&gt; &lt;li class="sign" onclick="compute('-')"&gt;-&lt;/li&gt; &lt;li class="num FC" onclick="Main.inClick(4)"&gt;4&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(5)"&gt;5&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(6)"&gt;6&lt;/li&gt; &lt;li class="sign" onclick="compute('X')"&gt;&amp;times;&lt;/li&gt; &lt;li class="num FC" onclick="Main.inClick(1)"&gt;1&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(2)"&gt;2&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(3)"&gt;3&lt;/li&gt; &lt;li class="sign" onclick="compute('/')"&gt;&amp;divide;&lt;/li&gt; &lt;li class="num FC" onclick="Main.inClick('.')"&gt;.&lt;/li&gt; &lt;li class="num" onclick="Main.inClick(0)"&gt;0&lt;/li&gt; &lt;li class="num" onclick="Main.inClick('PI')"&gt;PI&lt;/li&gt; &lt;!--Math.PI--&gt; &lt;li class="sign" onclick="Main.display()"&gt;=&lt;/li&gt; &lt;!--&lt;li class="sign" onclick="compute('^')"&gt;x&amp;sup3;&lt;/li&gt;--&gt; &lt;!--&lt;li class="sign" onclick="compute('#')"&gt;&amp;radic;&lt;/li&gt;--&gt; &lt;!--&lt;li class="sign" onclick="compute('sin')"&gt;sin&lt;/li&gt;--&gt; &lt;!--&lt;li class="sign" onclick="compute('cos')"&gt;cos&lt;/li&gt;--&gt; &lt;/ul&gt; &lt;/main&gt;&lt;/div&gt;&lt;script src="scripts/OperationTypeFactory.js"&gt;&lt;/script&gt;&lt;script src="scripts/SimpleCalculatorIndex.js"&gt;&lt;/script&gt;&lt;script&gt; window.onload=function () &#123; alert("使用提示：使用时请完整输入运算表达式，运算结果将不保存！"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 界面部分&lt;body&gt;标签内主要分为计算器显示部分&lt;header&gt;和计算机输入部分&lt;main&gt;。其中按键界面是由&lt;ul&gt;无序列表构成。具体可看上面代码，这里比较简单，不一一细讲。 OperationTypeFactory.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133'use strict';//运算原型var Operation = &#123; first: 0, second: 0, result: 0&#125;;//各种运算对象var Add = &#123; get: function (num1, num2) &#123; var i = accurate(num1, num2); Operation.result = (num1 * i + num2 * i) / i; &#125;, __proto__: Operation&#125;;var Sub = &#123; get: function (num1, num2) &#123; var i = accurate(num1, num2); Operation.result = (num1 * i - num2 * i) / i; &#125;, __proto__: Operation&#125;;var Multi = &#123; get: function (num1, num2) &#123; var i = accurate(num1, num2); Operation.result = ((num1 * i) * (num2 * i)) / Math.pow(i, 2); &#125;, __proto__: Operation&#125;;var Div = &#123; get: function (num1, num2) &#123; if (num1 === 0) &#123; alert("被除数不能为0"); return; &#125; var i = accurate(num1, num2); Operation.result = ((num1 * i) / (num2 * i)); &#125;, __proto__: Operation&#125;;var Pow = &#123; get: function (num1, num2) &#123; Operation.result = Math.pow(num1, num2); &#125;, __proto__: Operation&#125;;var Sqrt = &#123; get: function (num1, num2) &#123; Operation.result = Math.sqrt(num1); &#125;, __proto__: Operation&#125;;var Sin = &#123; get: function (num1, num2) &#123; var a = (Math.PI / 180) * num1; Operation.result = Math.sin(a); &#125;, __proto__: Operation&#125;;var Cos = &#123; get: function (num1, num2) &#123; var b = (Math.PI / 180) * num1; Operation.result = Math.cos(b); &#125;, __proto__: Operation&#125;;var Mod = &#123; get: function (num1, num2) &#123; Operation.result = num1 % num2; &#125;, __proto__: Operation&#125;;//运算对象工厂var operationFactory = &#123; produce: function (math) &#123; switch (math) &#123; case '+': Main.computer = Add; break; case '-': Main.computer = Sub; break; case 'X': Main.computer = Multi; break; case '/': Main.computer = Div; break; case '^': Main.computer = Pow; break; case '#': Main.computer = Sqrt; break; case 'sin': Main.computer = Sin; break; case 'cos': Main.computer = Cos; break; case '%': Main.computer = Mod; break; &#125; &#125;, __proto__: Operation&#125;;//解决浮点数运算不精确问题function accurate(a1, a2) &#123; var n1 = 0, n2 = 0, m = 1; try&#123; n1 = a1.toString().split(".")[1].length; &#125;catch (e)&#123; &#125; try &#123; n2 = a2.toString().split(".")[1].length; &#125;catch (e)&#123; &#125; m = Math.pow(10, Math.max(n1, n2)); return m;&#125; Operation 对象保存的是参与运算的数值，而它的子类是各种各样的运算对象，其 get 函数逻辑各不相同。最后根据输入的符号新建一个运算对象。 SimpleCalculatorIndex.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302'use strict';//显示台对象var Main = &#123; isFirst: true, //用以判断当前输入环境是Operation.first还是Operation.second temp: 0, //输入数字的缓存 count: 0, //统计输入数字的次数 description: document.getElementById("sum"), //用来显示运算过程 out: document.getElementById("content"), //用来显示运算结果 formula: "", //用来记录运算表达式，以便输出到运算过程显示框 computer: 0, //运算实体对象 subCount: 0, //记录减号按键次数 addCount: 0, //记录加号按键次数 multiCount: 0, //记录乘号按键次数 divCount: 0, //记录除号按键次数 modCount: 0, //记录求模按键次数 subLocation: -1, //记录运算公式字符串中运算符号位置 dotAddress: -1, //记录小数点在数值字符串中的位置 dotFlag: false, //用以判断小数点按键是否按下 dotLocation: -1, //永久保存subLocation deleteTemp: 0, //永久保存存入Operation.first的temp值 deleteCount: 0, //永久保存存入Operation.first的count值 deleteDotAddress: -1, //永久保存存入Operation.first的dotAddress值 //inClick 函数接受计算器的数字输入 inClick: function (number) &#123; if (number === 'd') &#123; var last = this.formula.charAt(this.formula.length - 1); var fl = this.formula.length; if (last === '.' || last === '+' || last === '-' || last === 'X' || last === '/' || last === '%') &#123; switch (last) &#123; case '.': this.dotAddress = -1; this.dotFlag = false; break; case '+': this.addCount--; this.isFirst = true; this.temp = this.deleteTemp; this.count = this.deleteCount; this.dotAddress = this.deleteDotAddress; break; case '-': this.subCount--; if (fl === this.dotLocation + 1) &#123; this.isFirst = true; this.temp = this.deleteTemp; this.count = this.deleteCount; this.dotAddress = this.deleteDotAddress; &#125; break; case 'X': this.multiCount--; this.isFirst = true; this.temp = this.deleteTemp; this.count = this.deleteCount; this.dotAddress = this.deleteDotAddress; break; case '/': this.divCount--; this.isFirst = true; this.temp = this.deleteTemp; this.count = this.deleteCount; this.dotAddress = this.deleteDotAddress; break; case '%': this.modCount--; this.isFirst = true; this.temp = this.deleteTemp; this.count = this.deleteCount; this.dotAddress = this.deleteDotAddress; break; &#125; this.formula = this.formula.substring(0, this.formula.length - 1); this.description.value = this.formula; return; &#125; this.formula = this.formula.substring(0, this.formula.length - 1); this.description.value = this.formula; var f = this.temp % 10; f /= 10; this.temp = this.temp / 10 - f; --this.count; if (this.isFirst) &#123; Operation.first = this.temp; this.subLocation = this.formula.length; this.dotLocation = this.subLocation; &#125; else &#123; Operation.second = this.temp; &#125; &#125; else &#123; this.formula += number; this.description.value = this.formula; &#125; if (number === 'PI') &#123; if (this.isFirst) &#123; Operation.first = Math.PI; this.subLocation = this.formula.length; //保证记录的是第一个运算数的后面那个运算符 this.dotLocation = this.subLocation; &#125; else &#123; Operation.second = Math.PI; &#125; &#125; if (number === '.') &#123; this.dotAddress = this.count; this.dotFlag = true; &#125; if (typeof number === "number") &#123; if (this.count === 0) &#123; this.temp += number; &#125; else &#123; this.temp = this.temp * 10 + number; &#125; this.count++; if (this.isFirst) &#123; Operation.first = this.temp; this.subLocation = this.formula.length; this.dotLocation = this.subLocation; this.deleteTemp = this.temp; this.deleteCount = this.count; this.deleteDotAddress = this.dotAddress; &#125; else &#123; Operation.second = this.temp; &#125; &#125; &#125;, //该函数接受运算符号的输入 getOperation: function (math) &#123; //如果Operation.first是小数的话，在输入运算符号之前进行小数化 if (this.dotFlag) &#123; var mi = this.count - this.dotAddress; for (let i = 0; i &lt; mi; i++) &#123; this.temp /= 10; &#125; if (this.isFirst) &#123; Operation.first = this.temp; &#125; this.dotFlag = !this.dotFlag; &#125; this.formula += math; this.description.value = this.formula; //此时记录输入各个运算符号按键的次数 switch (math) &#123; case '+': Main.addCount++; break; case '-': Main.subCount++; break; case 'X': Main.multiCount++; break; case '/': Main.divCount++; break; case '%': Main.modCount++; break; &#125; //根据传入的运算符号进行输入环境的切换 if (math === '+' || math === 'X' || math === '%' || math === '^' || math === '/') &#123; this.isFirst = !this.isFirst; &#125; else if (math === '-') &#123; if (this.formula.charAt(this.subLocation) === '-') &#123; this.isFirst = !this.isFirst; this.subLocation = -2; //防止减号运算和第二个运算数也为负数的矛盾 &#125; &#125; this.count = 0; this.temp = 0; this.dotAddress = -1; &#125;, //该函数负责运算结果的计算以及显示 display: function () &#123; //如果第二个运算数为小数的话，在此进行小数化 if (this.dotFlag) &#123; var m = this.count - this.dotAddress; for (let i = 0; i &lt; m; i++) &#123; this.temp /= 10; &#125; if (this.isFirst) &#123; Operation.first = this.temp; &#125; else &#123; Operation.second = this.temp; &#125; this.dotFlag = !this.dotFlag; &#125; //计算之前首先根据各运算符按键次数判断运算逻辑 if (this.subCount === 1) &#123; if (this.addCount != 0 || this.multiCount != 0 || this.divCount != 0 || this.modCount != 0) &#123; if (this.formula.charAt(0) === '-') &#123; Operation.first = Operation.first * (-1); &#125; else &#123; Operation.second = Operation.second * (-1); if (this.addCount === 1) &#123; operationFactory.produce('+'); &#125; if (this.multiCount === 1) &#123; operationFactory.produce('X'); &#125; if (this.divCount === 1) &#123; operationFactory.produce('/'); &#125; if (this.modCount === 1) &#123; operationFactory.produce('%'); &#125; &#125; &#125; else &#123; operationFactory.produce('-'); &#125; &#125; else if (this.subCount === 2) &#123; if (this.addCount != 0 || this.multiCount != 0 || this.divCount != 0 || this.modCount != 0) &#123; Operation.first *= (-1); Operation.second *= (-1); if (this.addCount === 1) &#123; operationFactory.produce('+'); &#125; if (this.multiCount === 1) &#123; operationFactory.produce('X'); &#125; if (this.divCount === 1) &#123; operationFactory.produce('/'); &#125; if (this.modCount === 1) &#123; operationFactory.produce('%'); &#125; &#125; else &#123; if (this.formula.charAt(0) === '-') &#123; Operation.first *= (-1); &#125; else &#123; Operation.second *= (-1); &#125; &#125; &#125; else if (this.subCount === 3) &#123; Operation.first *= (-1); Operation.second *= (-1); &#125; this.formula += '='; this.description.value = this.formula; this.computer.get(Operation.first, Operation.second); this.out.value = Operation.result; this.count = 0; this.temp = 0; this.formula = ""; this.subLocation = -1; this.addCount = 0; this.subCount = 0; this.multiCount = 0; this.divCount = 0; this.modCount = 0; this.deleteCount = 0; this.deleteTemp = 0; this.dotLocation = -1; if (this.isFirst === false) &#123; this.isFirst = !this.isFirst; &#125; &#125;, onreset: function () &#123; Operation.first = 0; Operation.second = 0; Operation.result = 0; this.isFirst = true; this.count = 0; this.temp = 0; this.formula = ""; this.out.value = 0; this.description.value = ""; this.dotFlag = false; this.subLocation = -1; this.dotAddress = -1; this.subCount = 0; this.addCount = 0; this.multiCount = 0; this.divCount = 0; this.modCount = 0; this.deleteCount = 0; this.deleteTemp = 0; this.dotLocation = -1; &#125;&#125;;//同时向显示台对象和运算对象工厂传入运算类型参数function compute(math) &#123; Main.getOperation(math); operationFactory.produce(math);&#125; 最重要的是此计算业务逻辑代码。在这里处理输入的数字和符号去获得结果并显示出来。Operation.first 和 Operation.second 是进行运算的两个运算值，Operation.result 是运算的最终结果。而 Operation.first 和 Operation.second 是由传入的数字按键直接赋值，因此未进行处理前都是正整数。而处理小数点、负号、退位按键都是在此正整数的基础上操作而来，这也是此项目中的重点难点。我这里大概讲一下处理这三个难点的逻辑思路：小数点是每次输入完数字之后按下操作运算符号按键（除数字按键之外的按键）时根据之前记录的小数点的位置，将正整数进行一系列数学运算之后修正为正确的数值；负号处理是在最后按键等号按键时根据此前记录各个运算按键的按下次数去判断按下的负号是代表减法运算的运算符号、还是代表为第一个运算值的负号或者第二个运算值的负号、或者是代表两个运算值的负号、还有可能是两个负数进行减法运算。判断完毕后再对此前的两个运算值进行修正；退位是在判断输入按键为退位按键时根据当时按下退位按键时运算表达式的最后一个字符进行相对应处理。比如运算表达式最后一个为数字字符，则简单进行数值修正。而如果运算表达式最后一个为非数字字符则要进行对应的逻辑操作，比如切换输入环境。 由于这三个难题的处理步骤处在不同操作中，耦合性较低。因此也较容易理解业务逻辑，同时上面也标注上对应的注释，方便大家理解。 最后这是我第一次较为完整的撸完一个相对简单的项目，同时写这个计算器 Demo 之前我也没有参考过其他优秀的计算器项目的源码，因此肯定还存在不合理的地方，欢迎各位大牛提出宝贵意见。同时如果各位阅读代码过程中有疑问可以提出来，我会认真回答各位问题，这也是帮助我提高编程能力的途径之一。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>项目实例</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的原型及原型链]]></title>
    <url>%2F2017%2F08%2F04%2F%E8%B0%88%E8%B0%88JavaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 一文中我们提到了在没有类概念的 JavaScript 语言中是通过原型来实现面向对象的继承特性。只要运用得好，这种基于原型的 JavaScript 继承模型比传统的类继承还要强大。所以我们还需详细学习一下原型的知识 JavaScript 的对象JavaScript 是基于对象的面向对象语言。因此在这里的“对象”既可以是普通对象（Object），也可以是函数对象（Function）。JS 抛弃了 Java 的类概念，而 Java 的继承恰恰是通过类来实现的。那么 JS 没有类的概念，就使用了“原型”的概念来实现继承。 字面量原型及原型链JS 可通过字面量构造对象。为了实现继承，对象里面有个_proto_属性可以指向该对象的父对象。这个父对象就是所谓的“原型”。 123456789101112131415161718192021var animal = &#123; name: '动物', eat: function()&#123; console.log(this.name + " is eating"); &#125;&#125;;animal.eat(); // animal is eatingvar dog = &#123; name: '狗', _proto_: animal&#125;;var cat = &#123; name: '猫', _proto_: animal&#125;;dog.eat(); // 狗 is eatingcat.eat(); // 猫 is eating 由上面代码我们可以看出：dog 和 cat 对象的原型都是 animal。但是 dog 和 cat 对象都没有定义 eat()方法，那怎么可以调用呢？其实当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。这几个对象通过_proto_属性建立一个原型链！ 构造函数原型及原型链但是为了迁就 C++、Java、C# 程序员，让 JavaScript 可以像 Java 那样 new （构造）出一个对象出来，于是这里做了一个变通，也提供了构造函数。例子如下： 1234567891011121314151617function Student(name,grade)&#123; this.name = name; this.grade = grade; this.sayHello = function()&#123; console.log('Hi,I'm ' + this.name); &#125;&#125;andy = new Student('Andy',5);lisa = new Student('Lisa',5);andy.sayHello(); //Hi,I'm Andylisa.sayHello(); //Hi,I'm Lisa //假设 andy 和 lisa 是同班同学，同时即将升入六年级andy.grade = 6;console.log(andy.grade); // 6console.log(lisa.grade); // 5 由上面的代码所示，我们可以看出这个所谓的构造函数已经很有 Java 类的感觉了。但是这里面存在两个问题：在对象里面定义方法，这样每创建一个对象都会一个sayHello()函数，这样来说显得对象臃肿，浪费资源；同时每个对象各自保有自己的属性和函数的副本，无法做到属性和方法共享。因此，这里有一个更加高效的办法就是把对象共享的属性和方法可以放到 Student.prototype 这个对象当中。如下： 123456789101112131415161718192021222324252627function Student(name)&#123; this.name = name;&#125;Student.prototype = &#123; grade: 5, sayHello: function()&#123; console.log(&quot;Hi, I&apos;m &quot;+this.name); &#125;&#125;;/*也可以写成Student.prototype.grade = 5;Student.prototype.sayHello = function()&#123; console.log(&quot;Hi, I&apos;m &quot;+this.name);&#125;;*/var andy = new Student(&quot;Andy&quot;);var lisa = new Student(&quot;Lisa&quot;);andy.sayHello(); //Hi, I&apos;m Andylisa.sayHello(); //Hi, I&apos;m LisaStudent.prototype.grade = 6;console.log(&quot;Andy&apos;s grade: &quot;+ andy.grade); // 6console.log(&quot;Lisa&apos;s grade: &quot;+ Lisa.grade); // 6 由上面的代码和示意图可看出这个所谓的构造函数 Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（ andy 或者 lisa ) ， 并且把这个对象的原型指针(_proto_)指向 Student.prototype 这个对象，这样一来就能找到sayHello()方法了。我们应该还知道上面的构造函数Student()对象（JS 中函数也是对象）会创建一个 prototype 对象（Student.prototype），而 new 出来的实例对象例如 andy 和 lisa 是没有这个 prototype 对象，但是他会有个 proto 属性（_proto_）指向这个构造函数对象的 prototype 对象，从而构成原型链。实例对象其实是通过原型对象与构造函数取得联系的。为了让 Java、C#、C++ 程序员降低学习成本，JavaScript 提供了语法糖： 1234567891011class Student &#123; constructor(name)&#123; this.name = name; &#125; sayHello()&#123; console.log("Hi, I'm "+this.name); &#125;&#125;var andy = new Student("andy"); andy.sayHello(); //Hi, I'm andy Object.create()123456var a = Object.create(null);console.log(a); //&#123;&#125;a.name = 'Zhiyu';var b = Object.create(a);console.log(b); //&#123;&#125;console.log(b.name); //Zhiyu 上面我们可以看出该方法是创建一个空对象，空对象的原型是create()参数。此时创建的空对象会有个(_proto_)属性指向方法参数，这样也可以构成一个原型链。 总结 JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _ _proto__ 的内置属性，用于指向创建它的函数对象的原型对象 prototype 原型和原型链是 JS 实现继承的一种模型 原型链是靠 proto 形成的，而不是 prototype 所有的原型对象都有 constructor 属性，该属性对应创建所有指向该原型的实例构造函数 函数对象和原型对象通过 prototype 和 constructor 属性进行相互关联 参考 javascript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ Javascript 深入浅出原型 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ ​]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中的this关键字]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java 语言当中也有this关键字，而 JavaScript 语言当中的this关键字因为具有运行期绑定的特性，JS 当中的这个this关键字的含义要丰富的多。现在来看看这个this到底有啥奥秘…… 运行环境this关键字指定的对象具体是指什么，这完全取决于函数的调用方式，JavaScript 中的函数的调用有以下几种方式： 作为函数调用 作为对象方法调用 作为构造函数调用 作为函数调用12345var n = "Hello World!";function example()&#123; console.log(this.n);&#125;example(); //Hello World! 123456var n = 'Hello World!';function example()&#123; this.n=0;&#125;example();console.log(n); //0 我们通过上面的两个例子，我们可以明确知道：当函数直接调用时，该函数的this关键字指向的就是全局对象window。此时上面例子的全局变量n其实就是window.n。 作为对象方法调用12345678910111213141516function getAge()&#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;console.log(xiaoming.age());//27console.log(getAge()); //NaNvar fn = xiaoming.age;console.log(fn()); //NaN 123456789101112var name = 'Akita';var dogs = &#123; name:'Collie', showName: function()&#123; console.log(this.name); &#125;&#125;;console.log(dogs.showName()); //Collievar otherNmae = dogs.showName;console.log(otherName()); //Akita 如上面所示代码，当使用obj.xxx()的形式调用函数时，里面的this关键字指向的就是对象本身。但是我们还需要注意一点就是：在对象方法内部再次定义一个方法，该方法的this关键字又会重新指向全局对象window！如下代码所示： 12345678910111213var xiaoming = &#123; name: '小明', birth: 1990, age: function()&#123; function getAgeFromBirth()&#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;console.log(xiaoming.age()); //NaN 由于这是 JavaScript 一个巨大的设计错误。ECMA 决定在 strict 模式下（就是开头声明&#39;use strict&#39;;）让函数的this指向undefined。因此，在 strict 模式下你会得到的错误就不是 NaN，而是TypeError：Cannot read property &#39;birth&#39; of undefined。 作为构造函数调用12345function Student(name)&#123; this.name=name;&#125;var xiaoming = new Student('小明');console.log(xiaoming.name); //小明 上面这段代码中我们通过构造函数构造了一个新的对象xiaoming，那么this就会指向这个对象。 指定 this 指向虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25 此时利用apply()将getAge()的this指向了xiaoming这个对象，因此函数执行正确。 参考 方法 - 廖雪峰的官方网站 Javascript 深入浅出this 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ ​]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript王国之函数教主]]></title>
    <url>%2F2017%2F07%2F30%2FJavaScript%E7%8E%8B%E5%9B%BD%E4%B9%8B%E5%87%BD%E6%95%B0%E6%95%99%E4%B8%BB%2F</url>
    <content type="text"><![CDATA[本篇是JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？的续集 来源：码农翻身 微信公众号 作者：刘欣 原文地址：javascript王国之函数教主 前言本篇由BlindingDark撰写， 老刘修改，原文参见 http://www.jianshu.com/p/74120c8ec56a 拜函数教Java 小王子在 JavaScript 王国待了也有一段时间，这里虽然不像 Java 帝国那样规范严苛，但也因此千奇百怪，五光十色。 要说小王子最喜欢待的地方，那还是人来人往的 JSON 酒馆，不仅有上好的酒菜，还有机会认识到各式各样的人。这不，一来二去他已经和上回认识的眼镜官员成了朋友，甚至私底下还称兄道弟的。 这一天小王子又和眼镜大哥一起约来吃酒。才寒暄了几句，筷子还没动，酒馆门口就发生了一点骚动。只见来了一位看起来像是教书先生的精瘦男子，旁边还有些随从。 “…… 大哥，这人什么来头，气度不凡啊。”小王子悄声向旁边的眼镜官员问到。 “哈哈，他是拜函数教的邱大教主，最近他们教派的信众激增啊，真是风水轮流转。” “函数式？以前随父亲经商途中是听说过他们的事情，好像非常古老而且高深莫测啊，据说只有学者和虔诚的教徒才会加入他们，怎么最近也接收新人了？” “小弟果然是见多识广，不错，在很久以前的确是这样，不过为何有大批新教徒这种事情也不在我的管辖范围内啊，所以也不太清楚。但是毕竟我是本国语言规范审查官，还是与他打过一些交道。不妨我们邀请他来一起喝酒，你亲自问他。” 小王子本来听到眼镜大哥也不了解情况正有些失望，突然得知可以直接面对面打探对方的底细，顿时兴奋了起来。 “那太好了！” “这不是眼镜老弟么，别来无恙啊。” “主教兄，甚好甚好，要不这顿我请？小二！” 饭菜上桌，互相客套了几句之后，话题就开始了。 “主教兄，这是我最近认识的朋友，年纪轻轻就周游四方，他有些事情要问你。” “哦？”函数式主教把目光放了过来，“有何见教？” “久闻贵教派向来神秘，为何最近有如此多的新教徒加入呢？” “哈，这个嘛 … 现在的年轻人都不喜欢条条框框，本教向来以简洁强大著称，自然就受欢迎了。” 小王子心想，这个教主倒也是有话直说、自卖自夸，不过难道没了面向对象这种强大的武器，他还能变出怎么样的花儿来？ “那还敢请教教主大人，依你看要怎么实现 Animal, Cat, Dog 这些对象呢？”想了一会儿，小王子认为不如直接发问。 “这个嘛，本教派并无对象这种说法，不过如果你愿意，也可以构造一个对象出来，只需要……” “我们拜函数教不用对象～”，还没等着主教说完，旁边的妹子突然发话了。 “哦，小兰，你来说吧。”这位被叫做小兰的少女像是主教的助手，看起来深得主教信任。 “嘻嘻，教主大人说的太复杂了，其实实现你说的那些根本不用什么对象。” “哦？那该怎么做？”小王子顿时来了兴趣。 函数是一等公民“你想啊，搞出来这些猫啊狗啊的，不就是想让他们都可以吃东西么？干嘛要封装到一个对象中，太压抑了” 哦！Java 小王子恍然大悟，在自己的Java帝国，法律非常严格， 类和对象才是一等公民， 函数是不可能独立存在的， 你即使是想输出一个简单的hello world , 也必须写一个类，在类中写一个方法 ， 在这个方法中才能输出hello world 。 在这里函数已经翻身做主人，成为了一等公民，再也不用困在对象的牢笼中，声明后就可以直接使用。 “也就是说，猫、狗都可以直接拿来调用咯？” “是的呢～ 不止是猫、狗，连人都能作为参数调用呢， 只要一个对象有name这个属性就行啊”小兰的脸上还是一样的笑容。 长期在一个强类型的语言中生活，小王子对这种有点“变态”的灵活性还真不习惯， 他说：“在Java帝国，方法的参数都有确定的类型，如果你的方法写错了，IDE就能自动帮你检测， 减少了很多错误，现在可就没这种福利了。” “有得必有失嘛”小兰笑道 “你可以多写一点单元测试来保证正确性啊” “既然函数是一等公民， 我相信它不止这点能耐吧？“ “那是自然， 我们这里的函数还可以作为参数传递给另外一个函数呢！” 小王子突然想到父王给自己讲过，要在Java8中引入函数式编程， 可以把一个所谓的lambada 表达式传递给另外一个函数， 省去了创建类或匿名类的开销。 但是宫廷老师偷偷地告诉过自己：“那只是半吊子的函数式编程，每个lambda表达式其实还得和一个函数接口相匹配， JDK在背后做了类型的推断” （微信公众号码农翻身注： 参见文章《Java帝国之函数式编程（上）》和《Java帝国之函数式编程（下）》） “函数既然能作为参数，我猜肯定也能作为返回值吧？” 小王子觉得拜函数教的邱大教主在场， 这个天真活泼的小兰好像不敢给自己透露太多， 只好主动发问。 “你这个外乡人很聪明嘛， 估计有不少编程基础吧？” 小兰又展示了一段代码： 果然和自己的猜想一致！ 作为皇族，小王子确实非常聪明，他很快就想到了另外一个问题： 如果内部的eat函数访问了外部函数的变量会发生什么状况？ 按照我们 Java 帝国的理论， 函数在被调用的时候是以栈帧的方式被压入栈中的， 函数的局部变量也在栈帧当中， 当这个函数返回，对应的栈帧就会被清除，局部变量自然也不可用了。 现在这个eat函数还能再使用createEatFunction()函数的desc这个变量吗？ 或者在调用它的时候会使用外边的全局desc 变量？ 从而输出 “dog 正在吃东西”? 函数作为返回值看起来很美， 但细节着实让人费解啊？ 闭包看到小王子像上次一样又“卡”住发呆了， 眼镜官员笑着对主教和小兰说： 这小子肯定又在深思了。 小兰说：“这个外乡人确实不一般，思考很深入，让他的CPU再运转一会儿吧” 小王子没有找到答案，从思考中回来，看到大家都盯着自己看，有点不好意思， 把疑惑给大家说了。 “外乡人，Java 把你毒害得不浅， 我看你资质不错，不如忘掉Java 那丑陋的模型， 加入到我们拜函数教来吧。 将来你继承我的位置也未可知啊！” 邱大教主看了小兰一眼，意味深长地说。 小兰接口说：“还是先解释下你的疑惑吧， 你那段代码的输出应该是‘dog is eating’ , 而不是 ‘dog 正在吃东西’” 小王子说： “这我猜到了， 我就是不理解一个函数(createEatFunction)都执行完了, 为什么它的变量(desc)还能被 后面执行的函数(eat)来使用。” “要不说你的java毒中的很深啊， 你换个角度想想，局部变量在函数执行完以后还可以被访问， 那它肯定不能存在于你说的那个什么java栈帧中。” 小兰说。 “那它放在那里？” “在JavaScript 当中，有个作用域链(scope chain)的东西，它定义了一个函数激活执行的时候去哪儿找变量的值， 比如eat函数的作用域链是这样的：” （微信公众号码农翻身注： 此图只是示意图，并不严谨，例如没有表达出Activation object， Variable Object等概念） 小王子看着这个图，马上就明白了，这个eat函数没有定义desc 这个变量， 所以就沿着链去查找， 在createEatFunction作用域去查找，如果还找不到，就到global 作用域中查找…… 这个例子中，在createEatFunction的作用域中有定义，于是就直接使用了。 “可是 ”小王子不服气地说 “createEatFunction 已经执行完了， 难道它的desc 变量不删除吗？” “那肯定不能删除喽” 小兰说 “这里和你熟悉的java 有个重要的不同， 当你执行creatEatFunction的时候， eat函数才会被创建出来，此时eat函数就会把外部函数的作用域链记录下来（其中包含desc=’ is eating’)，以便执行时使用” “奥，这个作用域是在函数创建时刻发生关联的，而不是运行时刻” “没错， 这叫做静态作用域(static scope)，或者叫词法作用域（lexical scope）。当eat函数被激活执行，就可以在createEatFuncction中找到desc的值，而不是在全局中找到desc的值。 ” 小兰接着说，“我再给你看个例子， 你就理解这个静态作用域了” 小王子说： “这段代码的输出应该是2 啊， 还有什么可说的，哦，不对不对，应该输出1， 静态作用域！ 函数foo在创建的那一刻， 已经确定了它会和包含x=1的全局作用域关联 , 所以在运行的时候也只会从全局作用域查找，而不是从bar 函数的作用域中找x ” “看来你已经Get到了， 这个静态作用域是实现闭包的一个必需条件， 你听说过闭包吧？” 小王子说： “我听父王说过，但是不知道怎么回事….” 小王子说漏了嘴，赶紧打住。 小兰像没有听到一样，继续讲闭包：“闭包在JavaScript当中就是一个函数和以静态方式存储的父作用域的一个集合体，通过这个集合体，一个函数就可以访问外部函数的变量了。 ” “所以eat函数就可以访问外部函数的变量了！ 闭包这个名称有点古怪，不过背后的概念还是比较清晰的” 小王子赶紧说。 尾声“咳咳，小莱你够了。客人都被你吓到了。”这时，在旁边默默看着的邱大教主说话了。 经过这一番交谈，小王子震惊于函数式的独特之处，尤其是和Java帝国的不同。 不过毕竟是皇族，阅历丰富，他还是悟出了一点门道，“我大概明白了一点，由于 JavaScript 是动态类型，其实无论是函数还是对象，在这里都可以做为一个值来传递。函数式里面偏向对值直接进行处理，通过对这些值的传递和组合，就可以组装实现更高级的功能。” “不错不错，我看你这位朋友的来头可不一般啊，新加入的信徒大多都经过漫长的适应期才能理解，他却立即悟出这些道理来。”邱大教主对小王子赞赏有加，或许以他的智慧已经识破了小王子的身份。 “不不不，还是因为小兰妹妹讲的好啊。”小王子脸红的说道。 “这还不是多亏了我们的原型才能自由灵活的实现各种编程范式么。”眼镜大哥也参合了起来。 “哈哈哈，你又在自夸了。” “来，说了这么多 eat，不说了，吃菜吃菜～” 看来编程世界上还有这么多种形态，小王子下次要去哪里，又会见识到怎样的东西呢？或许也能给他的 Java 帝国带回一些新鲜的血液？ 附 登场人物名： 小兰 == lambda 邱大教主 == 阿隆佐.丘齐(Alonzo Church) Lambda演算发明人]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式之简单工厂模式]]></title>
    <url>%2F2017%2F07%2F28%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[想起之前学 Android 开发和 Java 开发的时候发现框架的出现能大大提高开发效率。如今学习 Web 前端开发的时候发现前端框架更加丰富。那研究各式各样的框架就成为了挺重要的学习部分，我一位学计算机的高中同学介绍说“框架是设计模式的一次实战应用”。所以这又扯到了设计模式，那什么是设计模式，后面我们将慢慢介绍各种各样有趣的设计模式 大话设计模式人物及背景 小菜：准码农一枚，正求职找工作 大鸟：小菜表哥，大学毕业后长期从事软件开发和管理工作，与小菜同住一起 什么是设计模式码农翻身作者刘欣曾在他的公众号推送给设计模式说句公道话说过 设计模式是什么东西？ 简单来讲就是久经考验的、在面向对象设计领域的成功经验的总结 因为自从上世纪70年代高级语言发展到面向对象阶段，这中间接近六十年的时间你可以想象有多少应用会被开发出来，这中间开发人员得积累了多少的经验教训。而设计模式就是这半个多世纪那些开发大牛对血与泪教训的经验总结。我同时认为，这些经验总结不单单只是程序开发经验的总结，而是取自于现实社会生活，但同时也能反哺现实生活的一种经验性知识。正因为是取自于现实社会生活，才有了如工厂模式、观察者模式、中介者模式、代理模式等如此生活化的命名方式。而 OO 语言的指导思想就是希望能够以现实人类求解日常问题的思维方法去求解软件开发的问题，那么开发出来的软件不仅容易被人理解，而且易于维护和修改，从而会保证软件的可靠性和可维护性，并能提高公共问题域中的软件模块和模块重用的可靠性。所以学习并学会合理使用设计模式就显得尤其重要了！好，下面开讲第一课！ 面试受挫小菜今年计算机专业大四了，学了不少软件开发的知识，对自己的技术能力也信心满满。这不，他自信地在各大招聘网站投下自己的简历，希望能谋得一份不错的开发工作。投递结果也如小菜预计的一样，各大公司、单位陆陆续续向他发送了面试通知。到了人家单位，前台小姐姐给了他一份题目，上面写着：“请用 C++、Java、C# 或 VB.NET 任意一种面向对象语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。”小菜心想：“这还不简单！”，三下五除二。不到一会儿就写完了，觉得也没错误，就交了卷。交卷时前台小姐姐面带微笑地说道“请回去等待进行下一轮面试的通知吧”。于是小菜只得耐心等待，可是半个月过去了，什么消息也没有，小菜很苦闷，便向他已经从事软件开发工作七年的表哥大鸟讨论可能的原因。大鸟问了题目和了解了小菜代码的细节以后，撇起嘴角，说道“小菜呀，你是真不明白吗？人家单位出题的意思，你完全都没明白，当然不会再联系你了。”这时小菜更加郁闷了，觉得自己代码应该能完美运行，越想越想不明白的小菜郁闷的看着大鸟。大鸟苦笑的指着他写下的代码： 12345678910111213141516171819202122class Program&#123; static void Main(string[] args)&#123; Console.Write(&quot;请输入数字A：&quot;); string A = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string B = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string C = Console.ReadLine(); string D = &quot;&quot;; if (B == &quot;+&quot;) D = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C)); if (B == &quot;-&quot;) D = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C)); if (B == &quot;*&quot;) D = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C)); if (B == &quot;/&quot;) D = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C)); Console.WriteLine(&quot;结果是：&quot; + D); &#125;&#125; 大鸟一一的揪出了代码中不如意的地方。比如命名不规范、没有对用户输入情况做判断、判断分支的写法效率不够高。“哦，说的没错，这个我以前听老师说过，可是从来没有在意过，我马上改，改完你再看看”小菜说道。 123456789101112131415161718192021222324252627282930313233343536class Program&#123; static void Main(string[] args)&#123; try&#123; Console.Write(&quot;请输入数字A：&quot;); string strNumA = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string strOperation = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string strNumB = Console.ReadLine(); string strResult = &quot;&quot;; switch (strOperation)&#123; case &quot;+&quot;: strResult = Convert.ToString(Convert.ToDouble(A) + Convert.ToDouble(C)); break; case &quot;-&quot;: strResult = Convert.ToString(Convert.ToDouble(A) - Convert.ToDouble(C)); break; case &quot;*&quot;: strResult = Convert.ToString(Convert.ToDouble(A) * Convert.ToDouble(C)); break; case &quot;/&quot;: if (strNumB != &quot;0&quot;)&#123; strResult = Convert.ToString(Convert.ToDouble(A) / Convert.ToDouble(C)); &#125;else&#123; strResult = &quot;除数不能为0&quot;; &#125; break; &#125; Console.WriteLine(&quot;结果是：&quot; + strResult); Console.ReadLine(); &#125;catch(Exception ex)&#123; Console.WriteLine(&quot;您的输入有错：&quot; + ex.Message); &#125; &#125;&#125; 大鸟接过小菜写下的代码，摇摇头着说道“目前这代码实现计算器没有问题，但这样写出的代码是否符合出题人的意思呢？” 面向对象活字印刷，面向对象大鸟沉寂了一会，突然拍着小菜的肩膀说“你还记得我们古代四大发明之一的活字印刷术吗？”小菜菜点点头。“那你还知道活字印刷术发明之前民间常用的雕版印刷术吗？”这是小菜摇摇头。大鸟说道“雕版印刷术就是印书的时候，先用一把刷子蘸了墨，在雕好的板上刷一下，接着，用白纸覆在板上，另外拿一把干净的刷子在纸背上轻轻刷一下，把纸拿下来，这样一页书就印好了。那如果万一这时发现文章写的不对，需要改，那就只能为了一处的错误而去重新雕刻整块印刷板。而活字印刷术的出现就刚刚好解决了这个问题，只需把文章中的字体一个个分别雕刻出来，等后面印刷成页的时候进行排版就行了，如果需要更改，就只需要在排版的时候更改顺序。同时雕刻的单个字体还可以重复使用，还可以根据情况对文章增删内容。这样岂不是比之前方便多了！” 大鸟接着说道“开发程序也应该如此——可维护、可复用、可扩展。而在活字印刷术出现之前，要修改，必须重刻，要加字，必须重刻，要重新排列，必须重刻，印完一页后，此版已无任何可再利用价值。其实雕版印刷术的问题就在于所有的字都刻在同一版面上，按计算机专业的概念来理解，就是耦合度太高。而利用封装、继承、多态把程序的耦合度降低，将使程序更加灵活，容易修改，并且易于复用。” 业务的封装大鸟：“讲了那么多，你觉得之前那道题目你有什么想法吗？” 小菜：“我好像懂了一点，你刚才说的面向对象目的就是降低耦合度。刚才我写的代码的确还是有不合理的地方。比如代码逻辑中，既有计算逻辑也有控制台显示逻辑。这样就不利于代码的复用，维护，扩展。“ 大鸟：“不错，那你试试按你的刚才的想法去修改一下的你的代码” 小菜：“那我试试！” 123456789101112131415161718192021//Operation 运算类public class Operation&#123; public static double GetResult(double numberA,double numberB,string operation)&#123; double result = 0d; switch (operation)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; &#125; return result; &#125;&#125; 123456789101112131415161718//控制台显示类static void Main(string[] args)&#123; try&#123; Console.Write(&quot;请输入数字A：&quot;); string strNumA = Console.ReadLine(); Console.Write(&quot;请选择运算符号（+、-、*、、）：&quot;); string strOperation = Console.ReadLine(); Console.Write(&quot;请输入数字B：&quot;); string strNumB = Console.ReadLine(); string strResult = &quot;&quot;; strResult = Convert.ToString(Operation.GetResult(Convert.ToDouble(strNumA), Convert.ToDouble(strNumB),strOperation)); Console.WriteLine(&quot;结果是：&quot;+strResult); Console.ReadLine(); &#125;catch(Exception ex)&#123; Console.WriteLine(&quot;您的输入有错：&quot;+ex.Message); &#125;&#125; 小菜：“写好了，你看看！” 大鸟：“不错，这样就完全把业务和界面分离了。你现在在其他平台上写计算器的应用，就可以复用这个运算类了。但你现在只用了面向对象三大特性中的一个，还有两个没用呢？” 小菜：“面向对象三大特性不就是封装、继承和多态吗，这里我用到的应该是封装。我觉得一个个小小的计算器程序不至于用到继承和多态吧。” 大鸟：“你看来 too young too naive！” 继承和多态第二天。 小菜问道：“你说计算器这样的小程序还可以用到面向对象三大特性？继承和多态怎么可能用得上，我实在理解不了。我已经把业务和界面分离了，这不是很灵活了吗？” 大鸟：”那我问你，现在如果希望增加一个开根（sqrt）运算，你如何改？“ 小菜：”那只需要改 Operation 运算类就行了，在 switch 中加一个分支就行了。” 大鸟：“那万一你不小心改错了呢。这么说吧，如果公司把某个算法类交个你去做修改，结果一不小心改错了，结果还可能影响到了其他原有的代码。这样本来只是让你增加一个功能，却使得原有的运行良好的功能代码产生了变化，这个风险太大了 。你明白吗？“ 小菜：“哦，你的意思是我应该把加减乘除运算分离，修改其中一个不影响另外的几个，增加运算算法也不影响其他代码。” 大鸟：“对，如何用继承和多态，你应该有感觉了。” 小菜：“OK，我马上去写。” 1234567891011121314151617//Operation 运算类public class Operation&#123; private double _numberA = 0; private double _numberB = 0; public double NumberA&#123; get &#123;return _numberA;&#125; set &#123;_numberA = value;&#125; &#125; public double NumberB&#123; get &#123;return _numberB;&#125; set &#123;_numberB = value;&#125; &#125; public virtual double GetResult()&#123; double result = 0; return result;&#125; 加减乘除类 12345678910111213141516171819202122232425262728293031323334class Add : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA + NumberB; return result; &#125;&#125;class Sub : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA - NumberB; return result; &#125;&#125;class Multi : Operation&#123; public override double GetResult()&#123; double result = 0; result = NumberA * NumberB; return result; &#125;&#125;class Div : Operation&#123; public override double GetResult()&#123; double result = 0; if (NumberB==0)&#123; throw new Exception(&quot;除数不能为0&quot;); &#125; result = NumberA / NumberB; return result; &#125;&#125; 大鸟：“写的不错，但是问题来了你如何让计算器知道我是希望用哪一个算法呢？” 小菜：“是哦，我还没考虑到。” 简单工厂模式大鸟：“你现在的问题其实就是如何根据用户去实例化运算类的问题。解决这个问题可以用’简单工厂模式‘，也就是说到底要实例化谁，将来会不会增加实例化的对象，比如上面提到的开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造运算实例的过程，这就像我们生活当中会的工厂，共同点都是生产某一样特定的东西。那么这个类就叫做工厂类！” 123456789101112131415161718192021//简单运算工厂类public class OperationFactory&#123; public static Operation createOperation(string operation)&#123; Operation oper = null; switch (operation)&#123; case &quot;+&quot;: oper = new Add(); break; case &quot;-&quot;: oper = new Sub(); break; case &quot;*&quot;: oper = new Multi(); break; case &quot;/&quot;: oper = new Div(); break; &#125; return oper; &#125;&#125; 大鸟：“看看代码，这样的话你只需要输入运算符号，工厂实例化出合适的对象，通过多态，返回父类的方式实现了计算器的结果。” 123456//实现加法运算过程Operation oper;oper = OperationFactory.createOperation(&quot;+&quot;);oper.NumberA = 1;oper.NumberB = 2;double result = oper.GetResult(); 大鸟：“现在就是比较完整的计算器程序了。复用性，可维护性，可扩展性都不错。如果某一天需要更改加法运算，我们只需要更改 Add 类。增加其他各种运算，比如取对数，正弦余弦，就只要增加相对应的运算类即可。同时还要记得去工厂做一下”备注“-在工厂类 switch 增加对应的分支。是不是很不错啊。“ 小菜：”厉害了我的哥，我服。看来我还是 too young too naive!“ 大鸟：“就你嘴能，来我们最后看看这几个类的结构图总结一下。” 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？]]></title>
    <url>%2F2017%2F07%2F25%2FJavaScript%E7%8E%8B%E5%9B%BD%E7%9A%84%E4%B8%80%E6%AC%A1%E6%97%85%E8%A1%8C%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E7%B1%BB%E7%9A%84%E4%B8%96%E7%95%8C%E6%80%8E%E4%B9%88%E7%8E%A9%E8%BD%AC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[没有学习前端开发之前，一直以为 JavaScript 跟 Java 有亲缘关系，等了解了 JS 之后才发现原来半毛钱关系都没有。有一次我问一位我的高中同学，他专业是软件工程。我问他“Java 是面向对象语言，C 是面向过程语言，那么 JS 是什么？”。“基于对象”，他的回答让我很郁闷，那基于对象跟面向对象又有什么区别？这不，刚好码农翻身的最新推送解答了我的疑问 来源：码农翻身 微信公众号 作者：刘欣 原文地址：码农翻身-JavaScript王国的一次旅行，一个没有类的世界怎么玩转面向对象？ 前言作为Java 帝国的未来继承人，Java小王子受到了严格的教育， 不但精通Java语言、Java虚拟机、java类库和框架，还对各种官方的Java规范了如指掌。 近日他听说一个叫做Javascript的屌丝逆袭了， 成功地建立了一个独立的王国， 不但成了前端编程之王， 还不断地蚕食Java帝国的领地 ！ 按照小王子宫廷老师的说法： 想当年， 这家伙只是运行在浏览器中，完完全全是蹭了Java的热度这才发展起来， 现在竟然回过头来要欺负我们， 还有没有天理了？ 是可忍孰不可忍？ ！ (微信公众号码农翻身注：参见文章《Javascript：一个屌丝的逆袭》) 小王子可不这么认为， 存在必然是合理的，javascrip必有独特之处， 俗话说知己知彼，百战不殆，他觉得有必要去Javascript王国刺探一下，搜集一下情报， 看看这个曾经的浏览器中的面向对象语言是怎么回事， 为什么那么多码农趋之若鹜。 初步印象乔装打扮以后，小王子来到Javascript 王国，这里看起来一派生气勃勃的景象，人们随性而奔放， 不像Java帝国那么严肃而呆板， 让人感觉心情愉悦。 不过令小王子感到不可思议的是， 这里竟然没有官方提供的类库! 人们干活用的工具五花八门，让人眼花缭乱， 什么AngularJS, React , Backbone，Vue, Ember，JQuery, …… 互相之间还吵来吵去，争来争去，煞是热闹。 对比这下，Java帝国有着严密的统治，有着官方提供的庞大类库， 还有一统天下的Web框架 SSH/SSM ，再加上各种各样的Java规范， 码农们只需要拿来学习，干活就行。 没有了选择的烦恼， 但同时也减少了选择的权利， 是好还是坏？ 小王子自己也不知道。 小王子还注意到Javascript王国的人写程序几乎没人使用IDE， 找个趁手的文本编辑器就可以开工， 然后扔到浏览器中去运行测试，真是轻量级啊！ 唉， 我们Java帝国还在争论IntelliJ IDEA和Eclipse孰优孰劣, 实在是没有必要啊。 没有类怎么创建对象随着调查的深入，小王子愈发觉得吃惊， 这里竟然没有类的概念！ 一个面向对象的语言竟然没有类！ 这和小王子从出生就被灌输的概念可是背道而驰！ 没有类怎么创建对象 ？ 小时候宫廷老师经常说： 先写一个类， 然后才能从这个类new出一个对象出来 。 可是眼前却有着无数的javascript对象， 他们在不断地产生、消亡，一起辛苦地工作，支撑起庞大的、生机勃勃的帝国。 这些对象是从哪里来的？ 小王子百思不得其解， 正值正午时分， 小王子看到前面有一家JSON酒馆，决定先歇歇脚，美美地吃一顿再说。 小王子要了二斤熟牛肉，三碗酒，正要开始享用， 只听到旁边桌子的一个穿着长袍的人问道：哎，你说的那个对象的原型是什么？ 另一位戴眼镜的则低声说：嘘，噤声，国王刚颁布命令，原型法是我们帝国的秘密，禁止公开讨论，以防被Java帝国给学了去。 小王子心中一动， 马上把小二叫来，要来上等酒菜， 送到邻桌，请两位吃酒。 一番酒喝下来， 小王子终于获得了两人的初步信任， 原来他们还是负责审查javscript语言规范的官员。 小王子问道： “我家世代经商， 走南闯北，去过C++王国，Java帝国， C#帝国， 他们都是号称面向对象的语言， 都有class 和 object的区分， 可是到了咱们javascript王国， 我怎么连一个class 都没有看到啊？ ” 戴眼镜的官员说： “我们不用class， 那玩意儿太不直观了 ！” 小王子暗暗称奇， 可是仔细一想， 好像就是这样啊， 想当初我学习Java的时候， 费了好大的劲才接受了class这个概念，实际上面向对象的系统，不就是对象之间的交互吗？ 要类干什么？ 然后小王子问了一个关键问题： “没有class, 怎么创建对象啊” “外乡人， 没那么复杂，你想想什么是对象啊，不就是属性加上方法吗？ 你看看我们这就创建一个对象出来 ” 这位官员说着，手指头沾着酒水在桌子上写了起来： 看到没有，这个animal对象定义了一个属性name, 和一个方法 eat , 简单吧？” 的确是简单又明了，完全不需要class， 一个对象就创建了，小王子面前似乎打开了一扇新的大门。 “由于对象并不和类关联， 我们可以随意地给这个对象增加属性：” 眼镜官员补充到。 “还能这么玩？！” 小王子被惊到了，没有类的约束，这些对象也太自由了吧。 没有类怎么继承“那继承怎么实现， 继承可是面向对象的重要概念啊” 眼镜官员说： “简单啊，继承不就是让两个对象建立关联嘛！ 在我们javascript王国，每个对象都有一个特殊的属性叫做proto， 你可以用这个属性去关联另外一个对象（这个对象就是所谓的原型了） ， 来我给你画一下” 这段酒水写成的代码不长，但是却深深地震撼了小王子， 因为其中信息量非常巨大，隐藏了“原型”的秘密， 小王子不由得陷入了深思： 对象dog 的原型是animal (注意：也是一个对象)， 对象cat的原型也是animal 。 无论是dog还是cat ，都没有定义eat()方法， 那怎么可以调用呢？ 当eat方法被调用的时候，先在自己的方法列表中寻找， 如果找不到，就去找原型中的方法， 如果原型中找不到， 就去原型的原型中去寻找…… 最后找到Object那里， 如果还找不到， 那就是未定义了。 这里的这几个对象肯定是通过proto建立了一个原型链！ 嗯， 我师父给我讲JVM虚拟机的时候， 也提到了一个对象在执行方法的时候，需要查找方法的定义，这个查找的次序也是先从本对象所属的类开始， 然后父类， 然后父类的父类…… 直到Object, 思路是一模一样的！ 只不过Java 的方法定义是在class中， 而这个javascript 的方法就在对象里边， 现在我觉得似乎在对象里更加直观一点啊。 属性和方法应该类似，也是沿着原型链向上查找， 不过这里dog的name属性似乎覆盖了animal的name属性， 还有那个this, 在调用dog.eat()的时候，应该是指向dog这个对象的。 看来面向对象的理念都是想通的啊。 想着想着，小王子脸上竟然露出了笑容。 看到小王子像程序卡住一样，不动了， 穿长袍的官员推了小王子一把： 外乡人， 你怎么了？ 小王子意识到自己的失态， 赶紧说： “哦，没啥， 我觉得你们使用的这个’原型‘的办法很精妙啊， 完全不用类就实现了继承。” 眼镜官员一愣： “外乡人， 看来你悟性不错， 帝国的秘密已经被你给洞察了， 不过很多新来的程序员就不容易体会到这一点， 于是我们就做了一个变通， 让javascript可以像Java那样new 出对象出来。说来惭愧， 这完全是为了迁就那些C++,Java, C#程序员啊 ” 向Java靠拢小王子说：”什么变通办法？ 难道你们也开始使用类了吗？“ “不不， 我们提供了一个叫做构造函数的东西。还是给你写点儿代码吧 ” 官员说着，又蘸着酒水写了起来： 小王子说道： “那个function 已经有点 class的感觉了啊, 天呐我竟然看到了this这个关键字， 对了那个Student是你故意写的大写吗？ ” “是啊 ， 这样以来看起来就像Java的类了。但是，中间有个问题，你看出来了吗？ ” 小王子想了一阵：“ 是不是说每个新创建对象都有一个sayHello函数？ 在Java中函数都是定义在class 上的。 如果定义对象上， 那就意味着每个对象都有一份， 太浪费了。” “是的，所以我们得提供一种更加高效的办法， 把这个sayHello函数放到另外一个地方去！ ” “放到哪里？ ” “记得我们刚才说的原型链吗？ 当一个对象调用方法的时候，会顺着链向上找，所以我们可以创建一个原型对象，其中包含sayHello函数， 让andy, lisa这些从Student创建起来的对象指向这个原型就ok了。” “可是你这里只有构造函数Student, 在哪里创建原型对象呢？ 怎么把andy,lisa 这些对象的proto指向原型对象呢？ 不会让我手工来指定吧。” 眼镜官员瞪了一眼小王子说： “我们javascript帝国肯定不会这么麻烦程序员的， 我们可以把这个原型对象放到Student.prototype这个属性中（注意，不是proto）， 这样一来，每次当你创建andy,lisa这样的对象时， javascript 就会自动的把原型链给建立起来！” 小王子面露难色：“唉，这理解起来有点难啊。” “还是画个图吧， 当你去new Student的时候，javascript会建立这样的关系链：” 小王子说： “明白了，这个所谓的构造函数Student 其实就是一个幌子啊， 每次去new Student的时候，确实会创建一个对象出来（andy或者lisa) ， 并且把这个对象的原型(proto)指向 Student.prototype这个对象，这样一来就能找到sayHello()方法了。” 眼镜官员回答：“没错，这个地方容易让人混淆的就是proto和prototype这两个属性， 唉，我也不知道最早为什么这么干， 实在是不优雅。” “是啊，这个构造函数再加上prototype的概念，实在是让人费解， 所以我们商量着提供一点语法糖降低程序员的负担。” 长袍官员附和到。 语法糖听到语法糖，小王子觉的很亲切， 因为 Java 中也提供了很多方便程序员的语法糖。 当长袍官员写出javascript的语法糖的时候， 小王子不由得大吃一惊： 这语法糖已经把javascript变得非常像Java, C#，C++的类了， 看来javascript帝国为了“讨好”程序员， 已经努力的在改变了， 我们java帝国看来得加油啊。 小王子现在明白了Javascript是一个基于原型实现的面向对象的语言， 根本没有类的概念， 新的方式给小王子的思维观念带来了重大的冲击。 在这里待久了，他又了解到javascript强大的函数式编程，越来越喜欢javascript, 都有点乐不思蜀了。 小王子还会回到Java帝国吗？]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是框架？]]></title>
    <url>%2F2017%2F07%2F24%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%A1%86%E6%9E%B6%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[想起当初学习 Java 和 Android 开发的时候最后一个没有迈过去的门槛就是框架了。一开始我还很纳闷什么是框架，后来学习的时间长了才慢慢理解这个概念。同样，我们今天来看看码农翻身公众号的文章，该文章是以一个故事的形式来展开，极其有趣。通过这个故事来深入理解一下什么是框架 来源：码农翻身 微信公众号 作者：刘欣 原文地址：码农翻身-一个故事讲完https 码农菜鸟张大胖立志走上Java之路， 听了大神Bill的指点， 先学了Java SE, 把集合、线程、反射、IO、泛型、注解之类的基础知识学了一遍， 在Bill的严厉督促下，写了大量的代码。 然后开始学Web基础，什么Http, html, javascript , css , servlet, jsp , tomcat …… 又是一大堆知识点。 他在网上找了一个小网站， 自己模拟着做了一下， 虽然不是专业美工， 界面惨不忍睹， 但总算是把功能模仿了七七八八， 很有成就感。 大胖拿去给Bill 看了， Bill 夸奖道： “嗯，功能实现的还可以， 没有用任何框架能做成这样子， 很不错。 ” 大胖说： “框架？ 什么是框架？” Bill 愣了一下： “ 你还突然把我给问住了， 我们整天开口框架，闭口框架， 现在让我给框架下个定义， 我还真说不出来， 让我想想。 ” Bill 闭目养神， 大胖虔诚等待。 不到一炷香功夫， Bill睁开眼睛：“ 我来给你举个例子， 你不是刚刚用servlet和jsp做了小的Web项目吗， 假设有人出钱让你再做一个类似的系统，你会怎么办？” “那我就把现在的代码复制一下， 在上面改改， 不就得了？ ” “如果有十个八个类似这样的项目呢， 难道你都通过复制粘贴来做吗？” Bill 问 “十个八个？ 我还是跳楼去吧。 ” “那你没有想想把其中重复的一些东西抽取出来， 形成可以复用的东西？” 张大胖说： “ 听你这么说，还真的有一点可以复用的东西， 比方说URL和业务代码的映射， 我经常会遇到类似这样的 url : www.xxx.com?action=login ， 在后台的servlet 中我就判断， 如果action 的名称是login , 我就把userName, password 这样的参数从表单中提取出来， 执行登录的代码。 我得写很多的if else 才能支持不同的业务逻辑， 很折磨人。 有时候我就想， 要是有一种方法， 能够直接把URL和Java类直接映射起来就好了 ， 这样就轻松多了！” “没错，这是一个很好的想法， 还有吗？ ” Bill 笑着问。 “嗯。。。 再比如数据验证啊，比如登录时用户名或者密码出错， 我要在浏览器端显示错误提示信息，这个也很难搞啊， 错误提示的字体、颜色、图标、位置太烦人了。” “还有吗？” “对了，访问数据库也是个大问题， 我写了很多的SQL, 很多的JDBC 代码, 仅仅是为了把数据从数据库取出来， 放到Java 对象中去。 你肯定知道，直接用JDBC编程得处理很多细节问题：一定要记住关闭连接了， 处理异常了 。。。等等， 不瞒你说，很多代码都是我复制粘贴的。” “难道你不能写一个通用的类， 传入SQL，返回结果集吗？ ” Bill 问道。 “那我肯定是写了， 但是把结果集变成Java 对象还有一段很长的路呢， 没啥技术含量， 纯粹体力活， 怪不得人家叫我们码农！ ” 大胖愤愤的说。 Bill 说： “我刚才翻了翻你的代码， 我发现很多的地方都让人不爽啊， 比如你几乎把所有的业务逻辑都写到Servlet当中去了， 中间还掺杂者页面控制和跳转， 这么乱七八糟像意大利面条一样的代码过了一个月估计你自己都看不明白了。 ” 大胖不好意思的笑了： “不用一个月， 这刚过了一个星期我就犯晕了。” “所以嘛， 其实你这些问题我们的前辈早就遇到了， 他们也苦苦探索， 不断寻找好的实现方式， 找到以后就把各种经验给固化下来， 称为最佳实践。” “最佳实践？ 能举个例子嘛！” “比如在Web开发中就有一个很好的实践啊，叫做MVC。 就是针对你上面的业务逻辑和页面控制混在一起提出的解决办法。 这个实践会强烈的建议你把数据模型、页面展示、页面跳转控制分开来写， 防止搅成一团。” Bill意犹未尽， 继续举例： “再比如你说的第一个问题， 也早就有解决方案了， 可以利用XML或者Java注解来描述URL和Java 类之间的关系，你只需要声明一下， 背后的操作，都交由框架去处理了。 还有你的Java 对象和数据库表的对应关系， 也只需要声明一下，框架就可以帮你把数据取出来，填充到Java对象中去，这就极大的减轻了你的工作量。” “Bill, 你又提到框架这个词了，可不可以这么说， 框架就像一个模板， 里边已经预置了一些公认的最佳实践，我要是想用的话， 把我项目相关的东西填充进去就可以了，是不是这样？ ” “可以这么理解， 框架像个半成品， 是无法独立运行的，必须由开发人员按照它定义的规则，把项目的代码放置到指定的地方， 由框架整合起来，这才是一个完整的应用程序。” 大胖挠着头说： “那框架其实也没什么啊， 我只要理解了那些最佳实践， 掌握了它的规则，可不就学会了吗?” “没错， 现在很多Java Web系统都是基于像SpringMVC, Hibernate, MyBatis这样的流行框架构造起来的， 框架不得不学， 但是如果只会使用框架， 只会填充代码， 那只是一个HTML填空人员。” “那我学完了框架，可以用框架做项目了， 接下来学什么？” 大胖心里有点没底。 “你要是对Java 后端编程感兴趣， 还有很多东西啊， 用框架实现了业务只是很小一块， 还有系统架构设计， 缓存、性能、高可用性、分布式、安全、备份等很多内容啊， 你学的越多，就会发现无知的领域更多， 所谓学无止境啊！” 张大胖目视远方，沉默了。。。。。 张大胖听大神Bill讲解了框架的作用，回去思考了两天，茅塞顿开。 框架只是一个半成品而已， 这个半成品当中固化了很多最佳的实践， 开发人员必须把自己的代码填充到框架当中才能成为一个完整的应用程序。 说起来简单， 到底怎么“填充”呢 ？ 码农们写出来的代码怎么才能让框架知道， 并且调用呢？ 张大胖本来想找Bill 问个明白， 但转眼一想， 自己要是能思考出结果岂不更加印象深刻？ ！ 他的脑子开始热身，迅速进入高速运转状态， 叮的一声， 一个想法跨入他的脑海： 可以用继承啊！ 框架定义一些抽象类(如Java 中的abstract class ) 让具体的应用代码去继承， 抽象类的好处是可以写具体方法， 也可以只声明抽象方法而不实现 – 具体的实现肯定要留给码农们的应用程序了。 在抽象类的具体方法中，可以处理一些框架公用的逻辑， 然后调用那些子类应该实现的抽象方法， 这不就把框架和应用结合起来了吗？ 嗯， 这不就是我上周看过的一个著名的设计模式： 模板方法吗？ 用在此处挺合适的嘛， 大胖不由的一阵得意， 似乎是自己重新发明了这个设计模式。 （注： Action 为抽象类，doBusiness 为抽象方法，其他为具体方法） 张大胖马上向Bill汇报自己的新发明， Bill 鼓励到： “你小子开窍了啊， 这的确是一个办法， 著名的MVC框架struts1 就是这么干的， 还有JUnit的早期版本,更早的EJB1.x, 2.x 都是这样， 都需要自己的业务类/测试类去继承一个框架的抽象类， 实现抽象方法才可以。” 张大胖知道Bill的习惯是先扬后抑， 静静的等待着转折。 “但是，” 转折果然如期而至， “ 这种方法让人感到不爽，业务类比较死板 ， 比如你必须得用框架规定的方法名， 没法自己定制。例如JUnit的早期版本， 测试用例的初始化方法必须得叫Setup, 销毁方法必须是TearDown, 你想换成init/destroy 是肯定不行的， 因为框架根本不知道。 ” 张大胖说： “这没什么啊， 我觉得还是比较好的编程实践呢， 大家都保持名称一致，可读性很好啊” “其实你往深处想想就会明白， 这种方式其实让你的业务类和框架绑定了！ 这是最要命的。 你的例子中抽象类是Action , 如果这个Action 很‘重’ ，依赖HttpServletRequest/HttpServletResponse， 必须得有一个Web容器（Tomcat）才能创建起来， 那你的LoginAction 可就悲催了， 想要做个单元测试必须得把Tomcat跑起来才行。 ” 张大胖说：“听你这么一解释， 我明白了，这种继承的方式问题很大啊。 是不是可以这么说， 框架和业务类最好是独立变化， 中间用一座桥来连接起来。” Bill 赞许道 ： “对， 你想想这个桥用什么‘材料’做比较好？” 张大胖挠挠头，一脸懵逼。 “回到原始的问题， 我们不就是试图让框架把我们的业务类创建起来，然后调用特定的方法吗？ 完全不用在代码中写死， 可以采用别的声明式的办法啊” Bill 循循善诱。 “难道在代码中写注释？ ” 张大胖继续一脸懵逼。 “注释都是纯文本， 不是结构化的信息啊， 难道你让框架读取文本，然后做个语义分析？ 根本不可能， 更何况注释在编译过的class中间已经不复存在了，无处可寻， 框架怎么读？ 再想想” Bill急得就差自己公布答案了。 “啊， 我知道了，你刚才说的结构化信息提醒了我， 可以用XML啊， XML来描述结构化东西很擅长！ ” 张大胖说着还写了个例子出来： “通过用XML来描述， 框架就可以找到相关的类和方法，就可以调用了” “是的， 你举了一个小例子， 实际上由于XML的扩展性， 能描述极为复杂的语义，很多框架都会制定规则， 让码农们去‘声明’自己的业务类及其方法。 “ “这种声明的方式真是不错，业务类不用继承框架的抽象类了，我刚想到一个问题， 我们的Java类和XML配置不在一起， 当我们想知道一个类的方法，字段是怎么被框架使用的时候，还得回过头来查看XML， 这实在不爽。 ” 张大胖问道。 “这是个好问题， 那就把这种‘声明’信息挪到Java 类中去吧！” Bill 说。 “你刚才说了不能用注释， 怎么在Java 文件中写‘声明’ 啊？” “没有注释， 可以有注解啊！ ” “你是说那个@author, @version, @return, @see这样用来生成Java文档的注解吗？ 还有什么@Override，@Deprecated, 我从来都不用。” Bill 笑了： “那只是Java内置的一些注解， 现在Java可以自定义注解了， 我们完全可以利用这种注解来声明框架想用的信息， 我给你举个例子：” 张大胖问道： “@Controller, @ReqeustMapping, @RequestParam 都是框架自定义的注解？“ “是的， 你可以直接在Java 代码中使用， 在运行时框架能读取这些注解， 就知道你想干什么事情了。” “ 嗯，所有的信息都在Java 中了， 比XML看起来更简洁一些， 果然是十分酸爽。” 张大胖十分感慨 ，“不过，这样一来声明式的信息又四处分散，维护又不方便了。 ” Bill说： “哪有十全十美的东西？ 在编程中根据情况选择吧！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列查找(哈希表)基础讲解]]></title>
    <url>%2F2017%2F07%2F21%2F%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[还记得上个月面试官问我能不能谈谈哈希表，然后我就说了”数组+链表“。然后就再也憋不出任何一句话了，因为数据结构我刚好学到二叉树，一段黑历史了。不说了，现在补上之前没有填上的坑…… 引子相信大家多多少少肯定会对查找算法有些了解，比如顺序查找、二分查找、利用“二叉搜索树”查找等等。顺序查找适用于数据量不大的时候；二分查找虽然时间复杂度较为乐观，但前提是数据元素已经按照关键字排序并且存储在连续的地址空间中；二叉搜索树查找具有相当不错的时间复杂度，但有时需要附加条件。那这样我们就需要一种适应性广而速度又快的查找算法。这就是本篇要讲的散列查找。 其实我们生活中有许多例子也是运用到了散列查找的精髓。举个栗子，我们琢磨一下查英文字典的过程，其实这个过程结合了散列查找、二分查找和顺序查找这几种查找方法。 基本概念讲解基本概念之前，我们再回到查字典这个例子。我们会根据所查单词的首字母去字典的检索表获取该单词所在位置大概在整本字典的哪一部分。然后再翻到大概页面仔细查找相对应的单词。而在散列查找的概念，上面所说的单词首字母就是散列查找中的“关键词”(key)。然后通过“散列函数”求出关键词所在的存储位置(value)。但我们也得重点说明一下查字典时我们事先“估计”关键词的“大致位置”，而散列函数“计算”的是关键词的“准确位置”。 散列查找之所以能够通过计算来快速定位要找的关键词，一个基本的前提是在存放的时候也要通过同样的“计算方法”来定位存储的位置。 从抽象的数据类型的角度看，上表实际上就是一张符号表(Symbol Table)，我们也称它为散列表或哈希表(Hash Table)。它定义为“名字-属性”对的集合。名字和属性的含义随着应用的不同而不同， 符号表的抽象数据类型描述为： 类型名称：符号表(SymbolTable) 数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合 操作集：对于一个具体的符号表 $ Table \in SymbolTable $，一个给定名字 $Name \in NameType$，属性 $Attr \in AttributeType$，以及正整数 $TableSize$，符号表的基本操作主要有 SymbolTable CreateTable(int TableSize)-创建空的符号表，其最大长度为 TableSize boolean IsIn(SymbolTable Table,NameType Name)-查找指定名字Name 是否在符号表中，若是返回true；否则返回false AttributeType Find(SymbolTable Table,NameType Name)-获取符号表Table中指定名字Name对应的属性 boolean Modify(SymbolTable Table,NameType Name,AttributeType Attr)-将Table中指定名字Name的属性修改为Attr。成功返回true；找不到Name则返回false boolean Insert(SymbolTable Table,NameType Name,AttributeType Attr)-向Table中插入一个新名字Name及其属性Attr。成功则返回true；若Name已存在则返回false boolean Delete(SymbolTable Table,NameType Name)-从Table中删除一个名字Name 及其属性。成功返回true；找不到Name则返回false 散列(Hashing)是一种重要的查找算法。它的基本思想是：以数据对象的关键词 key 为自变量，通过一个确定的函数关系 $h$ ,计算出对应的函数值 $h(key)$ ，把这个值解释为数据对象的存储地址，并按此存放，即“$存储位置=h(key)$”。 在查找某数据对象时，有函数 $h$ (也称为哈希函数)对给定值 key 计算出地址，将 key 与该地址单元中数据对象关键字进行比较，确定查找是否成功。因此散列法又称为“关键字-地址转换法”。 说到这里，读者可能会有疑问：如果有两个（或更多）关键词通过某散列函数计算出相同的存储位置，那又该怎么办？总不能把多个多个关键词对应的信息都存放在相同的位置吧？我们把这种情况叫做冲突。因此，我们还需要研究解决冲突的方法。这就引出了后面我们要讲的散列查找法的两个基本内容： 1.如何构造散列函数 2.如何解决冲突 散列函数的构造方法一个“好”的散列函数一般应考虑下列两个因素： 1.计算简单，以便提高转换速度 2.关键词对应的地址空间分布均匀，以尽量减少冲突。 关键词可分为数字型关键词和字符串型关键词这两种类型 数字关键词的散列函数构造构造这类散列函数只不过把原来的数字按某种规律转换成另一个数字 直接定址法$$ h(key)=a \times key + b (a、b为常数) $$ 这类函数计算简单，分布均匀，不会产生冲突，但要求地址集合与关键词集合大小相同，因此对于较大的关键词集合不适用。 除留余数法假设散列表长为 TableSize（TableSize 的选取，通常由关键词集合的大小 $n$ 允许最大装填因子 $\alpha$ 决定），选择一个正整数 $p \leq TableSize$ ，散列函数为： $$h(key)= key \bmod p$$ 设散列表空间大小为 $m$ ，填入表中的元素个数是 $n$，则称 $\alpha = n/m$ 为散列表的装填因子。一般散列表大小设计使得 $\alpha=0.5 \sim0.8$为宜 使用除留余数法，选取合适的 $p​$ 很重要，一般选取 $p​$ 为小于或等于散列表表长 $TableSize​$ 的某个最大素数比较好。用素数求得的余数作为散列地址，比较均匀分布在整个地址空间上的可能性比较大。 大家也可能注意到如果 $p &lt; TableSize$ ，则意味着地址 $p \sim TableSize -1$ 是不能通过散列函数直接映射到的。 数字分析法如果数字关键词的位数比较多，我们可以根据实际情况将关键词中随机性比较大的位数提取出来形成一个新的关键词。例如 11 位手机号，前 3 位和中间 4 位在一定范围内很容易发生重复。所以直接选取最后 4 位作为散列地址。如果 4 位正整数太大，不适合作为地址，可以结合前面的除留余数法再做一次转换。 字符串关键词的散列函数构造简单的散列函数——ASCII 码加和法$$h(key)=(\sum key[i]) \bmod TableSize$$ 函数很简单，然而均匀性也较差。但仔细研究一下你会发现关键词集合元素可能性个数大大超过存储的散列地址个数。显然冲突会是很严重的，特别是关键词集合元素个数比较大的情况下。 简单的改进——前 3 个字符移位法我们改进一下上面的散列函数$$h(key)=(key[0]+key[1]\times 27+key[2]\times 27^{2})$$这里我们先假设字符串的每个字符只有不分大小的英文字母（26个）和空格符（1个）。函数仅考虑关键词的前 3 个字符。若忽略空格符不急，则前 3 位所有可能的不同组合为 $26^{3}=17576$ 种，似乎该数字不大。但是现实生活中英文不是随机的，真正的英文单词中前 3 位的不同组合大约不到 3000 种。这样不仅难以确定 $TableSize$ 大小而且具有相同的前 3 个字符的不同关键词一定会发生冲突。显然这个还不是很合适。 好的散列函数——移位法$$h(key)=(\sum_{i=0}^{n-1}key[n-i-1]\times32^i)\bmod TableSize$$ 这个散列函数涉及关键词的所有 $n$ 个字符，并且分布得很好。每位字符占 5 位(即 $2^5=32$)。具体实现时并不需要一一做乘法运算，而是通过将每位字符转换成 二进制 ASCII 码值，通过一次左移 5 位来完成，低位补 0 ，得到的二进制结果再转换成十进制数值，这就是字符 ASCII 码值乘以一次 32 的结果。 处理冲突的方法在前面的散列函数构造过程中，我们努力使散列地址均匀分布于整个地址空间，但是实际应用中，冲突不可避免只能减少。因此我们应该研究如何解决冲突的问题。 开放定址法假如你打算在某个小区买套房子住，根据你的生辰八字(关键词)，风水先生(散列函数)告诉你 8-801 最适合你。正准备下单的时候，开发商却告诉你说该房子已被人预定（冲突发生）。此时我们可能会看看其他附近其他套房子。这就是开放定址法。 所谓开放地址法，就是一旦产生了冲突，即改地址已经存放了其他数据元素，就去寻找另一个空的散列地址。在没有装满的散列表中，空的散列地址是有的，但是怎么去找，这是我们应该考虑的因素之一 一般来说，如果关键词经过散列函数得出散列地址后发现有冲突，那么就需要试探性散列函数去试试其他附近的散列地址是否是空的。如果还发生冲突的话就再次使用试探性散列函数再去试试其他散列地址。试探性散列函数的基本公式是：$$p_i(key)=(h(key)+d_i)\bmod TableSize (1\leq i &lt; TableSize)$$上面式子中，$i$ 表示冲突次数。根据 $d_i$ 的选取方式不同，我们可以得到不同的解决冲突方法。上面的地址必须对 $TableSize$ 取余。 线性探测法我们举个栗子，某个关键词 $key$ 经过散列函数 $h$ 获得散列地址 $h(key)$ 。但是发现该散列地址不是空的，发生了第一次冲突，此时 $d_1=1$ 。这时候我们就需要使用试探性散列函数去获取试探性散列地址 $p_1(key)$ 。如果 $p_1(key)$ 散列地址也不是空的，就发生了第二次冲突,此时 $d_2=2$ 求得 $p_2(key)$ 散列地址再去尝试。以此类推，我们可以得出 $d_i=i$ ，确定 $d_i$ 取值之后再不断用试探性散列函数去尝试新的散列地址直到没有发生冲突为止。这就是线性试探法。 线性试探法可能使第 $i$ 个散列地址的同义词存入第 $i+1$ 个散列地址，也就说本应存入第 $i$ 个散列地址的数据对象变成了第 $i+1$ 个散列地址的同义词。因为线性试探就是不断在发生冲突的地方附近一一试探，因此极容易出现很多元素在相邻的散列地址上“堆积”起来的叫做“一次聚集”的现象，这种现象会大大降低查找效率。为减轻这种一次聚集效应，可采用下面讲解的平方探测法或双散列探测法。 平方探测法按上面的流程，如果 $d_i =\pm i^{2}$ ，即 $d_i$ 的取值依次为 $1^{2}$，$-1^{2}$ ，$2^{2}$ ，$-2^{2}$ ，… ，$q^{2}$ ，$-q^{2}$ 且 $q \leq [TableSize/2]$ 去不断试探下一个存储地址的形式就是平方探测法。我们需要注意一点的就是散列表长度 $TableSize$ 是某个 $4k+3$ ($k$ 是正整数)形式的素数时能保证平方探测法可以探查到这个散列空间。这个是平凡探测法的理论基础。 双散列探测法如果公式 $p_i(key)$ 中的 $d_i=i \times h_2(key)$ ，其中 $h_2(key)$ 是另一个散列函数。我们就把它叫做双散列探测法。而第二个散列函数 $h_2(key)$ 的选取至关重要，要确保 $h_2(key)$ 都不能是 0 值，否则所有探测都是同一个位置。我们同时也需要保证所有的散列存储单元都应该能够被探测到，一般形如$$h_2(key)=p-(key \bmod p)(p是小于TableSize 的素数)$$的 $h_2(key)$ 函数具有良好的探测效果。采用双散列探测法会增加探测过程中的计算量，但其期望的探测次数比较少，这使得它在理论上很有吸引力。不过平方探测法不需要计算第二个散列函数，从而在实践中可能更简单又实用。 再散列法开放地址法的装填因子 $\alpha$ 会严重影响查找效率，由于表长在一定时间是定值，$\alpha$ 与“填入表中的元素个数”成正比，所以 $\alpha$ 越大填入表中的元素越多，产生冲突的可能性就越大。减少冲突是提高查找速度的直接因素，因为散列表的查找过程基本上与建表过程相同。一些关键词可通过散列函数转换的地址直接找到，另一些关键词在散列函数得到的地址上产生了冲突，需要按处理冲突的方式进行查找。因此加倍扩大散列表减少冲突是一种提高查找效率的方法，此方法的过程就叫做再散列(Rehashing)。 再散列需要新建一个新的两倍大的散列表，再将原表中的数据重新计算分配到新表中。这个过程集中花费时间长，体现在交互系统的现象就是使人感觉系统有“停顿”现象。这种现象在一些实时系统中是致命的，例如医用的生命保障系统中，设备的短暂“停顿”可能导致严重后果，所以需谨慎使用。此时可以采用不需要再散列的“分离链接法”。 分离链接法分离链接法(Separate Chaining)是解决冲突的另一种方法，其做法是将所有关键词为同义词(散列地址一致的关键词)的数据对象通过结点链接存储在同一个单链表中。 最后懂得基本的数据结构与算法是程序猿的必备素养，学习数据结构与算法的方式也有多种多样。浙江大学计算机系的数据结构的网络课程是个相当不错在线课程，课程还提供了在线编程平台PTA，感兴趣的朋友可以去看看。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个故事讲完 Https]]></title>
    <url>%2F2017%2F07%2F20%2F%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps%2F</url>
    <content type="text"><![CDATA[想起上个月面试官问我了不了解 Https，当时对 HTTP 都不太熟的我只能说”No”。当我看完计算机网络教材的时候，又恰巧看见了微信公众号码农翻身的此篇推送，让我受益良多。 来源：码农翻身 微信公众号 作者：刘欣 原文地址：码农翻身-一个故事讲完https 序言今天来聊一聊https 安全传输的原理。 在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。 这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。 此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心…… 张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America …… Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样….. 两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。 总是有一种被偷看的感觉有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。 张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！” Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ” 张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！” （码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥） 一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！” Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？” 张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？ “奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？” “哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ” 张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！ 可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！ RSA：非对称加密Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。 这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。 更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。 有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ） 反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。 这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。 非对称加密+对称加密两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？” Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了” “回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走 (1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ” Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。” 于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！ 中间人攻击张大胖把和Bill 聊天的情况给老婆汇报了一次。 老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?” 张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。” 老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密， 那中间人不就可以解密看到消息了？＂ 张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！ 看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！ 你到底是谁但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？ 可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。 怎么声明呢？ 张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。 这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！ 这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！ 可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？ 张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。 天无绝人之路， 张大胖很快就找到了突破口： 数字签名。 简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。 可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？” 张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名： 这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书” 张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！ 如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。 虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。 中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？ 难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？ 如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。” 张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！ 不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。 （公众号码农翻身注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。） Https终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。 一个简化的（例如下图没有包含Pre-Master Secret）https流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单：]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络入门]]></title>
    <url>%2F2017%2F07%2F19%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一直对人工智能感兴趣，但苦于找不到简洁易懂的入门资料。前几天拜读了阮一峰博客中的此篇博文，觉得非常不错，故转载过来，希望那些想了解神经网络的人都能有所收获 眼下最热门的技术，绝对是人工智能。 人工智能的底层模型是”神经网络“。许多复杂的应用（比如模式识别、自动控制）和高级模型（比如深度学习）都基于它。学习人工智能，一定是从它开始。 什么是神经网络呢？网上似乎缺乏通俗的解释。 前两天，我读到 Michael Nielsen 的开源教材《神经网络与深度学习》（Neural Networks and Deep Learning），意外发现里面的解释非常好懂。下面，我就按照这本书，介绍什么是神经网络。 感知器历史上，科学家一直希望模拟人的大脑，造出可以思考的机器。人为什么能够思考？科学家发现，原因在于人体的神经网络。 外部刺激通过神经末梢，转化为电信号，转导到神经细胞（又叫神经元）。 无数神经元构成神经中枢。 神经中枢综合各种信号，做出判断。 人体根据神经中枢的指令，对外部刺激做出反应。 既然思考的基础是神经元，如果能够”人造神经元”（artificial neuron），就能组成人工神经网络，模拟思考。上个世纪六十年代，提出了最早的”人造神经元”模型，叫做“感知器”（perceptron），直到今天还在用。 上图的圆圈就代表一个感知器。它接受多个输入（x1，x2，x3…），产生一个输出（output），好比神经末梢感受各种外部环境的变化，最后产生电信号。 为了简化模型，我们约定每种输入只有两种可能：1 或 0。如果所有输入都是1，表示各种条件都成立，输出就是1；如果所有输入都是0，表示条件都不成立，输出就是0。 感知器的例子下面来看一个例子。城里正在举办一年一度的游戏动漫展览，小明拿不定主意，周末要不要去参观。 他决定考虑三个因素。 天气：周末是否晴天？ 同伴：能否找到人一起去？ 价格：门票是否可承受？ 这就构成一个感知器。上面三个因素就是外部输入，最后的决定就是感知器的输出。如果三个因素都是 Yes（使用1表示），输出就是1（去参观）；如果都是 No（使用0表示），输出就是0（不去参观）。 权重和阈值看到这里，你肯定会问：如果某些因素成立，另一些因素不成立，输出是什么？比如，周末是好天气，门票也不贵，但是小明找不到同伴，他还要不要去参观呢？ 现实中，各种因素很少具有同等重要性：某些因素是决定性因素，另一些因素是次要因素。因此，可以给这些因素指定权重（weight），代表它们不同的重要性。 天气：权重为8 同伴：权重为4 价格：权重为4 上面的权重表示，天气是决定性因素，同伴和价格都是次要因素。 如果三个因素都为1，它们乘以权重的总和就是 8 + 4 + 4 = 16。如果天气和价格因素为1，同伴因素为0，总和就变为 8 + 0 + 4 = 12。 这时，还需要指定一个阈值（threshold）。如果总和大于阈值，感知器输出1，否则输出0。假定阈值为8，那么 12 &gt; 8，小明决定去参观。阈值的高低代表了意愿的强烈，阈值越低就表示越想去，越高就越不想去。 上面的决策过程，使用数学表达如下。 上面公式中，x表示各种外部因素，w表示对应的权重。 决策模型单个的感知器构成了一个简单的决策模型，已经可以拿来用了。真实世界中，实际的决策模型则要复杂得多，是由多个感知器组成的多层网络。 上图中，底层感知器接收外部输入，做出判断以后，再发出信号，作为上层感知器的输入，直至得到最后的结果。（注意：感知器的输出依然只有一个，但是可以发送给多个目标。） 这张图里，信号都是单向的，即下层感知器的输出总是上层感知器的输入。现实中，有可能发生循环传递，即 A 传给 B，B 传给 C，C 又传给 A，这称为“递归神经网络”（recurrent neural network），本文不涉及。 矢量化为了方便后面的讨论，需要对上面的模型进行一些数学处理。 外部因素 x1、x2、x3 写成矢量 &lt;x1, x2, x3&gt;，简写为 x 权重 w1、w2、w3 也写成矢量 (w1, w2, w3)，简写为 w 定义运算 w⋅x = ∑ wx，即 w 和 x 的点运算，等于因素与权重的乘积之和 定义 b 等于负的阈值 b = -threshold 感知器模型就变成了下面这样。 神经网络的运作过程一个神经网络的搭建，需要满足三个条件。 输入和输出 权重（w）和阈值（b） 多层感知器的结构 也就是说，需要事先画出上面出现的那张图。 其中，最困难的部分就是确定权重（w）和阈值（b）。目前为止，这两个值都是主观给出的，但现实中很难估计它们的值，必需有一种方法，可以找出答案。 这种方法就是试错法。其他参数都不变，w（或b）的微小变动，记作Δw（或Δb），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组w和b，就是我们要的值。这个过程称为模型的训练。 因此，神经网络的运作过程如下。 确定输入和输出 找到一种或多种算法，可以从输入得到输出 找到一组已知答案的数据集，用来训练模型，估算w和b 一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正 可以看到，整个过程需要海量计算。所以，神经网络直到最近这几年才有实用价值，而且一般的 CPU 还不行，要使用专门为机器学习定制的 GPU 来计算。 神经网络的例子下面通过车牌自动识别的例子，来解释神经网络。 所谓”车牌自动识别”，就是高速公路的探头拍下车牌照片，计算机识别出照片里的数字。 这个例子里面，车牌照片就是输入，车牌号码就是输出，照片的清晰度可以设置权重（w）。然后，找到一种或多种图像比对算法，作为感知器。算法的得到结果是一个概率，比如75%的概率可以确定是数字1。这就需要设置一个阈值（b）（比如85%的可信度），低于这个门槛结果就无效。 一组已经识别好的车牌照片，作为训练集数据，输入模型。不断调整各种参数，直至找到正确率最高的参数组合。以后拿到新照片，就可以直接给出结果了。 输出的连续性上面的模型有一个问题没有解决，按照假设，输出只有两种结果：0和1。但是，模型要求w或b的微小变化，会引发输出的变化。如果只输出0和1，未免也太不敏感了，无法保证训练的正确性，因此必须将”输出”改造成一个连续性函数。 这就需要进行一点简单的数学改造。 首先，将感知器的计算结果wx + b记为z。 123&gt; z = wx + b&gt;&gt; 然后，计算下面的式子，将结果记为σ(z)。 123&gt; σ(z) = 1 / (1 + e^(-z))&gt;&gt; 这是因为如果z趋向正无穷z → +∞（表示感知器强烈匹配），那么σ(z) → 1；如果z趋向负无穷z → -∞（表示感知器强烈不匹配），那么σ(z) → 0。也就是说，只要使用σ(z)当作输出结果，那么输出就会变成一个连续性函数。 原来的输出曲线是下面这样。 现在变成了这样。 实际上，还可以证明Δσ满足下面的公式。 即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。 原作者：阮一峰 原文地址：神经网络入门 - 阮一峰的网络日志]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记(二)]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[本文章将记录后面几个月的学习笔记 2017.7.9CSS 注意事项 CSS 类选择器中类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用 不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。 定块状元素使用 margin 属性来水平对齐时要注意块状元素的宽度不能是父元素的 100% 2017.7.14网页结构一个网页由许多文件组成：文本，代码，样式表，媒体内容等等。当你开发网页时，你需要将这些文件以清晰的结构在你的本地计算机中存储下来，保证它们之间的联系，使它们看起来正确，然后才能将它们上传至服务器 网页应该存放在计算机何处？当你在本地操作你的网页时，你应该将所有关联的文件放在一个能反映服务器上文件结构的单独的文件夹里。这个文件夹可以存放在任何你喜欢的位置，不过你应该将它放在你容易找到的位置，或许可以是你的桌面，你的主页，或是磁盘根目录 网页应该使用什么结构我们创建的任何网页项目中最常使用的就是一个索引HTML文件和不同的包括图像，样式表和脚本文件的文件夹 index.html：这个文件通常将包括你的主页内容，也就是说，人们第一次进入你的网页看到的文本和图像 images folder：这个文件夹包含你网页上所有使用的图像 styles folder：这个文件夹包含了为你的内容添加样式的样式表 scripts folder：这个文件夹包含了所有为你网页添加交互功能的 JavaScript 代码 文件路径如上面网页结构中 index.html 与 images 文件夹属于同级目录。index 网页需要引用 images 文件夹下的图片资源，就可以使用 images/icon.png 。如果 index.html 与图片资源 icon.png 直接同级的话，就直接使用 icon.png 。如果图片资源 icon.png 位于 Index.html 的上级目录中，则使用 ../icon.png 解析一个 HTML 元素如下图 这个元素的主要部分有： 开始标签：这里包含了元素的名称（这里是 p），表示这里是这个元素的开始发挥作用——在这个例子中从这一段的开头开始。 闭合标签：表明这里是元素的结尾——在这个例子中，就是这一段落的结尾。 内容（content）：这是一个元素的内容，这个例子中就是所输入的文本本身。 元素（The element）：开标签、闭标签与内容相结合，便是一个完整的元素。 解析 HTML 文档12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;My test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="images/firefox-icon.png" alt="My test image"&gt; &lt;/body&gt;&lt;/html&gt; 这里我们有： &lt;!DOCTYPE html&gt;——文档类型。在 HTML 刚刚出现的时期里（大约是1991/2 年），文档类型是用来链接一些应该遵守的规则，有点像自动校正等。然而现在大家都不用管文件类型，只是因为历史原因必须包含在代码中。现阶段大家知道这些就够了。 &lt;html&gt; 元素。这个元素包含了整个页面的内容，有时也被称作根元素。 &lt;head&gt; 元素。这个元素可以包含你想添加的所有内容，但是不会被用户所看到。这里面包括像想被搜索引擎搜索到的关键字（keywords）和页面描述，CSS样式表和字符编码声明等等。 &lt;body&gt; 元素。这个元素包含了你想被用户看到的内容，不管是文本，图像，视频，游戏，可播放的音轨或是其他内容。 ——这个元素指定了你的文档需要使用的字符编码，像 UTF-8 ，它包括了非常多人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容。我们没有任何理由不去设定字符编码，而且也可以避免以后可能出现的问题。 &lt;title&gt; 元素——这个元素设置了页面的标题，标题显示在浏览器标签页上，而且在你将网页添加到收藏夹或喜爱中时将作为默认名称。 解析 CSS 规则 选择多个元素你也可以选择多种类型的元素然后为它们添加一组样式。记得将不同的选择符用逗号分开 123p,li,h1&#123; color:red;&#125; Margin 属性概述margin属性为给定元素设置所有四个（上下左右）方向的外边距属性。这是四个外边距属性设置的简写。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数 浏览器支持 取值方式 应用实例 外边距合并块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。具体可了解W3C 外边距合并、MDN 外边距合并、前端面试必备——外边距合并、Collapsing margins——合并的外边距 发生外边距合并的三种基本情况： 相邻的兄弟姐妹元素 块级父元素与其第一个/最后一个子元素 空块元素 CSS overflow属性w3c overflow MDN overflow CSS clear属性MDN clear属性 CSS float浮动元素和清除浮动float 会使浮动元素脱离正常的文档布局流，并粘贴到其父容器的某个方向。在正常布局中位于该浮动元素之下，不管是父容器的内容还是元素浮动后其兄弟元素补上他原来位置后其本身的内容，此时会围绕着浮动元素，填满其它方向的空间。但有时候我们为了停止浮动元素之下位于正常布局的元素不再围绕着浮动元素，这是需要清除浮动。同时如果设置某个元素浮动后，那么其父容器（如果存在的话）就会出现父容器背景不能显示、边框不能撑开、margin设置值不能正确显示 详情可看MDN布局 浮动布局、MDN float属性参考、CSS 最核心的几个概念 HTTPS 是什么在协议名 http 后面加上的‘s’代表 SSL 运输层安全协议，表明现在使用的是提供安全服务的 HTTP 协议。在这种情况下，在发送方，SSL 接受应用层的数据，对数据进行加密，然后把加了密的数据送往 TCP 套接字。在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。 什么是Web Server什么是网络服务器 MDN 2017.7.18什么是元数据(Metadata)元数据是描述数据的数据。举个简单的例子，如果一份 HTML 文档是一数据，那么描述这份数据的数据，比如作者，关键字，摘要，指定文档文档字符编码等等就是元数据。它在 HTML 文档结构中存在&lt;title&gt;&lt;/title&gt;当中。 2017.7.22在 HTML 中应用 CSS 和 JavaSscript&lt;link&gt;元素位于文档头部，它有两个属性，rel=&quot;stylesheet&quot;，这表明这是文档的样式表，而href属性指明了样式表文件的路径： &lt;script&gt;元素放置文档正文&lt;body&gt;&lt;/body&gt;标签内的尾部会是一个更好的选择，因为这样可以确保在加载脚本之前浏览器已经解析了 HTML 内容(如果脚本加载某个不存在的元素，浏览器会报错) 为文档设定主语言 这是为你的站点设定语言。这样你的 HTML 文档就会被搜索引擎更有效地索引。我们还可以将文档的分段设置为不同的语言。例如下面我们把日语部分设置为日语： Japanese example: ご飯が熱い。. 2017.7.23HTML &lt;meta&gt; 标签 http-equiv 属性http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。 name 属性name 属性提供了名称/值对中的名称。HTML 和 XHTML 标签都没有指定任何预先定义的 名称。通常情况下，您可以自由使用对自己和源文档的读者来说富有意义的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助： 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; 如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 content 属性content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。content 属性始终要和 name 属性或 http-equiv 属性一起使用。 scheme 属性scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 标签的 profile 属性指定的概况文件中进行了定义。 HTML 主要元素一篇 HTML 文档的的结构是具有一定的通用型的，其通用元素有&lt;main&gt;,&lt;article&gt;,&lt;section&gt;,&lt;aside&gt;,&lt;header&gt;,&lt;nav&gt;,&lt;footer&gt;。其中每个元素的具体信息可看MDN HTML layout elements HTML 文档纠错大型HTML文档可使用W3C的工具进行错误检查，具体可见HTML validation Markdown 本质书写的 markdown 语言，最后其实是转换成 html 语言的。html 本来就是为了结构化文档的，可是 html 写起来太费劲了，所以才有 markdown 语言。markdown 标准化了，大家都可以用自己的方式将 markdown 转换成自己想要的 html 。其实转 html 是差不多的，不一样就体现在各个解析器怎么去写自己 css（体现成不同的样式） 2017.7.24Understanding Uninitialized Variables当 JavaScript 中的变量被声明的时候，程序内部会给它一个初始值 undefined。当你对一个值为 undefined的变量进行运算操作的时候，算出来的结果将会是 NaN，NaN 的意思是 “Not a Number”。当你用一个没有 定义 的变量来做字符串连接操作的时候，它会如实的输出&quot;undefined&quot; Understanding String Immutability在 JavaScript 中，字符串的值是不可变的，这意味着一旦字符串被创建就不能被改变 JS 的 strict 模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量： i = 10; // i 现在是全局变量 在同一个页面的不同的 JavaScript 文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 为了修补 JavaScript 这一严重设计缺陷，ECMA 在后续规范中推出了strict 模式，在 strict 模式下运行的 JavaScript 代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用 strict 模式的方法是在 JavaScript 代码的第一行写上： ‘use strict’; 这是一个字符串，不支持 strict 模式的浏览器会把它当做一个字符串语句执行，支持 strict 模式的浏览器将开启 strict 模式运行 JavaScript。 2017.7.25HTTP HTTPS 2017.7.26HTML 输出流JavaScript 能够创建动态的 HTML 内容。在 JavaScript 中，document.write()可用于直接向 HTML 输出流写内容 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;输出流测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.write(Date()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果是： 今天的日期是：Wed Jul 26 2017 14:30:15 GMT+0800 (中国标准时间) HTML DOM通过 DOM，可访问 HTML 文档的所有元素。当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），通过 DOM 创建的表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。文档对象模型 DOM 是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API），HTML DOM 模型被构造为对象的树： 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找HTML元素通常，通过 JavaScript，您需要操作 HTML 元素。 为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事： 通过 id 找到 HTML 元素 通过标签名找到 HTML 元素 通过类名找到 HTML 元素 浏览器事件兼容性处理123456var x = document.getElementById("myBtn");if (x.addEventListener)&#123; //所有主流浏览器，除了 IE8 及更早版本 x.addEventListener("click",myFunction);&#125;else if (x.attachEvent)&#123; //IE8 及更早版本 x.attachEvent("onclick",myFunction);&#125; DOM创建和删除元素添加新元素12345678910111213&lt;div id="div1"&gt; &lt;p id="p1"&gt;this is the first paragraph&lt;/p&gt; &lt;p id="p2"&gt;this is the second paragraph&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var para=document.createElement("p"); //创建新的文本元素 var node=document.createTextNode("这是一个新段落。");//创建新的文本节点 para.appendChild(node); //元素追加文本节点 var element=document.getElementById("div1"); //找到一个已有的元素 element.appendChild(para); //已存在的元素后添加新元素&lt;/script&gt; 删除已有的HTML元素12345678910&lt;div id="div1"&gt; &lt;p id="p1"&gt;this is the first paragraph&lt;/p&gt; &lt;p id="p2"&gt;this is the second paragraph&lt;/p&gt;&lt;/div&gt;//这个 HTML 文档含有拥有两个子节点（两个 &lt;p&gt; 元素）的 &lt;div&gt; 元素&lt;script&gt; var parent=document.getElementById("div1"); //找到 id="div1" 的元素 var child=document.getElementById("p1"); //找到 id="p1" 的 &lt;p&gt; 元素 parent.removeChild(child); //从父元素中删除子元素&lt;/script&gt; 注意：DOM需要清楚你需要删除的元素，以及他的父元素 123//找到您希望删除的子元素，然后使用其 parentNode 属性来找到父元素var child=document.getElementById("p1");child.parentNode.removeChild(child); Canvas的基本用法Canvas是一个可以使用脚本(通常为JavaScript)在其中绘制图形的 HTML 元素。它可以用于制作照片集或者制作简单(也不是那么简单)的动画。 基本用法 HTML SVGSVG 是使用 XML 来描述二维图形和绘图程序的语言。 2017.7.27关于开发者工具 style 栏的使用google developer 编辑样式 CSS 样式优先级浏览器缺省 &lt; 外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器 &lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器 &lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式 各种选择器 元素选择器 类选择器 ID选择器 属性选择器 后代选择器 子元素选择器 相邻兄弟选择器 伪类和伪元素 其中，后代选择器和子元素选择器以及相邻兄弟选择器统称为派生选择器。伪选择器就是不选择实际元素，而是元素的某些部分，或仅在某些上下文中的元素。它们有两种主要类型 - 伪类和伪元素。 chrome开发者工具style一栏划线条目或灰色条目意义划线条目代表优先级低已被优先级高所取代 灰色条目代表没有起作用，原因可能是该条目需要根据运行结果计算出来，或者该条目不可继承。 chrome下的调试器里面灰色的样式是代表什么？ CSS的值和单位MDN CSS的值和单位 2017.7.29编程范式漫谈编程范式是某种编程语言典型的编程风格或者说是编程方式。但是同时一个语言的编程范式没有绝对的划分界限，比如 Java 面向对象语言，但是 最新的 Java 8 标准加入了函数式特性，JavaScript 也是多范式语言。因此我们可以得出编程语言的发展都是根据需求来制定的。我们知道现有语言的编程范式有：过程式（面向过程），面向对象，函数式（具有声明式），逻辑式。随着软件工业化程度的普及，以及软件的复杂度越来越高，编程语言的发展历程也是从最初的过程式（命令式）语言c，发展到以 Java 语言为代表的面向对象编程语言。而逻辑编程语言(以prolog为代表）和函数式语言(lisp系列）还多用在学术和人工智能领域中。近几年，随着多核，云计算时代的到来。函数式编程语言逐渐浮出水面，最经典的语言以scheme,common-lisp,ml,clojure,go为代表.而且最近的jdk8也逐步加入了functional,closure,lambda等语法，而且scala的作者也越来越推崇编码者以函数式语言的思维来coding。可见编程语言的发展也是满足时代的变化不断变化着。从其中的发展历程中我们可以看到：技术的发展都是在围绕着解决“软件的复杂度”这个基本的需求而发展的。 过程化（命令式）编程：应该是最原始的、也是我们最熟悉的一种传统的编程方式。从本上来讲，它是“冯诺依曼机”运行机制的抽象，它的编程方式源于计算机指令的顺序排列。也就是说过程化语言模拟的是计算机机器的系统结构。它的编程步骤是：首先，应该讲待解的问题的解决方案抽象为一系列概念化的步骤。然后通过编程的方式将这些步骤转化为程序指令集，而这些指令按照一定的顺序排列，用来说明如何执行一个任务或解决一个问题。过程化语言特别适合解决线性的问题。它强调“自上而下”的设计方式，一步一步的解决问题。这种方式非常类似我们的工作和生活方式，都是以时间为线性基础的。过程化语言趋向于开发运行较快且对系统资源利用率较高的程序。它的不足之处就是不适合某些种类问题的解决，例如那些非结构化的具有复杂算法的问题。 事件驱动编程（响应式编程）：事件驱动的程序设计中，程序中的许多部分可能在完全不可预料的时刻被执行。往往这些程序的执行是由用户与正在执行的程序的互动激发所致。事件驱动常常用于用户与程序的交互，通过图形用户接口（鼠标、键盘、触摸板）进行交互式的互动。属于事件驱动的编程语言有： VB、C#、Java Swing等。它们所涉的事件绝大多数都是 GUI 事件。 面向对象编程：以“世界万物皆为对象”的思想指导开发工作。这符合人类的认知方式。所以常被用来开发问题复杂的软件。 2017.7.31服务器编程语言Java、PHP、Python、Ruby等。这些服务器端的语言可以帮我们产生 HTML 的网页。 表格在一些浏览器中，没有内容的表格单元显示得不太好，如果某个单元格是空的（没有内容），浏览器可能无法显示出这个单元格的边框。为了避免这种情况，在空单元格中添加一个空格占位符，就可以将边框显示出来。 12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; jQuery事件1234567$(document).ready(function()&#123; //开始写 jQuery 业务代码&#125;);//等效写法$(function()&#123; //开始写 jQuery 业务代码&#125;) 这个方法允许我们在文档完全加载完后执行函数。如果文档未完全加载完毕就执行逻辑代码，那么操作失败。 jQuery toggle()可是使用$(&quot;选择器&quot;).toggle(speed,callback)方法来切换 hide()和show()方法。参数speed可选值：”slow”、”fast”或毫秒。参数callback是隐藏或显示完成后所执行的函数名称。 但是对于callback参数，需要说明的就是： $(&quot;选择器&quot;)选中的个数有 n 个，则回调函数就会执行 n 次 callback 函数名后加括号，会立刻执行函数体，而不是等到显示或者隐藏完成后才执行 callback 既可以是函数名，也可以是匿名函数 code sample 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $("#hide").click(function()&#123; $("p").hide("slow",function()&#123;alert("callback")&#125;); //先执行两次回调函数再隐藏元素 //$("p").hide("slow",show); 隐藏后再执行回调函数 //$("p").hide("slow",show()); 先执行回调函数再隐藏元素 &#125;); $("#show").click(function()&#123; $("p").show(); &#125;);&#125;);/*function show()&#123; alert("callback回调函数");&#125;*/&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果你点击“隐藏” 按钮，我将会消失。&lt;/p&gt;&lt;p&gt;我在学习 jQuery。&lt;/p&gt;&lt;button id="hide"&gt;隐藏&lt;/button&gt;&lt;button id="show"&gt;显示&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2017.8.1关于 JavaScript、jQuery、AJAX、JSON 之间的关系 JavaScript 是一门语言，早先时期运行与前端，负责网页的动画以及前后台的交互，现已进化成前后端通吃 JQuery 是为了简化 JavaScript 语法而形成的库，其实就是对 JavaScript 的封装，形成更简洁的语法 AJAX 是一种接口技术，或者说是一种思想，用来实现异步刷新，用 JavaScript 和 JQuery 都可以实现该技术(思想) JSON 是一种简单的数据交换格式。简单来说就是 JavaScript 的对象属性集合，他比 xml 语法要更加简单，方便传输。 详情请见：JavaScript、jQuery、AJAX、JSON 这四个之间的关系？ 2017.8.4盒子位移属性是如何工作？盒子的位移属性有四个“top、right、bottom和left”，用来指定元素的定位位置和方向。这些属性只能在元素的“position”属性设置了“relative、absolute和fixed”属性值，才生效。对于相对定位元素，这些属性的设置让元素从默认位置移动。例如，top设置一个值“20px”在一个相对定位的元素上，这个元素会在原来位置向下移动“20px”。对于绝对定位和固定定位，这些属性指定了元素与父元素边缘之间的距离，例如，绝对定位的元素设置一个“top”值为“20px”，将使绝对定位元素相对于其设置了相对定位的祖先元素顶部边缘向下移动“20px”，反之，如果设置一个“top”值为“20px”，将使绝对定位元素相对于其设置了相对定位的祖先元素顶部边缘向上移动“20px”。（绝对定位的参考点是其祖先元素设置了“relative”或者“absolute”值）。 详情可查阅CSS 中，为什么绝对定位（absolute）的父级元素必须是相对定位（relative）？-知乎 子绝父相 “子绝父相”指的是设置为绝对定位的元素其参考物是设置为相对定位的父元素。如果父级元素是绝对定位或者没有设置，里面的绝对定位自动以body定位。 上面是绝对定位的一般认识，但是这种认识是错误。正确理解应该是： 只要父级元素设了 position 并且不是 static（默认既是 static ），那么设定了 absolute 的子元素即以此为包含块（最近的）。绝对定位（Absolute positioning）元素定位的参照物是其包含块，既相对于其包含块进行定位，不一定是其父元素。若没有非 static 祖先，包含块为初始包含块，在浏览器里，根元素的包含块（）为初始包含块，只是一般情况下看上去像是 body 区域。 2017.8.7互联网安全协议网络层安全协议在虚拟专用网 VPN 上传送的信息都是经过加密的，而提供这种服务的就是 IPsec。IPsec 并不是一个单一协议，而是能够在 IP 层提供互联网通信安全的协议族。IPsec 并没有限定用户必须使用何种特定的加密和鉴别算法。实际上，IPsec 是个框架，它允许通信双方选择合适的算法和参数。为保证互操作性，IPsec 还包含了一套加密算法，所有 IPsec 的实现都必须使用。 运输层安全协议运输层现在广泛使用的两个安全协议就是： 安全套接字层(Source Socket Layer) 运输层安全(Transport Layer Security) SSL 协议是 Netscape 公司开发，广泛用于基于万维网的各种网络应用。它作用在端系统应用层的 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。之后 1995 年 Netscape 将 SSL 转交给 IETF，IETF 在 SSL 的基础上设计了 TLS 协议，为所有基于 TCP 的网络应用提供安全数据传输服务。 在未使用 SSL 时，应用层的应用程序的数据是通过 TCP 套接字与运输层进行交互的。使用 SSL 之后，在应用程序下面多了一个 SSL 子层，而在应用程序和 SSL 子层之间，还有一个 SSL 套接字，其作用和以前讲过的 TCP 套接字相似，是应用程序和 SSL 子层的应用编程接口 API。 应用层使用 SSL 最多的就是 HTTP，但是 SSL 并非仅用于 HTTP，而是可用于任何应用层的协议。使用 SSL 进行通行时： 发送方：SSL 从 SSL 套接字接收应用层的数据，对数据进行加密，然后把加密的数据送往 TCP 套接字 接收方：SSL 从 TCP 套接字读取数据，解密后通过 SSL 套接字把数据交给应用层 SSL 提供的安全服务可归纳为一下三种： SSL 服务器鉴别，允许用户证实服务器的身份。支持 SSL 的客户端通过验证来自服务器的数字证书，来鉴别服务器的真实身份并获得服务器的公钥 SSL 客户鉴别，SSL 的可选安全服务，允许服务器证实客户的身份 加密的 SSL 会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改 动态主机配置协议为了把协议软件做成通用的和便于移植的，协议软件的编写者不会把所有的细节都固定在源码中。相反，他们把协议软件参数化。这就使得在很多台计算机上有可能使用通过一个经过编译的二进制代码。不同计算机可以设置不同参数来使计算机使用不同的网络协议。动态主机配置协议 DHCP (Dynamic Host Configuration Protocol)，它提供了一种机制，称为即插即用连网。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。这有利于经常移动位置的计算机，但对于不经常移动的计算机来说，也免去了手工配置参数的麻烦。 2017.8.9Git标签git tag vxxx可以给最新提交到本地版本打上标签 git tag -d vxxx 删除本地标签 git tag vxxx xxxx给历史版本补上标签 git tag -a vxxx打上带注解的标签，会进入vi命令模式，按i可以进入编辑模式，再按Esc可以退回命令模式，按:wq保存并退出vi编辑器模式 git push origin vxxxx将本地的标签推送到远端服务器 git push origin :refs/tags/vxxx 删除远程标签 JavaScript来由JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言（如 Perl）负责的一些输入验证操作。在 JavaScript 问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。在那个拨号上网的年代，每一次与服务器的数据交换事实上都成了对人们耐心的一次考验。由此，JavaScript的诞生就是为了解决这个问题。当然如今的 JavaScript 早已具备了与浏览器窗口及其内容等几乎所有方面交互的能力。 ECMAScript1997 年，以 JavaScript 1.1 为蓝本的建议被提交给了欧洲计算机制造商协会（ECMA，European Computer Manufactures Association）。该协会最后完成了 ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准。 JavaScript实现虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMA-262 中规定的要多得多。一个完整的 JavaScript 实现应该由下列三个不同的部分组成。如下图： 2017.8.10HTML 5 的时代要求现在的时代已经迫切地要求有一个统一的互联网通用标准。HTML 5 之前的情况是，由于各浏览器之间的不统一，光是修改 Web 浏览器之间的由于兼容性而引起的 bug 就浪费了大量时间。而 HTML 5 的目标就是将 Web 带入一个成熟的应用平台，在 HTML 5 平台上，视频、音频、图像、动画，以及同电脑的交互都被标准化。 Web应用程序应用程序有两种模式 C/S、B/S。C/S 是客户端/服务器端程序，也就是说这类程序一般独立运行。而 B/S 就是浏览器端/服务器端应用程序，这类应用程序一般借助 IE 等浏览器来运行。WEB 应用程序一般是 B/S 模式。Web 应用程序首先是“应用程序”，和用标准的程序语言，如 C、C++ 等编写出来的程序没有什么本质上的不同。然而 Web 应用程序又有自己独特的地方，就是它是基于 Web 的，而不是采用传统方法运行的。换句话说，它是典型的浏览器/服务器架构的产物。 HTML 5 要解决的三个问题 Web 浏览器之间的兼容性很低：HTML 5 出现之前 HTML 并没有一个全球统一的标准，这就导致各家浏览器之间的兼容性很低。在某个 Web 浏览器上可以正常运行的 HTML/CSS/JavaScript 等 Web 程序，在另一个 Web 浏览器上就不正常了的事情是非常多的。HTML 5 的使命是详细分析各浏览器所具有的功能，然后以此为基础，要求这些浏览器所有内部功能都要符合一个通用标准。如果各浏览器都符合通用标准，然后以该标准为基础来书写程序，那么程序在各浏览器都能正常运行的可能性就大大提高了。 文档结构不够明确：在HTML 5 之前的版本中，文档的结构不够清晰、明确、语义化。特别是&lt;div&gt;标签的滥用严重降低了文档的语义特性。 Web 应用程序的功能受到了限制：一直以来对于 Web 应用程序来说，HTML 真正做出的贡献是很少的，譬如说就连上传文件时想同时选择一个以上的文件都做不到。为了弥补这方面的不足，HTML 5 已经开始提供各种各样 Web 应用上的新 API，各浏览器也在快速地封装着这些 API，HTML 5 已经使富 Web 应用的实现变成了可能。 HTML 5 的语法变化DOCTYPE 声明HTML 4 &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 5 &lt;!DOCTYPE HTML&gt; 可以省略结束标记的元素li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th 不允许写结束标记的元素area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 可以省略全部标记的元素(以隐式方式存在)html、head、body、colgroup、tbody 具有 boolean 值得属性1234&lt;input type = 'checkbox' checked&gt; //只写属性不写属性值代表属性为 true&lt;input type = 'checkbox'&gt; //不写属性代表属性为 false&lt;input type = 'checkbox' checked = 'checked'&gt; //属性名=属性值，代表属性为 true&lt;input type = 'checkbox' checked = ''&gt; //属性值为空字符串，代表属性为 true 全局属性是指可以对任何元素都使用的属性，具体可参考MDN 全局属性 HTML 5 新增主体结构元素article元素article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。他可以使一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件。 article元素是可以嵌套使用的，内层的内容在原则上需要与外层的内容相关联。 section元素section元素用于对网站或应用程序中页面上的内容进行分块，或者说对文章进行分段。 JavaScript 比较 相等运算符：== 相等运算符会进行类型比较 严格相等运算符：=== 严格相等运算符同时比较元素的值和数据类型 不相等运算符：!= 与相等运算符逻辑相反 严格不相等运算符：!== 与严格相等运算符逻辑相反 >、\&lt;、>=、\&lt;= 都会进行类型转换 2017.8.11JSONJSON 是 JavaScript 语法的一个严格的子集，利用了 JavaScript 中的一些模式来表示结构化数据。它是一种数据格式，不是一种编程语言。很多编程语言都有针对 JSON 的解析器和序列化器。 JSON 支持简单值（字符串、数值、布尔值和null）、对象、数组。例子如下： 123456789&#123; "name": "Nicholas", "age": 29, "school": &#123; "name": "MIT", "location": "North Andover,MA" &#125;&#125;//属性名一定为双引号 1234567891011121314151617181920212223242526272829303132333435363738[ &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], "edition": 2, "year": 2009 &#125;, &#123; "title": "Professional Ajax", "authors": [ "Nicholas C. Zakas", "Jeremy McPeak", "Joe Fawcett" ], "edition": 2, "year": 2008 &#125;, &#123; "title": "Professional Ajax", "authors": [ "Nicholas C. Zakas", "Jeremy McPeak", "Joe Fawcett" ], "edition": 1, "year": 2007 &#125;] 2017.8.13HTML 使用 JavaScript使用&lt;script&gt;元素嵌入 JavaScript 代码块，解释器会从上至下一次解释。在解释器对代码的解释过程中，页面中的 HTML 元素不会被加载或显示。因此 JavaScript 代码块最好确保在 HTML 元素加载完全后再去解释。在使用&lt;script&gt;嵌入 JavaScript 代码时，记住不要在代码中的任何地方出现&quot;&lt;/script&gt;&quot;字符串。因为按照解析嵌入式代码的规则，当浏览器遇到字符串&quot;&lt;/script&gt;&quot;时会认为那是代码块结束标签。而通过&quot;&lt;\/script&gt;&quot;字符串解决这个问题 延迟脚本HTML 4.01 为&lt;script&gt;标签定义了 defer 属性。这个属性告诉浏览器立即下载，延迟执行，脚本会被延迟到整个页面都解析完毕后再执行。因此只要设置了该属性，则 JS 代码的嵌入也可以放到&lt;head&gt;标签内。但是这个属性不是所有浏览器都支持，为此，把延迟脚本放在页面底部仍然是最佳选择。 异步脚本HTML 5 为&lt;script&gt;元素定义了 async 属性。这个属性改变了脚本的解释时机是由所处文件的位置决定的特点。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在页面加载期间修改 DOM。 JS 是单线程 UI 语言，但JS的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行（你可以使用IE的标签式浏览试试看效果，这时打开的多个页面使用的都是同一个JS执行线程，如果其中一个页面在执行一个运算量较大的function时，其他窗口的JS就会停止工作）。而异步机制是浏览器的两个或以上常驻线程共同完成的，例如异步请求是由两个常驻线程：JS执行线程和事件触发线程共同完成的，JS的执行线程发起异步请求（这时浏览器会开一条新的HTTP请求线程来执行请求，这时JS的任务已完成，继续执行线程队列中剩下的其他任务），然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理。 具体可查阅 JavaScript 既是单线程又是异步的，请问这二者是否冲突，以及有什么区别？-知乎 const、let、var 的区别 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值 变量提升和函数提升变量提升12345678910console.log(global); // undefinedvar global = "global";console.log(global); // globalfunction fu()&#123; console.log(a); // undefined var a ="aaa"; console.log(a); // aaa&#125;fn(); 实际执行顺序 123456789101112var global; //变量提升，全局作用域，但是只声明，未赋值console.log(global); // undefinedglobal = "global";console.log(global); // globalfunction fu()&#123; var a; //变量提升，函数作用域范围内，只声明，未赋值 console.log(a); // undefined var a ="aaa"; console.log(a); // aaa&#125;fn(); 函数提升1234console.log(f1); //funtion f1()&#123;&#125;console.log(f2); //undefinedfunction f1()&#123;&#125;var f2=funtion()&#123;&#125; 因为函数提升只对函数声明式起作用，对函数字面量式不起作用，其实际执行顺序 1234function f1()&#123;&#125;console.log(f1);console.log(f2);var f2=function()&#123;&#125; 2017.8.16回调函数回调函数——函数中的参数如果是另一个函数的话，那么这个作为参数的函数就是回调函数，可以在需要的时候在函数体内调用这个函数 1234567891011121314151617181920function a(callback)&#123; console.log("我是parent函数a"); console.log("调用回调函数"); callback();&#125;function b()&#123; console.log("我是回调函数b");&#125;function c()&#123; console.log("我是回调函数c");&#125;function test()&#123; a(b); a(c);&#125;test(); 输出结果 我是parent函数a——&gt;调用回调函数——&gt;我是回调函数b——&gt;我是parent函数a——&gt;调用回调函数——&gt;我是回调函数c window.requestAnimationFrame()使用12345function animate()&#123; //done(); requestAnimationFrame(animate);&#125;requestAnimationFrame(animate); 12345678var globalID;function animate()&#123; //done(); globalUD = requestAnimationFrame(animate); //do something animate&#125;globalID = requestAnimationFrame(animate);cancelAnimationFrame(globalID); 兼容性最佳实践123456789101112131415161718192021222324(function() &#123; var lastTime = 0; var vendors = ['webkit', 'moz', 'o']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;;&#125;()); 2017.8.24JavaScript 的面向对象构造函数123456var Car = function()&#123; this.wheels = 4; this.engines = 1; this.seats = 1;&#125;var myCar = new Car(); 如上面一个构造函数，通常使用大写字母开头，以便把自己和其他普通函数区别开来。在构造函数中，this指向被此构造函数创建出来的对象。要使用new关键字去调用构造函数。因为只有这样，JavaScript 才知道这是要去构造一个新对象，并且把构造函数中的this指向这个新对象。 对象的私有属性/方法和公有属性/方法12345678910var Bike = function()&#123; var gear = 2; //var 关键字创建私有属性，在对象外部无法访问私有属性/方法 this.getGear = function()&#123; //this 关键字指向将要被创建对象，可创建公有属性/方法 return gear; &#125;; this.setGear = function(num)&#123; gear = num; &#125;&#125;;var myBike = new Bike(); 2017.8.31闭包因为全局变量可以被内部环境（例如函数内部）读取使用，而局部变量只能在自身环境内部使用外并不能被外部使用。因此我们可以通过闭包的方式在外部读取内部的变量，这种方式会使局部变量始终保存在内存中，容易造成内存泄漏。简而言之，闭包就是内部函数和外部函数连接的一座桥梁。 例子： 123456789function sayHello2(name)&#123; var text="Hello "+name; //局部变量,正常情况下外部无法访问 var sayAlert=function()&#123; console.log(text); &#125;&#125;var say2=sayHello2("Jane");say2(); //Hello Jane 更多内容可查阅 通过示例学习JavaScript闭包 JavaScript 闭包 |知秋的博客 Javascript 深入浅出闭包 学习Javascript闭包（Closure）|阮一峰的网络日志 global 与 window通过 node 环境执行 js 与我们平时在浏览器中执行 js 有所不同，平常我们在网页中执行 js 代码，我们的全局对象就是 window ，而所谓的最顶级的 global 对象，在浏览器中无法直接访问，我们只能通过 window 这个代理来访问到全局对象的相关属性。但是在 node 中，我们是可以直接访问到全局对象 global 的。 JavaScript 模块化编程随着 Web 应用程序的功能越来越丰富，JavaScript 业务逻辑越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。Javascript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。但是，Javascript不是一种模块化编程语言，它不支持”类“（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。）具体可查阅JavaScript 模块化编程（一）：模块的写法|阮一峰的网络日志。而 AMD 和 CMD 是两种模块定义规范，AMD 即异步模块定义，依赖前置；CMD 通用模块定义规范，依赖就近。 高内聚，低耦合 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据 2017.9.1闭包的应用123456789101112function Animal()&#123; // 私有变量 var series = "哺乳动物"; function run()&#123; // 函数声明式 console.log("Run!!!"); &#125; // 闭包 this.getSeries = function()&#123; return series; &#125;&#125; 普通设计的单例模式123456789var singleton = &#123; name: "percy", speak: function()&#123; console.log("speaking"); &#125;, getName: function()&#123; return this.name; &#125;&#125;; 模块化设计的单例模式(立即执行函数 IIFE)123456789101112131415var singleton = &#123; //私有变量 var age = 22; var speak = function()&#123; console.log("speaking"); &#125;; //公有属性和方法 return &#123; name: "percy", getAge: function()&#123; return age; &#125; &#125;;&#125; 具体可查阅 JavaScript模块化编程（一）：模块的写法|阮一峰的网络日志 闭包计数器123456var countNumber = (function()&#123; //匿名函数 var num = 0; return function()&#123; //匿名函数 return ++num; &#125;&#125;)(); eval is evileval() 函数极低的运算效率，是访问一个简单函数运算执行时间几百倍 父作用域都是对子作用域可见浏览器内核一般来说浏览器内核指的是渲染引擎和 JS 引擎。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。常见的浏览器内核可以分这四种：Trident、Gecko、Blink(Chromium)、Webkit。 2017.9.2预处理器（Preprocessor）In time writing HTML and CSS may feel a bit taxing, requiring a lot of the same tasks to be completed over and over again. Tasks such as closing tags in HTML or repetitively having to looking up hexadecimal color values in CSS. These different tasks, while commonly small, do add up to quite a bit of inefficiency. Fortunately these, and a handful of other inefficiencies, have been recognized and preprocessor solutions have risen to the challenge. A preprocessor is a program that takes one type of data and converts it to another type of data. In the case of HTML and CSS, some of the more popular preprocessor languages include Haml and Sass. Haml is processed into HTML and Sass is processed into CSS. Upon setting out to solve some of the more common problems, Haml and Sass found many additional ways to empower HTML and CSS, not only by removing the inefficiencies but also in creating ways to make building websites easier and more logical. The popularity of preprocessors have also brought along different frameworks to support them, one of the more popular being Compass. you can check Preprocessors - Learn to Code Advanced HTML &amp; CSS to get more information. 2017.9.7GitHub Pages 是什么？Github Pages 设计的初衷是为托管在 GitHub 上的项目提供介绍页面,开发者们可以通过 GitHub Pages 为他们的每一个项目创建一个用于介绍该项目的静态网站,不过由于他的空间免费而且稳定,因此用它搭建一个个人博客网站是再好不过了。 2017.9.10ECMAScript由 ECMA-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262 定义的只是这门语言的基础，而在此基础之上可以构建更完善的脚本语言。我们常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript 的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。 既然 ECMA-262 标准没有参照 Web 浏览器，那它都规定了以下这些内容： 语法 类型 语句 关键字 保留字 操作符 对象 DOM 的诞生曾在 IE 4 和 Netscape Navigator 4 分别支持的不同形式 DHTML 技术，该技术可以使开发人员不用重新加载页面，就可以修改其外观和内容。然而，微软和 Netscape 两家公司在 DHTML 技术发展的不同观点将会使网页的兼容性大大降低，这时，致力于 Web 通信标准的 W3C 着手规划 DOM 标准。 DOM 标准 DOM0——DOM历史坐标中的一个参照点，指的是最早的 DHTML 技术 DOM1——实现映射文档的结构这一功能，并提供一些对 HTML 的对象和方法 DOM2——在原先基础上增加对鼠标和用户界面事件、范围、遍历等模块 DOM3——进一步扩展 DOM，引入了以统一方式加载和保存文档的方法、新增了验证文档的方法 BOM 浏览器对象模型开发人员使用 BOM 可以控制浏览器显示的页面以外的部分——浏览器窗口和框架。 Null 和 Undefined无论在什么情况下，都没有必要把一个变量的值显示地设置为 undefined ，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存到对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和undefined。 ###Boolean 类型 Boolean 类型的字面值只有两个，但 ECMAscript 中所有类型的值 Number、String、Undefined、Null 都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean() ，至于转换结果为 true 还是 false，取决于待转换值得数据类型及其实际值。具体转换规则可参考《JavaScript 高级程序设计》第45页表格。转换规则对理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要，请看下面的代码： 1234var message = "Hello World!"if (message)&#123; alert("Value is true");&#125; 2017.9.12Web建站中各种技术的关系 2017.9.13Vue框架的“渐进式”特性说明前端三大框架 Vue、React、Angular 各自都有自己的一些特点，这样不可避免的会对使用者有一定的要求，这些要求有强有弱，它的强势程度会影响在业务开发中的使用方式。而 Vue 框架的“渐进式”特性表明它的要求不是强势的，没有多做职责之外的事。也可以理解为所谓的“高内聚，低耦合”。具体更多信息可查阅 知乎|Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？ 2017.9.14jQuery Validate插件简介jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。所有的捆绑方法默认使用英语作为错误信息，且已翻译成其他 37 种语言。 使用将表单验证规则写到控件上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js"&gt;&lt;/script&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js"&gt;&lt;/script&gt;&lt;script&gt;$.validator.setDefaults(&#123; submitHandler: function() &#123; alert("提交事件!"); &#125;&#125;);$().ready(function() &#123; $("#commentForm").validate();&#125;);&lt;/script&gt;&lt;style&gt;.error&#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form class="cmxform" id="commentForm" method="get" action=""&gt; &lt;fieldset&gt; &lt;legend&gt;输入您的名字，邮箱，URL，备注。&lt;/legend&gt; &lt;p&gt; &lt;label for="cname"&gt;Name (必需, 最小两个字母)&lt;/label&gt; &lt;input id="cname" name="name" minlength="2" type="text" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="cemail"&gt;E-Mail (必需)&lt;/label&gt; &lt;input id="cemail" type="email" name="email" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="curl"&gt;URL (可选)&lt;/label&gt; &lt;input id="curl" type="url" name="url"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="ccomment"&gt;备注 (必需)&lt;/label&gt; &lt;textarea id="ccomment" name="comment" required&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input class="submit" type="submit" value="Submit"&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 将表单验证规则写到js代码中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js"&gt;&lt;/script&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js"&gt;&lt;/script&gt;&lt;script&gt;$.validator.setDefaults(&#123; submitHandler: function() &#123; alert("提交事件!"); &#125;&#125;);$().ready(function() &#123;// 在键盘按下并释放及提交后验证提交表单 $("#signupForm").validate(&#123; rules: &#123; firstname: "required", lastname: "required", username: &#123; required: true, minlength: 2 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: "#password" &#125;, email: &#123; required: true, email: true &#125;, "topic[]": &#123; required: "#newsletter:checked", minlength: 2 &#125;, agree: "required" &#125;, messages: &#123; firstname: "请输入您的名字", lastname: "请输入您的姓氏", username: &#123; required: "请输入用户名", minlength: "用户名必需由两个字母组成" &#125;, password: &#123; required: "请输入密码", minlength: "密码长度不能小于 5 个字母" &#125;, confirm_password: &#123; required: "请输入密码", minlength: "密码长度不能小于 5 个字母", equalTo: "两次密码输入不一致" &#125;, email: "请输入一个正确的邮箱", agree: "请接受我们的声明", topic: "请选择两个主题" &#125; &#125;);&#125;);&lt;/script&gt;&lt;style&gt;.error&#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form class="cmxform" id="signupForm" method="get" action=""&gt; &lt;fieldset&gt; &lt;legend&gt;验证完整的表单&lt;/legend&gt; &lt;p&gt; &lt;label for="firstname"&gt;名字&lt;/label&gt; &lt;input id="firstname" name="firstname" type="text"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="lastname"&gt;姓氏&lt;/label&gt; &lt;input id="lastname" name="lastname" type="text"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="username"&gt;用户名&lt;/label&gt; &lt;input id="username" name="username" type="text"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="password"&gt;密码&lt;/label&gt; &lt;input id="password" name="password" type="password"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="confirm_password"&gt;验证密码&lt;/label&gt; &lt;input id="confirm_password" name="confirm_password" type="password"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="email"&gt;Email&lt;/label&gt; &lt;input id="email" name="email" type="email"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="agree"&gt;请同意我们的声明&lt;/label&gt; &lt;input type="checkbox" class="checkbox" id="agree" name="agree"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="newsletter"&gt;我乐意接收新信息&lt;/label&gt; &lt;input type="checkbox" class="checkbox" id="newsletter" name="newsletter"&gt; &lt;/p&gt; &lt;fieldset id="newsletter_topics"&gt; &lt;legend&gt;主题 (至少选择两个) - 注意：如果没有勾选“我乐意接收新信息”以下选项会隐藏，但我们这里作为演示让它可见&lt;/legend&gt; &lt;label for="topic_marketflash"&gt; &lt;input type="checkbox" id="topic_marketflash" value="marketflash" name="topic[]"&gt;Marketflash &lt;/label&gt; &lt;label for="topic_fuzz"&gt; &lt;input type="checkbox" id="topic_fuzz" value="fuzz" name="topic[]"&gt;Latest fuzz &lt;/label&gt; &lt;label for="topic_digester"&gt; &lt;input type="checkbox" id="topic_digester" value="digester" name="topic[]"&gt;Mailing list digester &lt;/label&gt; &lt;label for="topic" class="error" style="display:none"&gt;至少选择两个&lt;/label&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;input class="submit" type="submit" value="提交"&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; AJAX简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 使用12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script&gt;function loadXMLDoc()&#123; var xmlhttp; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET","/try/ajax/ajax_info.txt",true); xmlhttp.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type="button" onclick="loadXMLDoc()"&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2017.9.15for in 循环/for of 循环for in 循环是 ES5标准，for of 是 ES6 标准 12345678let arr = ['a','b'];for (a in arr)&#123; console.log(a); //0,1&#125;for (a of arr)&#123; console.log(a); //a,b&#125; 关于本知识点有个面试题是这样的： 123456789var scores = [10,11,12];var total = 0;for (var score in scores)&#123; total += score;&#125;var mean = total / scores.length;console.log(mean); 那么这个mean值是什么？ 11？1？都不对。答案是 4。解释是 for in 循环循环的值永远是键名key，而 key 是一个字符串。所以 total 的值是：‘0012’。它是字符串，但进行数序运算时他又自动转换为数值 12,然后$12\div3=4$ 。 这里涉及到几个 JavaScript 基础知识： for in 循环是循环对象的索引属性，key是一个字符串 数值类型和字符串相加，会自动转换成字符串 字符串除以数值类型，会先把字符串转为数值 2017.9.17AJAX-向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的open()和send()方法： 12xmlhttp.open("GET","ajax_info.txt",true);xmlhttp.send(); 当 async = false 时，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。但是对于一些小型的请求，也是可以的。这时请不要编写 onreadystatechange() 函数，而是把代码放到 send() 语句后面即可： 123xmlhttp.open("GET","/try/ajax/ajax_info.txt",false);xmlhttp.send();document.getElementById("myDiv").innerHTML=xmlhttp.responseText; onreadystatechange当请求被发送到服务器时，我们需要执行一些基于响应的任务。而每当 xmlhttp.readyState 改变时就会触发本函数。 使用回调函数如果网站上存在多个 AJAX 任务，那么应该为创建 XMLHttpRequest 对象编写一个标准函数，并为每个 AJAX 任务调用该函数。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;var xmlhttp;function loadXMLDoc(url,cfunc)&#123; if (window.XMLHttpRequest)&#123;// IE7+, Firefox, Chrome, Opera, Safari 代码 xmlhttp=new XMLHttpRequest(); &#125;else&#123;// IE6, IE5 代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange=cfunc; xmlhttp.open("GET",url,true); xmlhttp.send();&#125;function myFunction()&#123; loadXMLDoc("/try/ajax/ajax_info.txt",function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;&lt;h2&gt;使用 AJAX 修改文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type="button" onclick="myFunction()"&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; AJAX的请求与服务器语言的互动当请求发送到服务器后，服务器端语言 ASP 或 PHP 以及其他语言会去处理发送过来的请求并生成结果发送结果到浏览器上。 AJAX发送请求获取 XML 文件并解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;table,th,td &#123; border : 1px solid black; border-collapse: collapse;&#125;th,td &#123; padding: 5px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;XMLHttpRequest 对象&lt;/h1&gt;&lt;button type="button" onclick="loadDoc()"&gt;获取我收藏的 CD&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;table id="demo"&gt;&lt;/table&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myFunction(this); // this 在这里指的就是 xhttp &#125; &#125;; xhttp.open("GET", "cd_catalog.xml", true); xhttp.send();&#125;function myFunction(xml) &#123; var i; var xmlDoc = xml.responseXML; var table="&lt;tr&gt;&lt;th&gt;Artist&lt;/th&gt;&lt;th&gt;Title&lt;/th&gt;&lt;/tr&gt;"; var x = xmlDoc.getElementsByTagName("CD"); //所有标签名为CD的节点的数组 for (i = 0; i &lt;x.length; i++) &#123; table += "&lt;tr&gt;&lt;td&gt;" + //childNodes[0]是标签名为ARTIST节点数组种索引为0的节点下子节点数组中索引为0的节点（文本节点） //nodeValue为文本节点的节点内容，就是文本本身 x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;td&gt;" + x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue + "&lt;/td&gt;&lt;/tr&gt;"; &#125; document.getElementById("demo").innerHTML = table;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这个例子中使用的 URL 地址实际上是一个名为 “cd_catalog.xml“ XML 文件。 HTTP的报文结构请求报文：从客户向服务器发送请求报文 响应报文：从服务器到客户的回答 报文中的每一个字段都是一些 ASCII 码串。请求报文和响应报文都是由三部分组成——开始行、首部行、实体主题，两种报文的区别就来自于第一部分的不同。 开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行（Request-Line），而在响应报文中的开始行叫做状态行（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的 CR和LF分别代表“回车”和“换行” 首部行，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。 实体主体（entity body），在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段 请求报文请求报文的第一行“请求行”只有三个内容，即方法、请求资源的 URL、以及 HTTP 的版本。这里的“方法”是指请求函数的不同。请求报文中常见的几个请求函数如下： 方法（操作） 意义 OPTION 请求一些选项的信息 GET 请求读取由 URL 所标志的信息 HEAD 请求读取由 URL 所标志的信息的首部 POST 给服务器添加信息（例如，注释） PUT 在指明的 URL 下存储一个文档 DELETE 删除指明的 URL 所标志的资源 TRACE 用来进行环回测试的请求报文 CONNECT 用于代理服务器 当我们浏览清华大学院系设置的页面时，HTTP 的请求报文的请求行是： GET http://www.tsinghua.edu.cn/chn/yxsz/index.htm HTTP/1.1 下面是这个请求报文的详细信息 GET /chn/yxsz/index. htm HTTP/1.1 {请求行使用了相对 URL} Host: www.tsinghua.edu.cn {此行是首部行的开始。这行给出主机的域名} Connection: close {告诉服务器发送完请求的文档后就可释放连接} User-Agent: Mozilla/5.0 {表明用户代理是使用Netscape浏览器} Accept-Language : cn {表示用户希望优先得到中文版本的文档} {请求报文的最后还有一个空行} 在请求行使用了相对 URL（即省略了主机的域名）是因为下面的首部行（第2行）给出了主机的域名。第 3 行是告诉服务器不使用持续连接，表示浏览器希望服务器在传送完所 请求的对象后即关闭 TCP 连接。这个请求报文没有实体主体。 不同请求函数的比较 GET——最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是 GET 方式。GET 方法要求服务器将 URL 定位的资源放在响应报文的数据部分，回送给客户端。使用 GET 方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。同时，GET 方式的请求一般不包含实体主体内容，请求数据已通过在 URL 后添加字符串的方式添加到请求报文中。在 URL 后添加请求数据，各个数据之间用“&amp;”符号隔开。显然，这种方式不适合传送私密数据。虽然 HTTP 协议没有对传输的数据大小进行限制，HTTP 协议规范也没有对 URL 长度进行限制。但是由于浏览器和操作系统对 URL 字符的长度有所限制，所以我们可以认为添加到 URL 后面的请求数据也是有限的。所以如果需要传送大量数据的时候，也不适合使用 GET 方式。 POST——对于上面提到的不适合使用 GET 方式的情况，可以考虑使用 POST 方式，因为这时 POST 方法将请求参数封装在请求报文中的实体主体中，以名称/值的形式出现，可以传输大量数据，这样 POST 方式对传送的数据大小没有限制，而且也不会显示在URL中。各数据之间也是使用“&amp;”符号隔开。 HEAD——HEAD 就像 GET ，只不过服务端接受到 HEAD 请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用 HEAD 是非常高效的，因为在传输的过程中省去了页面内容。 响应报文每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。状态码（Status-Code）都是三位数字的，分为5大类共33种（见RFC 2616)。例如， lxx——表示通知信息的，如请求收到了或正在进行处理。 2xx——表示成功，如接受或知道了。 3xx——表示重定向，如要完成请求还必须采取进一步的行动。 4xx——表示客户的差错，如请求中有错误的语法或不能完成 5xx——表示服务器的差错，如服务器失效无法完成请求。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>理解计算机</tag>
        <tag>Web前端</tag>
        <tag>计算机网络</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 基础扫盲]]></title>
    <url>%2F2017%2F07%2F03%2FRxJava-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2%2F</url>
    <content type="text"><![CDATA[前几天浏览了一下稀土 App，发现有个挺不错的新闻 App 实战实例。正好最近想学习一下完整项目的源码（特别是后台代码，就是各种框架等等）。然后想起以前很多大牛都谈起过 RxJava、Retrofit、Gson 等等框架，所以现在决定来学习学习这些常用的框架 RxJava 到底是什么一个词概括：异步。说到底它就是一个实现异步操作的库。那什么是异步操作，我之前在Android 消息传递机制这篇博文中讲过 Android 是单线程模型。进程启动时，也就是 App 启动后默认就只有一个线程运行，而该线程就是我们说的主线程，也叫 UI 线程。顾名思义，UI 线程就是用来更新界面显示，而如果运行当中具有耗时操作如网络请求，数据库读写，文件下载等这些耗时操作都需要在其他线程当中去完成，完成之后再更新在 UI 界面中显示出来。这就是异步加载，而 Android 中我们有现成的方式去完成这一操作，如 AsyncTask 、Handler。那为什么还要用 RxJava？ RxJava 好在哪里还是用一个词概括：简洁。异步操作很关键的一点是要注意程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和 Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 假设有这样一个需求：界面上有一个自定义的视图 ImageCollectorView ，它的作用是显示多张图片，并能使用addImage(Bitmap)方法来任意增加显示的图片。现在需要程序将一个给出的目录数组folders中每个目录下的.png图片都加载出来并显示在 ImageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种： 1234567891011121314151617181920new Thread()&#123; @Override public void run()&#123; super.run(); for(File folder:folders)&#123; File[] files = folder.listFiles(); for(File file:files)&#123; if(file.getName().endsWith(".png"))&#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable()&#123; @Override public void run()&#123; mImageCollcetorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava，就可以写成：123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File,Observable&lt;File&gt;&gt;()&#123; @Override public Observable&lt;File&gt; call(File file)&#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File,Boolean&gt;()&#123; @Override public Boolean call(File file)&#123; return file.getName().endsWith(".png"); &#125; &#125;) .map(new Func1&lt;File,Bitmap&gt;()&#123; @Override public Bitmap call(File file)&#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;()&#123; @Override public void call(Bitmap bitmap)&#123; mImageCollectorView.addImage(bitmap); &#125; &#125;); 那看到这里有人可能说了这代码敲得更多了，哪来的简洁。注意，我们这里说的简洁指的是逻辑上的简洁，不是单纯的代码量少。观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显。 RxJava 原理与使用简析原理RxJava 的异步实现是通过一种通用概念下的观察者模式来实现的。那么我们了解一下设计模式当中的观察者模式。 观察者模式面向的需求是：A 对象(观察者)对 B 对象(被观察者)的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者(例如 A 不需要每过 2ms 就检查一次 B 的状态)，而是采用注册(Register)或者称为订阅(subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过setOnClickListener()方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。它有四个基本概念：Observable(被观察者)、Observer(观察者)、subscribe(订阅)、事件。Observable 与 Observer 通过 subscribe 订阅这一动作联系在一起，从而使 Observable 可以在需要的时候发出事件来通知Observer。RxJava 的事件回调方法除了普通事件 onNext() 之外，还定义了两个特殊的事件 onCompleted() 和 onError()。这些方法具体内容如下： onCompleted()——事件队列完结。RxJava 不仅把每个事件单独处理，还会把他们看做一个队列。RxJava 规定如果队列处理完毕，需要回调此方法作为标志 onError()——事件队列异常。在事件处理过程中出现异常时，此方法会被回调，同时事件停止发出 在一个正确运行的事件序列中， onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是， onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 使用1.创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;()&#123; @Override public void onNext(String s)&#123; Log.d(TAG,"Item:"+s); &#125; @Override public void onCompleted()&#123; Log.d(TAG,"Completed!"); &#125; @Override public void onError(Throwable e)&#123; Log.d(TAG,"Error!"); &#125;&#125; 其实 RxJava 中还有一个实现了 Observer 接口的抽象类 Subscriber。这两个类基本使用方式一样，而且在subscribe()时 Observer 对象先被转换成 Subscriber 对象再使用。但他们的区别对于使用者来说主要有两点： onStart()——这是 Subscriber 增加的方法。它会在subscribe()刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， 该方法就不适用了，因为它总是在subscribe()所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用doOnSubscribe()方法。 unsubscribe()——这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如onPause()、onStop()等方法中）调用unsubscribe()来解除引用关系，以避免内存泄露的发生。 2.创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。它有三种方法来创建一个 Observable，并为它定义事件触发规则 create() 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;()&#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber)&#123; subscriber.onNext("Hello"); subscriber.onNext("Hi"); subscriber.onNext("Aloha"); subscriber.onCompleted(); &#125;&#125;); create()方法的参数 OnSubscribe 相当于一个计划表，当 Observable 被订阅时 OnSubscribe 的call()方法会被自动调用，事件序列就会依照设定依次触发(对于上面的代码，就是观察者 Subscriber 将会被调用三次onNext()和一次onCompleted())。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 just() 123456Observable observable = Observable.just("Hello","Hi","Aloha");//将会依次调用//onNext("Hello");//onNext("Hi");//onNext("Aloha");//onCompleted(); from(T[] t) 1234567String[] words = &#123;"Hello","Hi","Aloha"&#125;;Observable observable = Observable.from(words);//将会依次调用//onNext("Hello");//onNext("Hi");//onNext("Aloha");//onCompleted(); 3.subscribe()订阅创建了 Observable 和 Observer 之后，再用subscribe()方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer);//或者observable.subscribe(subscriber); 我们再来关注一下subscribe()方法的内部实现 123456public Subscription subscribe(Subscriber subscriber)&#123; ...... subscriber.onStart(); onSubscriber.call(subscriber); //事件发送逻辑开始运行 return subscriber;&#125; 4.线程控制在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler (调度器)。 在 RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate()——直接在当前线程运行，相当于不指定线程。这是默认的情况。 Schedulers.newThread()——总是启用新线程，并在新线程执行操作。 Schedulers.io()——I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和newThread()差不多，区别在于该方法的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下该方法比newThread()更有效率。不要把计算工作放在该方法中，可以避免创建不必要的线程。 Schdeulers.computation()——计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread()——它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用subscribeOn()和observeOn()两个方法来对线程进行控制了。 subscribeOn()指定subscribe()所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn() 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。举个例子 123456789Observable.just(1,2,3,4) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action&lt;Integer&gt;()&#123; @Override public void call(Integer number)&#123; Log.d(TAG,"number:"+number); &#125; &#125;) 上面这段代码中，由于subscribeOn(Schedulers.io())的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于observeOn(AndroidScheculers.mainThread())的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种使用方式非常常见，它适用于多数的『后台线程取数据，主线程显示』的程序策略。 总结对于 RxJava，我们应该记住两个关键字：异步、简洁。而 RxJava 还有一些比较重要的关键点需要理解，但本篇仅仅用于向初学者普及 RxJava 的一些简单原理和使用方法，更多内容大家可以查看给 Android 开发者的 RxJava 详解。 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记(一)]]></title>
    <url>%2F2017%2F06%2F30%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本文章只是个人记录日常学习的笔记，将不定期更新 2017.3.11 2017.3.14 Android 线程与进程 Android app 启动过程 Service 与耗时工作线程的区别 何时使用 Service，何时使用 Working Thread 即 UI 线程（主线程）开启耗时操作线程 Local Service 与 Remote Service Service 的使用（实时温度显示客户端） 2017.3.16 Service 与 Activity交互 Service 开启线程后与 Activity 交互，注意线程之间的数据传递要么用 Handler 或者 AsyncTask 类 只能在 UI 主线程更新界面的真正含义（慕课网笔记） 2017.3.20 ArrayBlockingQueue 是阻塞队列且线程安全 线程池的使用 2017.3.21 HandlerThread 与 Handler 的关系 Handler , Looper , MessageQueue 与线程的关系 2017.3.22知乎 live 总结 要有兴趣学安卓 边学边实践项目，加深印象 需要用什么就学什么 巩固计算机基础知识，如操作系统、计算机网络、熟练掌握两三门编程语言 关注新兴技术，比如人工智能 2017.3.25 一次只有一个进程可以在一个处理器核心上运行 单线程模型：一个进程是一个只能进行单个执行线程的程序 “超线程”（Hyperthreading Technology）技术就是通过采用特殊的硬件指令，可以把一个物理内核模拟成两个逻辑内核，在单处理器中实现线程级的并行计算，同时在相应的软硬件的支持下大幅度提高运行效能，从而实现在单处理器上模拟双处理器的效能。其实，从实质上说，超线程是一种可以将 CPU 内部暂时闲置处理资源充分“调动”起来的技术。虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的 CPU 那样，每个 CPU 都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗 CPU 的性能 一个应用程序通常是作为一个具有多个控制线程的独立进程实现的 多进程的优点之一就是能够充分使用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。而使用多线程加强了并发功能（在不谈论 Intel 的超线程技术） 数据结构是一堆数据元素和这些数据元素之间关系的总和，数据元素是数据的基本单位 按关系或结构分。数据结构可归结为以下4类：集合结构、线性结构、树形结构和图状结构 2017.4.8 内存可以看作是所有小房间连续线性排列而组成的大房子 为了标识大房子中的某一个小房子，我们给所有小房子编号，这就是内存地址，或者叫指针。指针就是特别指向了某一个小房子以方便找出房子里存储的货物（数据）。指针本质就是内存空间地址 而新建一个以链表为存储结构的线性表，如 List a；“a”所代表的含义其实就是这个链表的头指针，指向链表的第一个数据单元结点 2017.4.10模块化设计根据模块化程序设计思想，采用分解法把问题分解为多个相对独立的子问题，每个子问题对应程序的一个功能模块 C语言程序文件结构一个源程序文件一般定义多个函数解决复杂问题。一个C程序由一个或多个源程序文件组成。 C语言参数传递12int x=10,y=100;swap(x,y); 按照C语言的参数传递规则，实参变量x和y的值分别被“单向传递”给形参变量a和b。数组元素作为函数参数，这种情况下与简单变量作为函数的参数完全一样，数组元素的值被单向传递给形参变量。另一种情况是数组名作为函数的参数，此时作为实参的数组名讲其存储的数组的首地址单向传递给作为形参的数组名。所以第二种情况下实参数组名和形参数组名中存放相同的地址，实际上实参数组名和形参数组名代表的是同一个数组。这样，如果在被调函数中通过形参数组名去改变数组元素，则程序流程返回主调函数后，实参数组名对应的数组内容也随之变化 单个C语言源程序文件的全局变量由于C语言是以源程序文件为单位进行编译的，所以在一个源程序文件中定义的全局变量，默认情况下不能在其他源程序文件中使用 内存空间分类C 语言中，供用户程序运行使用的内存空间分为3个部分：程序区、静态存储区、动态存储区 程序区：存放可执行的程序指令 静态存储区：存放程序运行期间占用固定内存单元的变量，比如全局变量、静态局部变量等 动态存储区：存放程序运行期间根据需要动态分配存储单元的变量，比如非static的局部变量、函数的形参等 局部变量局部变量的存储类别有自动、静态、寄存器。全局变量的存储类别有外部和静态。外部全局变量(外部函数)允许其他源程序文件直接使用。而静态全局变量(内部函数)只允许在本源程序文件中使用 内存原貌数据在程序的运行过程中存储在计算机内存中，而内存是以字节为基本存储单元的连续存储空间。为了能够标识内存中不同的存储单元，每个存储单元都有一个编号，这个编号就是内存单元的“地址”。每个变量的值存储在内存空间中，通过变量名访问变量的值，这就是“按名访问”。“直接访问”是通过存储单元的地址读取其中的值。变量名在编译器中会与实际内存地址关联 什么是指针变量一个变量的内存地址称为该变量的“指针”。如果把一个变量的指针(地址)存放到另一个变量中，则存放指针的变量称为“指针变量”。其中指向结构体类型数据的指针变量称为结构体指针变量，他存放结构体变量的起始地址。 2017.4.23 带参数的宏的定义：一切都要括号，指整个值要括号，参数出现的每个地方都要括号 2017.4.24 子网划分是某个网络内部的事情。在某个网络之外的视角下他是不具有子网的特点。只有当IP数据报传入到与该网络相连的路由器上时。该网络内部的子网划分就会将整个网络划分为若干个子网网络，每个子网络的标识就是由网络号和主机号重新组合形成的广义上的网络号。 由于子网划分是一个网络在内部的特性，所以某个网络的子网掩码是一定的。而为了节省地址资源，后来使用了变长子网掩码来根据实际情况在子网下再划分子网，所以一个网络下就存在多个子网掩码，这样可进一步提高IP地址资源的利用率。 2017.4.261.内存中的堆栈：操作系统对于正在运行的进程会分配一个独立的内存空间，这个内存空间在逻辑上分为3个部分：代码区、静态数据区和动态数据区。其中动态数据区一般又分为“堆”与”栈”。“栈stack”和“堆heap”是两种不同的动态数据区。 栈空间是由栈操作系统自动分配和释放，该部分主要用于存放函数的参数值、局部变量等。栈区的操作方式类似于数据结构中栈。 堆区空间一般由程序员分配和释放，如 C 语言中的malloc函数申请的空间就是堆空间。 静态数据区：全局变量和静态变量都存放于该区。初始化的全局变量和初始化的静态变量放在一块区域，未初始化的全局变量和未初始化的静态变量放在相邻的另一区域。程序结束后由系统自动释放。 代码区：该区用于存放函数体的二进制代码。 2.数据结构的堆栈：数据结构意义上的”栈“是逻辑概念，具有后进先出的特点。而数据结构意义上的“堆”是一种树形结构，其满足树中任一非叶结点的关键字均不大于或不小于其左右子树的结点的关键字。 2017.4.27 Android 作为一个移动设备平台，其软件层次结构包括操作系统、各种库和 Android 运行环境、应用程序框架和应用程序。 Android 运行环境主要指虚拟机技术—— Dalvik 虚拟机。Dalvik 虚拟机和一般 Java 虚拟机不同，他执行的不是 Java 标准的字节码而是 Dalvik 可执行格式（.dex）中执行文件。他们两者最大不同就是 Java 虚拟机是基于栈的虚拟机，而 Dalvik 是基于寄存器的虚拟机。 Android 的应用程序框架这一层级为应用程序的开发者提供 APIs。就是我们常说的 Android 四大组件 Activity、Broadcast Receiver、Service、Content Provider。 XML 只是一种简单的数据存储语言，只用来存储数据，而 HTML 是用来表现数据的。 多种编程语言都支持获取 XML 文档。 CSS 技术是 Web 网页技术的重要组成，页面通过 CSS 的修饰可以实现用户需要的显示效果。 JavaScript 是一种脚本技术，页面通过脚本程序可以实现用户数据的传输和动态交互。 2017.4.28socketSocket 是支持 TCP/IP 协议的网络通信基本操作单元，是操作系统为应用程序提供的一套针对 TCP 或 UDP 的编程接口。而类似 HttpURLConnection 、ftpClient 之类的类是基于 Socket 对应用层专属协议的封装。 递归函数递归函数是一层一层调用函数的。而在计算机中函数调用是通过栈(stack)这种数据结构实现，每当调用一层函数，栈就会加一层栈帧，每当函数返回，栈就会减少一层栈帧。所以递归用的不好可能会导致栈溢出。或者运行时间特别长。递归调用过程必须在进行有限次后终止，这就必须在编写递归调用函数时进行条件控制 尾递归尾递归：在函数返回时只调用自身。尾递归在执行过程中不需要回溯。因为尾递归把结果包含在一部分参数中。故每次调用实际上都是对参数的一个更新过程。 2017.5.3 运输层的“端口”概念可以类比于一个机构的收发室，这个机构收发公文都由这个收发室负责。而运输层中具体的某一个端口号可以认为是收发室中负责机构中某一个部门（可以理解为进程）收发公文的工作人员。而且这个端口号（工作人员）不是一直固定负责具体某个部门收发公文的工作（工作时由某个进程占有，通信结束后解除占有），可以在空闲时也为其他部门工作。 每一个 TCP 连接只能连接两个端点，就是点对点通信。而这个“点”就是我们通常所说的套接字 socket 。但是“套接字”这个翻译非常不准确，我们可以讲 socket 理解为插座，而 TCP 逻辑连接实体化为普通电线。而 socket 本身的翻译就是“插座，接头” 2017.5.4 注意回调机制和监听器的设计模式 注意 Android 项目目录下的 drawable 和 mipmap 文件夹的不同 关于回调机制的理解：Java 是面向对象语言，一切万物皆对象。父类暴露一个接口，接口内有一个抽象方法。该抽象方法不在父类中实现，而是在其他继承这个接口的类中实现。为了就是父类的实例能够根据实际情况各自做出反应。比如Button、ImageButton等都具有可被点击的共性，但是被点击之后相关事件的处理是不同的，比如说我想点击的这个Button弹出一个消息提示，然而我希望我的ImageButton点击之后可以弹出一个Notifaction通知，这个时候回调方法的好处就体现出来了。通过暴露接口方法可以减少很多重复，代码更加优雅。Android 当中的各种监听器采取的设计模式也是回调机制，设计模式如下: 1234567891011121314public class A&#123; private CallBack mCallBack; public interface CallBack&#123; public abstract void work(); &#125; public void setCallBack(CallBack callBack)&#123; this.mCallBack=CallBack; &#125; //调用回调接口对象中的方法 public void doWork()&#123; mCallBack.work(); &#125;&#125; 123456789public class B&#123; private A a; a.setCallBack(new A.CallBack()&#123; @Override public void work()&#123; ...... &#125; &#125;)&#125; 使用对话框最好采用 DialogFragment ，因为 DialogFragment 具有完整的生命周期，方便管理。代码如下： 12345678910111213141516171819202122232425262728293031323334public class MapLayerDialog extends DialogFragment &#123; private ImageButton btn_normal, btn_satellite; //把它理解成监听者 public interface ChoiceListener &#123; void onMapLayerListener(int view); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View view = inflater.inflate(R.layout.maplayer_choice_dialog, container); btn_normal = (ImageButton) view.findViewById(R.id.NORMAL_layer); btn_satellite = (ImageButton) view.findViewById(R.id.SATELLITE_layer); btn_normal.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ChoiceListener listener= (ChoiceListener) getActivity(); listener.onMapLayerListener(R.id.NORMAL_layer); &#125; &#125;); btn_satellite.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ChoiceListener listener= (ChoiceListener) getActivity(); listener.onMapLayerListener(R.id.SATELLITE_layer); &#125; &#125;); return view; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity implements LocationSource, AMapLocationListener,MapLayerDialog.ChoiceListener &#123; //把监听者的功能赋予 Activity private MapView mMapView; private AMap mAMap; private MyLocationStyle mMyLocationStyle; OnLocationChangedListener mListener; AMapLocationClient mLocationClient; AMapLocationClientOption mLocationOption; private ImageButton mImageButton; private Context mContext; @Override protected void onCreate(Bundle savedInstanceState) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext=this; mMapView = (MapView) findViewById(mapView); mMapView.onCreate(savedInstanceState); mImageButton=(ImageButton)findViewById(R.id.choiceDialog); mImageButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; MapLayerDialog mapLayerDialog=new MapLayerDialog(); mapLayerDialog.show(getFragmentManager(),"ChoiceMapLayer"); &#125; &#125;); init(); &#125; ...... ...... @Override public void onMapLayerListener(int view) &#123; switch (view)&#123; case R.id.NORMAL_layer:mAMap.setMapType(AMap.MAP_TYPE_NORMAL); break; case R.id.SATELLITE_layer:mAMap.setMapType(AMap.MAP_TYPE_SATELLITE); break; &#125; &#125;&#125; 2017.5.11 Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。 Intent 一般可被用于启动活动、启动服务、以及发送广播等场景 2017.5.14 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 如何保证Service不被杀死或被kill之后自动重启：利用系统广播(Intent.ACTION_TIME_TICK)每隔一分钟检测一次Service的运行状态。 2017.6.10 当应用继承 ContentProvider 类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用 SharedPreferences 共享数据，需要使用 SharedPreferences API 读写数据。而使用 ContentProvider 共享数据的好处是统一了数据访问方式。‍‍ 服务不能自己运行，需要通过调用 Context.startService() 或者 Context.bindService() 方法启动服务。这两个方法都可以启动 Service，但是它们的使用场合有所不同。使用 startService() 方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用 bindService() 方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 2017.6.11 Android 的官方建议应用程序的开发采用MVC 模式。MVC 是 Model,View,Controller 的缩写，MVC 包含三个部分： 模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 视图层（view）：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 控制层（controller）：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给模型层处理。 Service 和 Thread 的区别？答：Service 是系统的组件，它由系统进程托管（ServiceManager）；它们之间的通信类似于 Client 和 Server，是一种轻量级的IPC 通信，这种通信的载体是 Binder ，它是在 Linux 层交换信息的一种 IPC 机制。而 Thread 是由本应用程序托管。 Thread：Thread 是程序执行的最小单元，它是分配 CPU 的基本单位。可以用 Thread 来执行一些异步的操作。 Service：Service 是 Android 的一种机制，当它运行的时候如果是 Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是 Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。 既然这样，那么我们为什么要用 Service 呢？其实这跟 Android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被杀掉之后，如果你没有主动停止 Thread 或者 Thread 里的run方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被杀掉之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有创建并运行的时候也在运行。这个时候当你创建一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 2017.6.12 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？答：重写 onSaveInstanceState() 方法，在此方法中保存需要保存的数据，该方法将会在 Activity 被回收之前调用。通过重写onRestoreInstanceState() 方法可以从中提取保存好的数据 如何退出Activity？如何安全退出已调用多个 Activity 的 Application ？ 单个 Activity： finish() System.exit() 多个 Activity： 抛异常强制退出：该方法通过抛异常，使程序 Force Close。方法可行。但是需要解决的问题是，如何使程序结束掉，而不弹出 Force Close 的窗口 记录打开的 Activity：每打开一个 Activity，就记录下来。在需要退出时，关闭每一个 Activity 即可。 发送特定广播：在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可 递归退出：在打开新的 Activity 时使用startActivityForResult()，然后自己加标志，在onActivityResult()中处理，递归关闭 Activity 基类：让所有 Activity 继承这个基类，基类中定义一个方法解决这个关闭各个 Activity 的共同问题 请解释下Android程序运行时权限与文件系统权限的区别。 运行时权限 Dalvik ( Android 授权) 文件系统 Linux 内核授权 Android dvm 的进程和 Linux 的进程, 应用程序的进程是否为同一个概念答：DVM 指 dalivk 的虚拟机。每一个 Android 应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik 虚拟机实例。而每一个 DVM 都是在 Linux 中的一个进程，所以说可以认为是同一个概念。 2017.6.17###浏览器概述 浏览器之所以能够工作，它的核心是一个叫做「内核」的东西，这个内核就类似于汽车的引擎，没有它浏览器是没法工作的，而市面上的内核有很多种，比如：KHTML、Presto、Trident、WebKit 等，大家熟知的浏览器如 Firefox、IE、Opera、Chrome、Safari 等所用的内核都不一样，而 Chrome 和 Safari 浏览器所用的内核是一样的，叫做「WebKit」，WebKit 其实是苹果基于开源的内核 KHTML 来改造的，也是开源的。而内核其实又分为两部分：渲染引擎和 js 引擎。渲染引擎主要就是负责获取网页的 html、xml、图片、css 等内容进行渲染显示，js 引擎则负责解析 javascript 语言，实现网页的动态效果。Chrome 虽然也是基于 WebKit 内核的，但是 Google 一开始觉得 WebKit 自带的 js 引擎性能上有问题，所以 Google 专门为 Chrome 搞了个 js 引擎叫做「V8」，所以在内核方面，Chrome 和 Safari 的主要区别就在于 js 引擎不一样。 TCP主要过程TCP 是面向连接的协议。那么采用 TCP 协议的运输层的连接的建立和释放是每一次面向连接得通信中不可少的过程。因此运输层连接包含了连接建立、数据传送、连接释放。 三次握手、四次挥手运输层的连接建立过程也可称作三次握手 第一次握手：A 主动向 B 发出建立连接的请求 第二次握手：B 向 A 发出确认建立连接的请求 第三次握手：A 向 B 发出确认 至于为什么连接建立后客户进程 A 还要发送一次确认报文。这主要是为了防止已失效(已失效：滞留在网络中而后才到达B）的连接请求报文段突然又传到了服务进程 B 中而产生错误。 运输层的连接释放过程也称作四次挥手 第一次握手：A 主动向 B 发出释放连接的请求 第二次握手：B 向 A 发出确认释放连接的请求 第三次握手：B 主动向 A 发出释放连接的请求 第四次握手：A 向 B 发出确认释放连接的请求 经过四次握手过程，TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL 后客户进程 A 才进入 CLOSED 状态。而 B 只要收到了 A 发过来的确认就立即进入 CLOSED 状态。因此 B 结束 TCP 连接的时间要比 A 早一些。当然服务进程也会有一个保活计时器来探测客户端是否有响应。至于为什么是两倍的 MSL 时间是保证 A 发送的最后一个报文段能够到达 B 。 2017.6.20 RecyclerView 是 Android 5.0 系统官方推出的一个代替 ListView 的组件，ListView 和 RecycleView 的原理大致相同，如下图。都是在内部维护一个缓存池，回收划出列表的 item，添加给将要进入列表的 item。只不过 ListView 内部是两级缓存，分别是mActiveViews和mScrapViews。而 RecycleView 内部有四级缓存。 2017.6.25 应用层协议与网络应用并不是同一个概念。应用层协议只是网络应用的一部分。例如，万维网应用是一种基于客户-服务器体系结构的网络应用。万维网应用包含很多部件，有万维网浏览器、万维网服务器、万维网文档的格式标准，以及一个应用层协议。万维网的应用层协议是 HTTP，它定义了在万维网浏览器和万维网服务器之间传送的报文类型、格式和序列等规则，而万维网浏览器如何显示一个万维网页面，万维网服务器是用多线程还是多进程来实现并不是 HTTP 定义的内容 许多应用层软件经常直接使用域名系统 DNS。虽然计算机的用户只是间接而不是直接使用域名系统，但 DNS 却为因特网的各种网络应用提高了核心服务 因特网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户-服务器方式。 2017.6.30 设计模式原则：修改原有代码就说明解耦性太低。其次依赖倒转原则是让程序实体运行类都依赖抽象类，而不是实体运行类互相依赖。注意解耦！ 设计模式——观察者模式：观察者模式又叫做发布-订阅(Publish/Subsrcibe)模式。它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主体对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够 自动更新自己。 2017.7.1 响应式编程：响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。例如，在命令式编程环境中，a=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似=B1+C1的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。响应式编程最初是为了简化交互式用户界面的创建和实时系统动画的绘制而提出来的一种方法，但它本质上是一种通用的编程范式。 2017.7.2 从理论上来讲，可以让每一级的域名都有一个相对应的域名服务器，使所有的域名服务器构成树状结构。但这样做会使域名服务器的数量太多，使域名系统的运行效率降低。因此 DNS 就采用划分区的办法来解决这个问题。一个服务器所负责管辖的范围叫做区。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中所有主机的域名到 IP 地址的映射。因此 DNS 服务器的管辖范围是以”区“为单位的。 因特网上的 DNS 域名服务器也是按照层次安排的。每一个域名服务器都只对域名体系中的一部分进行管辖 根名服务器：根域名服务器是最高层次的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。因特网上任何一个域名的解析，只要在本地服务器无法解析，就首先要求助于根域名服务器。因此根域名服务器的工作情况对整个 DNS 系统的工作至关重要。同时在许多情况下，根域名服务器并不直接把待查询的域名直接转换成 IP 地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询 顶级域名服务器：这些域名服务器负责在该顶级域名服务器注册的所有二级域名 本地域名服务器：本地域名服务器并不属于域名服务器层级结构中。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个因特网服务提供者 ISP ，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器 文件传送协议 FTP 只提供文件传送的一些基本服务，它使用了 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。FTP 使用C/S 模式，即客户服务器模式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程有两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。FTP 的工作情况如图所示，图中的服务器端有两个从属进程：控制进程和数据传送进程。客户端除控制进程和数据传送进程还有一个用户界面进程。文件进行传输时 FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。 万维网 WWW 并非某种特殊的计算机网络。万维网是一个大规模的、联机式的信息储藏所，英文简称为 Web。万维网用链接的方法能非常方便地从因特网上一个站点访问另一个站点。 万维网是一个分布式的超媒体系统，它是超文本系统的扩充。所谓超文本是包含指向其他文档的链接的文本。超文本是万维网的基础。超媒体与超文本的区别是文档内容不同，超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。 2017.7.3 统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符 URL。URL 是与因特网相连的机器上的任何可访问对象的一个指针。URL 的一般形式由以下四个部分组成： &lt;协议&gt;://&lt;主机域名&gt;:&lt;端口&gt;/&lt;路径&gt; 使用超文本传送协议 HTTP(HyperText Transfer Protocol)实现万维网上各种链接 万维网使用超文本标记语言 HTML(HyperText Markup Language)使得万维网网页的设计者可以很方便地用链接从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。 2017.7.4 应用需要因特网的支持，但这些应用又不能直接使用已经标准化的因特网协议，那么我们应当了解一下系统调用和应用编程接口 大多数操作系统使用系统调用的机制在应用程序和操作系统之间传递控制权。 当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API(Application Programming Interface) 现在 TCP/IP 协议软件已驻留在操作系统中。因此 TCP/IP 标准没有规定应用程序与 TCP/IP 协议软件如何接口的细节。目前只有几种可供应用程序使用 TCP/IP 的应用编程接口 API——Socket 在讨论网络编程时常常把套接字作为应用进程与运输层协议之间的接口。在套接字以上的进程是受应用程序控制的，而在套接字一下的运输层协议软件则是受计算机操作系统的控制。因此，只要应用程序使用 TCP/IP 协议进行通信，他就必须通过套接字与操作系统交互并请求其服务。由此可见套接字是应用进程为了获得网络通信服务而与操作系统进行交互使用的一种机制。 TCP 系统调用过程： 连接建立阶段——应用进程创建套接字并绑定来指明本地端口号和本地 IP 地址。服务器进程同样过程，但之后需要调用 listen 把套接字设置为被动方式。紧接着调用 accept 以便把远地客户进程发来的连接请求提取出来。该服务进程也称为主服务器进程就为每一个新的连接请求创建一个新的套接字，并把这个新创建的套接字的识别符返回给发起连接的客户进程。与此同时，主服务器进程还要新创建一个从属服务器进程来处理新建立的连接。这样，从属服务器进程用这个新创建的套接字和客户进程建立连接，而主服务器进程用原来的套接字重新调用 accept ，继续接受下一个连接请求。客户进程调用 connect ，以便和远地服务器建立连接，此过程必须指明远地服务器的 IP 地址和端口号 数据传送阶段——客户和服务器都在 TCP 连接上使用 send 系统调用传送数据，使用 recv 系统调用接受数据。调用 send 需要三个变量：数据要发往的套接字的描述符、要发送数据的地址(操作系统的内核的缓存中)以及数据的长度。调用 recv 也需要三个变量：套接字的描述符、缓存地址以及缓存空间的长度 连接释放阶段——一旦任何一方结束使用套接字，就把套接字撤消。这时就调用 close 释放连接和撤消套接字 UDP 服务器只提供无连接服务，因此不使用 listen 和 accept 系统调用 2017.7.8 HTTP 是面向事务的应用层协议 当我们点击了网页当中的某个链接，如“清华大学院系设置”的页面，其 URL 是 http://www.tsinghua.edu.cn/chn/yxsz/index.html。下面我们将列举用户点击鼠标后所发生的几个事件 浏览器分析链接指向页面的 URL 浏览器向 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址 域名系统 DNS 解析出清华大学服务器的 IP 地址为 116.111.4.100 浏览器与服务器建立 TCP 连接（第一次握手，服务器需要发出确认连接报文） TCP 建立连接的第三次握手中浏览器发出取文件命令（具体查看 HTTP 协议的请求报文） 服务器给出相应，发出响应报文 释放 TCP 连接 浏览器解析渲染得到的 html 文件显示网页 2017.7.11 XHTML 是更严格更纯净的 HTML 版本 在数据交换， 配置文件， 任务和流程的描述， Web服务的描述， 还有界面描述领域都取得了成功 XML 是独立于软件和硬件的信息传输工具 XHTML 是更严格更纯净的 HTML 版本 XHTML 是作为一种 XML 应用被重新定义的 HTML 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>理解计算机</tag>
        <tag>Android</tag>
        <tag>计算机网络</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文搬运]]></title>
    <url>%2F2017%2F06%2F28%2F%E5%8D%9A%E6%96%87%E6%90%AC%E8%BF%90%2F</url>
    <content type="text"><![CDATA[本篇不生产博文，而只是简书博文的搬运工 说明 其实本人在今年情人节的时候就在简书上开通了个人账号。本来打算一个月更新5篇左右，后来发现并不是什么时候都有干货能写出来。我也不想让大家花时间去看一些没有意义的东西，所以我如果更新了博文，那么它肯定是花了我很多时间和精力写的。所以也希望学习开发的朋友能从我这得到你们想要的答案。 搬运的博文 Android自定义圆形进度条源码解析 Android 消息传递机制 进程与线程、并发与并行，傻傻分不清 Java基础课程——static代码块 翻滚吧！Scroller Android事件分发机制的系统性解析 Android Studio日常使用技巧 关于我、我的博客、我的Android开发之路]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的新天地]]></title>
    <url>%2F2017%2F06%2F27%2F%E6%88%91%E7%9A%84%E6%96%B0%E5%A4%A9%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[本篇更新自简书博客 开篇尬谈 真是没想到，时间过得可真快。距离上篇博文的发布正好两个月了。关注我的网友可能会问“说好的持续更新呢”（泪目，啪啪打脸），其实说不定关注我的网友都可能忘了我这茬事（别说了，人艰不拆）。哈哈，跟大家开开玩笑先。我跟大家聊聊我自从上次更新博文之后为什么那么久没更新以及中间遇到的事吧 我干什么去了 其实自从4.27号更新以后，我们专业的课程基本都已经结课了。后面陆陆续续的当然就是各种各样的考试（其实要考试的科目也不多，总共4科）。基本五月份开始就是一星期一门期末考试。而我很自信的整个学期都没有怎么去上专业课，基本都是在图书馆捣鼓我的开发。估计这段生活经历也是我过得最大胆的一次，因为之前无论在老师还是在家长、同学、朋友面前我给大家留下的都是一个好学生的印象。接下来大家可能都能猜到：五月份就基本边自己学习开发边复习课程准备期末考试。就这样一个月就过去了，但是我这个专业对我来说还有一个大 bug ，就是六月份还得去湖北十堰进行专业实践实习半个月，这属于教学计划，很难申请不去这个实习。没办法我就把这次实习看成一次旅行，因为我已经对本专业没有任何感觉了，就很陌生。六月中旬就回到广州了，这也是我本人第一次出省，顺便说一下本人真的很喜欢北方的那种人文氛围，除了一开始去到那里对吃辣，澡堂，厕所这几样东西不习惯之外（其实后面也习惯了），真的感觉是我好像就像那里的本地人一样。对周围的一切事物感觉很舒服，很适应。 回到广州之后基本上这个学期也就结束了。之后我就开始尝试寻找 Android 开发工程师的实习。那几天就不断的在各大招聘 App 上投简历，想着广撒网，看能不能钓上大鱼。喜悦的是陆陆续续能收到一些面试通知，但经历的几次面试来说，就只有少数几个是比较正规的实习生招聘面试，其余都是培训机构（又一次泪目）。所以在这里还是要提醒一下大家现在很多培训机构都在招聘 App 上以招聘实习生的名义去找培训生。可能会有人说培训班这条路是进入 IT 行业比较常见的一种方式，特别对于非科班生来说。一开始不了解培训机构的我也是这么认为，可后面去仔细了解过后深思熟虑，觉得培训班这条路子并不适合我个人。因为很有可能在培训班学到的知识还不如我自己学习来的更有效果（在学习上我从小到大就是一个很有自主性的人，对学习有自己的规划）。况且培训班的学习目的很强，不利于以后的职业的多方向发展。但是培训班那种学习的氛围也是很让人羡慕。综合来看，最起码现在来说走培训班这条路并不是我现在最明智的选择。而在仅有的几次正规实习生招聘面试中我也收获到了一些面试经验以及自我肯定，面试中两位技术面试官先后考验我开发技术的问题。第一位面试官问的都是 Android 开发的知识，比较基础，没有问到很偏的问题。第二位面试官就问的都是专业基础知识，比如操作系统，数据结构，排序算法等等。其实两位面试官问的问题我都有接触过，但因为有些知识点在学习之后没有去实际应用，就忘得特别快，而我刚好从湖北十堰回来没有好好准备面试。所以总体面试表现一般。这也是我现在自学 Android 开发最大的问题——没有在实际项目中去应用自己学到的知识。那这里肯定有人会说那就去找项目做啊？其实我自己也有一些想做的项目，但是每次一做项目就会有各种各样的问题难以用谷歌或百度搜索解决问题，即使找到解决办法又还得自己去验证技术的准确性，导致整个项目进度拖得太慢，后面因为没有阶段性结果就难以坚持下去。这时候就好希望能有人给我一个方向性的指导。这也是我为什么想找实习的原因：一是希望在实际项目中加深对知识的理解；二是希望能认识一些技术大牛对自己指导一下，提高开发效率。面试官最后对我的评价就是专业基础一般。仅仅这个评价对我来说就是肯定了我自己在前两个月自学专业基础课程的努力。因为毕竟在两三个月前自己还是对计算机网络以及算法，数据结构知识略知一二。当然这个评价不足以让我获得想要的工作，所以后面还是需要继续提高水平。 记得知乎上有个程序猿这么说“如果自学不能为你带来一份工作，那么你也可能不适合这份职业”。也记得其他人说过开发这种东西是需要时间积累，就是所谓的厚积薄发。总之，我选择了自己的道路就希望能一直走下去。 个人博客预告 我现在说说我的个人博客吧。从湖北回来后我就有了想搭建独立博客的想法，因为老觉得搭建独立博客平台逼格更大（哈哈，请允许我装装13先），说不定还能提高我更新博客的主动性，以后打算博文更新在我搭建的博客上。就这样用一两天的时间待在宿舍上谷歌，百度搜索教程初步成功搭建好了个人博客。域名是阿里买的，文档托管在 GitHub pages ，框架用的是 hexo，主题用的是 material。欢迎大家来我的博客踩踩！谢谢大家。 刘志宇的新天地 因为评论系统集成的是网易云跟帖，因为主题的原因现在还存在 PC 访问网页可能无法评论博文以及评论控件时隐时现的问题。这些问题还得通过后面的更新解决 本文作者：刘志宇 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
</search>
